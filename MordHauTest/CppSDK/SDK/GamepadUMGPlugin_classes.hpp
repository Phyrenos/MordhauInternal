#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GamepadUMGPlugin

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "UMG_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class GamepadUMGPlugin.VirtualCursorFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVirtualCursorFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DisableVirtualCursor(class APlayerController* PC);
	static void EnableVirtualCursor(bool bIsInputModeGame, class APlayerController* PC);
	static void FlushLastKeyPressed();
	static bool GetCursorViewportPosition(struct FVector2D* position);
	static class FName GetHoveredWidgetName();
	static bool GetHoveredWidgetPosition(struct FVector2D* position);
	static struct FKey GetLastKeyPressed();
	static bool IsAnalogCursorEnabled(class APlayerController* PC);
	static bool IsCursorOverInteractableWidget();
	static bool IsHoveringNewWidget();
	static bool IsHoveringSnapWidget();
	static void OverrideMaxSpeedHover();
	static void ResetMaxSpeedHover();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VirtualCursorFunctionLibrary">();
	}
	static class UVirtualCursorFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVirtualCursorFunctionLibrary>();
	}
};
static_assert(alignof(UVirtualCursorFunctionLibrary) == 0x000008, "Wrong alignment on UVirtualCursorFunctionLibrary");
static_assert(sizeof(UVirtualCursorFunctionLibrary) == 0x000028, "Wrong size on UVirtualCursorFunctionLibrary");

// Class GamepadUMGPlugin.GamepadCursorSettings
// 0x0150 (0x0188 - 0x0038)
class UGamepadCursorSettings final : public UDeveloperSettings
{
public:
	struct FRuntimeFloatCurve                     AnalogCursorAccelerationCurve;                     // 0x0038(0x0088)(Edit, Config, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     AnalogCursorScrollAccelerationCurve;               // 0x00C0(0x0088)(Edit, Config, NativeAccessSpecifierPrivate)
	float                                         MaxAnalogCursorSpeed;                              // 0x0148(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAnalogCursorSpeedWhenHovered;                   // 0x014C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorDragCoefficient;                       // 0x0150(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorDragCoefficientWhenHovered;            // 0x0154(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinAnalogCursorSpeed;                              // 0x0158(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorDeadZone;                              // 0x015C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorAccelerationMultiplier;                // 0x0160(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnalogCursorSize;                                  // 0x0164(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseEngineAnalogCursor;                            // 0x0168(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAnalogCursorNoAcceleration;                       // 0x0169(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16A[0x16];                                     // 0x016A(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseCursorSnapping;                                // 0x0180(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamepadCursorSettings">();
	}
	static class UGamepadCursorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamepadCursorSettings>();
	}
};
static_assert(alignof(UGamepadCursorSettings) == 0x000008, "Wrong alignment on UGamepadCursorSettings");
static_assert(sizeof(UGamepadCursorSettings) == 0x000188, "Wrong size on UGamepadCursorSettings");
static_assert(offsetof(UGamepadCursorSettings, AnalogCursorAccelerationCurve) == 0x000038, "Member 'UGamepadCursorSettings::AnalogCursorAccelerationCurve' has a wrong offset!");
static_assert(offsetof(UGamepadCursorSettings, AnalogCursorScrollAccelerationCurve) == 0x0000C0, "Member 'UGamepadCursorSettings::AnalogCursorScrollAccelerationCurve' has a wrong offset!");
static_assert(offsetof(UGamepadCursorSettings, MaxAnalogCursorSpeed) == 0x000148, "Member 'UGamepadCursorSettings::MaxAnalogCursorSpeed' has a wrong offset!");
static_assert(offsetof(UGamepadCursorSettings, MaxAnalogCursorSpeedWhenHovered) == 0x00014C, "Member 'UGamepadCursorSettings::MaxAnalogCursorSpeedWhenHovered' has a wrong offset!");
static_assert(offsetof(UGamepadCursorSettings, AnalogCursorDragCoefficient) == 0x000150, "Member 'UGamepadCursorSettings::AnalogCursorDragCoefficient' has a wrong offset!");
static_assert(offsetof(UGamepadCursorSettings, AnalogCursorDragCoefficientWhenHovered) == 0x000154, "Member 'UGamepadCursorSettings::AnalogCursorDragCoefficientWhenHovered' has a wrong offset!");
static_assert(offsetof(UGamepadCursorSettings, MinAnalogCursorSpeed) == 0x000158, "Member 'UGamepadCursorSettings::MinAnalogCursorSpeed' has a wrong offset!");
static_assert(offsetof(UGamepadCursorSettings, AnalogCursorDeadZone) == 0x00015C, "Member 'UGamepadCursorSettings::AnalogCursorDeadZone' has a wrong offset!");
static_assert(offsetof(UGamepadCursorSettings, AnalogCursorAccelerationMultiplier) == 0x000160, "Member 'UGamepadCursorSettings::AnalogCursorAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UGamepadCursorSettings, AnalogCursorSize) == 0x000164, "Member 'UGamepadCursorSettings::AnalogCursorSize' has a wrong offset!");
static_assert(offsetof(UGamepadCursorSettings, bUseEngineAnalogCursor) == 0x000168, "Member 'UGamepadCursorSettings::bUseEngineAnalogCursor' has a wrong offset!");
static_assert(offsetof(UGamepadCursorSettings, bAnalogCursorNoAcceleration) == 0x000169, "Member 'UGamepadCursorSettings::bAnalogCursorNoAcceleration' has a wrong offset!");
static_assert(offsetof(UGamepadCursorSettings, bUseCursorSnapping) == 0x000180, "Member 'UGamepadCursorSettings::bUseCursorSnapping' has a wrong offset!");

// Class GamepadUMGPlugin.InteractableWidget
// 0x0010 (0x0140 - 0x0130)
class UInteractableWidget final : public UOverlay
{
public:
	TDelegate<void()>                             OnInteractableWidgetHoveredDelegate;               // 0x0130(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableWidget">();
	}
	static class UInteractableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableWidget>();
	}
};
static_assert(alignof(UInteractableWidget) == 0x000008, "Wrong alignment on UInteractableWidget");
static_assert(sizeof(UInteractableWidget) == 0x000140, "Wrong size on UInteractableWidget");
static_assert(offsetof(UInteractableWidget, OnInteractableWidgetHoveredDelegate) == 0x000130, "Member 'UInteractableWidget::OnInteractableWidgetHoveredDelegate' has a wrong offset!");

// Class GamepadUMGPlugin.SnapWidget
// 0x0018 (0x0148 - 0x0130)
class USnapWidget final : public UOverlay
{
public:
	TDelegate<void()>                             OnSnapWidgetHoveredDelegate;                       // 0x0130(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              EscapeVelocity;                                    // 0x0140(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnapWidget">();
	}
	static class USnapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnapWidget>();
	}
};
static_assert(alignof(USnapWidget) == 0x000008, "Wrong alignment on USnapWidget");
static_assert(sizeof(USnapWidget) == 0x000148, "Wrong size on USnapWidget");
static_assert(offsetof(USnapWidget, OnSnapWidgetHoveredDelegate) == 0x000130, "Member 'USnapWidget::OnSnapWidgetHoveredDelegate' has a wrong offset!");
static_assert(offsetof(USnapWidget, EscapeVelocity) == 0x000140, "Member 'USnapWidget::EscapeVelocity' has a wrong offset!");

}

