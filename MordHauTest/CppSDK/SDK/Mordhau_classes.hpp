#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mordhau

#include "Basic.hpp"

#include "Mordhau_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "PhysXVehicles_classes.hpp"
#include "UMG_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "SlateCore_structs.hpp"
#include "InputCore_structs.hpp"
#include "MordhauOnlineSubsystem_structs.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "EngineSettings_structs.hpp"
#include "NavigationSystem_classes.hpp"
#include "PlayFab_structs.hpp"


namespace SDK
{

// Class Mordhau.RconCommand
// 0x0058 (0x0080 - 0x0028)
class URconCommand : public UObject
{
public:
	struct FRconCommandInfo                       CommandInfo;                                       // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bLogCommandUsage;                                  // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanExecuteCommand(const class FString& CommandType, class UPlayFabJsonObject* InCommand, const int32 ClientId, const int32 PacketId);
	bool ExecuteCommand(const class FString& CommandType, class UPlayFabJsonObject* InCommand, const int32 ClientId, const int32 PacketId);
	class UPlayFabJsonObject* RequestInfo(const int32 ClientId, const int32 PacketId);
	bool SendResponse(class UPlayFabJsonObject* ResponseObject, const int32 ClientId, const int32 PacketId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RconCommand">();
	}
	static class URconCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<URconCommand>();
	}
};
static_assert(alignof(URconCommand) == 0x000008, "Wrong alignment on URconCommand");
static_assert(sizeof(URconCommand) == 0x000080, "Wrong size on URconCommand");
static_assert(offsetof(URconCommand, CommandInfo) == 0x000028, "Member 'URconCommand::CommandInfo' has a wrong offset!");
static_assert(offsetof(URconCommand, bLogCommandUsage) == 0x000078, "Member 'URconCommand::bLogCommandUsage' has a wrong offset!");

// Class Mordhau.MuteListCommand
// 0x0000 (0x0080 - 0x0080)
class UMuteListCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MuteListCommand">();
	}
	static class UMuteListCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMuteListCommand>();
	}
};
static_assert(alignof(UMuteListCommand) == 0x000008, "Wrong alignment on UMuteListCommand");
static_assert(sizeof(UMuteListCommand) == 0x000080, "Wrong size on UMuteListCommand");

// Class Mordhau.MordhauMotion
// 0x0078 (0x00A0 - 0x0028)
class UMordhauMotion : public UObject
{
public:
	float                                         StartRealTime;                                     // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMordhauMotion*                         ComingFromMotion;                                  // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0038(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablesDodge;                                    // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCosmeticFlinch;                            // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurncapModifier;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpectedDelay;                                     // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0050(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeaveTime;                                         // 0x0054(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitiatedLocally;                                 // 0x0058(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasConfirmedByAuthority;                          // 0x0059(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConfirmedByAuthorityTime;                          // 0x005C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlinchable;                                     // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementRestriction                          MovementRestriction;                               // 0x0061(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedFactor;                                       // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackpedalSpeedFactor;                              // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEmote;                                         // 0x006C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAttack;                                        // 0x006D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBlock;                                         // 0x006E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablesAtmospherics;                             // 0x006F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequires3PArmsSync;                               // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablesCosmeticWeaponTransform;                  // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablesOffhandIK;                                // 0x0072(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablesChaseMechanic;                            // 0x0073(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForcesOffhandIK;                                  // 0x0074(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOffhandIsRightHand;                               // 0x0075(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffhandIKChangeSpeed;                              // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CosmeticTransformChangeSpeed;                      // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffhandIKDistanceMax;                              // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffhandIKDistanceMin;                              // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlocksRegen;                                      // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDedicatedServerAnimLOD;                      // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesLeftTorsoBlend;                               // 0x008A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B[0x1];                                       // 0x008B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftTorsoBlendSpeed;                               // 0x008C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsRightLegBending;                             // 0x0090(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RightLegBendingChangeSpeed;                        // 0x0094(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsSlowLookSmoothing;                           // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookSmoothingChangeSpeed;                          // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CanInitiateMotion(TSubclassOf<class UMordhauMotion> NewMotionType);
	void OnBegin();
	void OnDynamicParamChanged(uint8 OldValue, uint8 NewValue);
	void OnEnded();
	void OnLateTick(float DeltaTime);
	void OnLeave(bool Interrupted);
	void OnTick(float DeltaTime);
	bool ProcessAttack(EAttackMove Move, float Angle);
	bool ProcessBlock(EBlockType Type);
	bool ProcessFeint();

	bool GetIsFirstPerson() const;
	class UMotionSystemComponent* GetOwner() const;
	class AActor* GetOwnerActor() const;
	class AAdvancedCharacter* GetOwnerAdvancedCharacter() const;
	class AMordhauCharacter* GetOwnerMordhauCharacter() const;
	class UWorld* GetWorld() const;
	bool HasAuthority() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauMotion">();
	}
	static class UMordhauMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauMotion>();
	}
};
static_assert(alignof(UMordhauMotion) == 0x000008, "Wrong alignment on UMordhauMotion");
static_assert(sizeof(UMordhauMotion) == 0x0000A0, "Wrong size on UMordhauMotion");
static_assert(offsetof(UMordhauMotion, StartRealTime) == 0x000028, "Member 'UMordhauMotion::StartRealTime' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, ComingFromMotion) == 0x000030, "Member 'UMordhauMotion::ComingFromMotion' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, Tag) == 0x000038, "Member 'UMordhauMotion::Tag' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bDisablesDodge) == 0x000040, "Member 'UMordhauMotion::bDisablesDodge' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bDisableCosmeticFlinch) == 0x000041, "Member 'UMordhauMotion::bDisableCosmeticFlinch' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, TurncapModifier) == 0x000044, "Member 'UMordhauMotion::TurncapModifier' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, ExpectedDelay) == 0x000048, "Member 'UMordhauMotion::ExpectedDelay' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, StartTime) == 0x00004C, "Member 'UMordhauMotion::StartTime' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, EndTime) == 0x000050, "Member 'UMordhauMotion::EndTime' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, LeaveTime) == 0x000054, "Member 'UMordhauMotion::LeaveTime' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bInitiatedLocally) == 0x000058, "Member 'UMordhauMotion::bInitiatedLocally' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bWasConfirmedByAuthority) == 0x000059, "Member 'UMordhauMotion::bWasConfirmedByAuthority' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, ConfirmedByAuthorityTime) == 0x00005C, "Member 'UMordhauMotion::ConfirmedByAuthorityTime' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bIsFlinchable) == 0x000060, "Member 'UMordhauMotion::bIsFlinchable' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, MovementRestriction) == 0x000061, "Member 'UMordhauMotion::MovementRestriction' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, SpeedFactor) == 0x000064, "Member 'UMordhauMotion::SpeedFactor' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, BackpedalSpeedFactor) == 0x000068, "Member 'UMordhauMotion::BackpedalSpeedFactor' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bCanEmote) == 0x00006C, "Member 'UMordhauMotion::bCanEmote' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bCanAttack) == 0x00006D, "Member 'UMordhauMotion::bCanAttack' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bCanBlock) == 0x00006E, "Member 'UMordhauMotion::bCanBlock' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bDisablesAtmospherics) == 0x00006F, "Member 'UMordhauMotion::bDisablesAtmospherics' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bRequires3PArmsSync) == 0x000070, "Member 'UMordhauMotion::bRequires3PArmsSync' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bDisablesCosmeticWeaponTransform) == 0x000071, "Member 'UMordhauMotion::bDisablesCosmeticWeaponTransform' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bDisablesOffhandIK) == 0x000072, "Member 'UMordhauMotion::bDisablesOffhandIK' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bDisablesChaseMechanic) == 0x000073, "Member 'UMordhauMotion::bDisablesChaseMechanic' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bForcesOffhandIK) == 0x000074, "Member 'UMordhauMotion::bForcesOffhandIK' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bOffhandIsRightHand) == 0x000075, "Member 'UMordhauMotion::bOffhandIsRightHand' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, OffhandIKChangeSpeed) == 0x000078, "Member 'UMordhauMotion::OffhandIKChangeSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, CosmeticTransformChangeSpeed) == 0x00007C, "Member 'UMordhauMotion::CosmeticTransformChangeSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, OffhandIKDistanceMax) == 0x000080, "Member 'UMordhauMotion::OffhandIKDistanceMax' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, OffhandIKDistanceMin) == 0x000084, "Member 'UMordhauMotion::OffhandIKDistanceMin' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bBlocksRegen) == 0x000088, "Member 'UMordhauMotion::bBlocksRegen' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bAllowDedicatedServerAnimLOD) == 0x000089, "Member 'UMordhauMotion::bAllowDedicatedServerAnimLOD' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bUsesLeftTorsoBlend) == 0x00008A, "Member 'UMordhauMotion::bUsesLeftTorsoBlend' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, LeftTorsoBlendSpeed) == 0x00008C, "Member 'UMordhauMotion::LeftTorsoBlendSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bWantsRightLegBending) == 0x000090, "Member 'UMordhauMotion::bWantsRightLegBending' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, RightLegBendingChangeSpeed) == 0x000094, "Member 'UMordhauMotion::RightLegBendingChangeSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, bWantsSlowLookSmoothing) == 0x000098, "Member 'UMordhauMotion::bWantsSlowLookSmoothing' has a wrong offset!");
static_assert(offsetof(UMordhauMotion, LookSmoothingChangeSpeed) == 0x00009C, "Member 'UMordhauMotion::LookSmoothingChangeSpeed' has a wrong offset!");

// Class Mordhau.AttackMotion
// 0x1060 (0x1100 - 0x00A0)
class UAttackMotion : public UMordhauMotion
{
public:
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        VisualizeAttackAccelerationTraces;                 // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 VisualizeAttackAccelerationDeltaTimes;             // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowAutomaticBlendingDebug;                       // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAutomaticBlendingVisualDebug;                 // 0x00E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWindUpSmoothingDebug;                         // 0x00E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesTrail;                                        // 0x00E3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayAttackYellTimeReleaseOffset;                   // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WooshTimeFactor;                                   // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsSlowLookSmoothingInRecovery;                 // 0x00EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AnglingLimits;                                     // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerspectiveHighMidLowSpineSpaceAdditive AnglingAdditiveWindUp;                             // 0x00F8(0x0318)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FHighMidLowSpineSpaceAdditive          AnglingAdditiveRelease;                            // 0x0410(0x018C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveHighMidLowSpineSpaceAdditive RiposteAnglingAdditiveWindUp;                      // 0x059C(0x0318)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FHighMidLowSpineSpaceAdditive          RiposteAnglingAdditiveRelease;                     // 0x08B4(0x018C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ExperimentalLiveRecoveryDuration;                  // 0x0A40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LiveRecoveryHitsAreThuds;                          // 0x0A44(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeMissingDeltaTime;                          // 0x0A45(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableWorldCollision;                            // 0x0A46(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A47[0x1];                                      // 0x0A47(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            WorldCollisionPercentageTriggerCurve;              // 0x0A48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            WorldCollisionAbsoluteTriggerCurve;                // 0x0A50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceMemoryStayDuration;                           // 0x0A58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxParryAngleForChamberAndActiveParry;             // 0x0A5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxParryWeaponAngleForChamberAndActiveParry;       // 0x0A60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveParryStaminaCost;                            // 0x0A64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveParryWindow;                                 // 0x0A68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeParriedInEarlyRelease;                       // 0x0A6C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoDamageInEarlyRelease;                           // 0x0A6D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeParriedByForwardCollider;                    // 0x0A6E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeParriedByForwardColliderInEarlyRelease;      // 0x0A6F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClashAngle;                                        // 0x0A70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EarlyReleaseIsClashableAfter;                      // 0x0A74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChamberWindow;                                     // 0x0A78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChamberStaminaRecover;                             // 0x0A7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToChamberAttackAngleTolerance;                     // 0x0A80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A84[0x4];                                      // 0x0A84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlanceDamageModifier;                              // 0x0A88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostFriendlyHitModifier;                           // 0x0A8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopOnHitOnKills;                                 // 0x0A90(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTraceHitUsingShieldBlockCollider;              // 0x0A91(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStunsHeldBlock;                                   // 0x0A92(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsComboFromMiss;                                  // 0x0A93(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAngleToRearHorse;                               // 0x0A94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissTwiceStaminaCostMultiplier;                    // 0x0A98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RiposteTradeDamageFactor;                          // 0x0A9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RiposteWindUpCanParryWindow;                       // 0x0AA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RiposteWindupModifier;                             // 0x0AA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClashOnParryFollowUpWindup;                        // 0x0AA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClashOnParryCanParryWindow;                        // 0x0AAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotMakeRecoveryFlinchable;                      // 0x0AB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSeamlessCFTPInRecovery;                        // 0x0AB1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB2[0x2];                                      // 0x0AB2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitRecovery;                                       // 0x0AB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopRecovery;                                   // 0x0AB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClashedRecovery;                                   // 0x0ABC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      MissRecoveryToPlayRate;                            // 0x0AC0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveVector2D                   MissRecoveryPlayRateClamp;                         // 0x0AC8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RecoveryQueueWindow;                               // 0x0AD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ADC[0x4];                                      // 0x0ADC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           BounceMontage;                                     // 0x0AE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerspectiveAnimSequence               BounceAdditive;                                    // 0x0AE8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveCurveFloat                 WorldBounceCurve;                                  // 0x0AF8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveCurveFloat                 WorldBounceScaleCurve;                             // 0x0B08(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveCurveFloat                 ParryBounceCurve;                                  // 0x0B18(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveCurveFloat                 ParryLateBounceCurve;                              // 0x0B28(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveCurveFloat                 ParryBounceScaleCurve;                             // 0x0B38(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EarlyRelease;                                      // 0x0B48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EarlyReleaseTimeFactor;                            // 0x0B4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RiposteEarlyRelease;                               // 0x0B50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RiposteEarlyReleaseTimeFactor;                     // 0x0B54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrikeAnimationNormalizedRecoveryOffset;           // 0x0B58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5C[0x4];                                      // 0x0B5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SupersprintDurationByRangeCurve;                   // 0x0B60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SupersprintStartOffset;                            // 0x0B68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SupersprintDuration;                               // 0x0B6C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B70[0x4];                                      // 0x0B70(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FeintWindow;                                       // 0x0B74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ComboFeintWindow;                                  // 0x0B78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRiposteFeintable;                               // 0x0B7C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAttackFromFeintLockout;                        // 0x0B7D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B7E[0x2];                                      // 0x0B7E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerspectiveFloat                      FeintAnimRate;                                     // 0x0B80(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      FeintAnimDurationOffset;                           // 0x0B88(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      FeintAnimMinimumDuration;                          // 0x0B90(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanAutoFeintToAttack;                             // 0x0B98(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRiposteAteFeintInput;                             // 0x0B99(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9A[0x2];                                      // 0x0B9A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinWindUpTimeBeforeMorphing;                       // 0x0B9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MorphWindow;                                       // 0x0BA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MorphWindupModifier;                               // 0x0BA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MorphWindupCurve;                                  // 0x0BA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMorphTotalTime;                                 // 0x0BB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MorphKickExtraTime;                                // 0x0BB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReleaseJumpBlockTime;                              // 0x0BB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPerformWeaponSlidingSparks;                       // 0x0BBC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerspectiveBool                       RegularAttacksUseAutoBlendIn;                      // 0x0BBD(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveBool                       RiposteAttacksUseAutoBlendIn;                      // 0x0BBF(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveBool                       ComboAttacksUseAutoBlendIn;                        // 0x0BC1(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveBool                       PostClashAttacksUseAutoBlendIn;                    // 0x0BC3(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveBool                       MorphAttacksUseAutoBlendIn;                        // 0x0BC5(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC7[0x1];                                      // 0x0BC7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerspectiveCurveFloat                 AutoBlendInWeaponCurve;                            // 0x0BC8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AutoBlendConsiderUpVectorIfLargerThanAngle;        // 0x0BD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BDC[0x4];                                      // 0x0BDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerspectiveCurveFloat                 AutoBlendInSpineCurve;                             // 0x0BE0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         AutoBlendOptimizeForwardSteps;                     // 0x0BF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RiposteAutoBlendOptimizeForwardSteps;              // 0x0BF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoBlendOptimizeForwardStepSize;                  // 0x0BF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      NormalBlendIn;                                     // 0x0BFC(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      NormalSlowBlendIn;                                 // 0x0C04(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      NormalParrySlowBlendIn;                            // 0x0C0C(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      ComboBlendIn;                                      // 0x0C14(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      PostClashBlendIn;                                  // 0x0C1C(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      MorphBlendIn;                                      // 0x0C24(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      RiposteBlendIn;                                    // 0x0C2C(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      RiposteWithShieldBlendIn;                          // 0x0C34(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C3C[0x4];                                      // 0x0C3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlendInCurve;                                      // 0x0C40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerspectiveCurveFloat                 ComboBlendInCurve;                                 // 0x0C48(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MorphBlendInCurve;                                 // 0x0C58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RiposteBlendInCurve;                               // 0x0C60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendIn;                                           // 0x0C68(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAutomaticBlendIn;                              // 0x0C6C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6D[0x3];                                      // 0x0C6D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerspectiveAnimSequenceBase           Animation;                                         // 0x0C70(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FPerspectiveAnimSequenceBase> ComboAnimations;                                   // 0x0C80(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FPerspectiveAnimSequenceBase> MorphAnimations;                                   // 0x0CD0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPerspectiveAnimSequenceBase           RiposteAnimation;                                  // 0x0D20(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveAnimSequenceBase           AltRiposteAnimation;                               // 0x0D30(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveAnimSequenceBase           ClashAnimation;                                    // 0x0D40(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveAnimMontage                LeftTorsoMontage;                                  // 0x0D50(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveAnimMontage                RiposteLeftTorsoMontage;                           // 0x0D60(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CurrentLeftTorsoAnimMontage;                       // 0x0D70(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      BlendOut;                                          // 0x0D78(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      SuccessfulHitBlendOutAnimTime;                     // 0x0D80(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      SuccessfulHitPlayRate;                             // 0x0D88(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D90[0x8];                                      // 0x0D90(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TWeakObjectPtr<class UAttackMotion>>     BlockedAttacks;                                    // 0x0D98(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE8[0x4];                                      // 0x0DE8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerspectiveBool                       EnableWindUpSmoothing;                             // 0x0DEC(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_DEE[0x2];                                      // 0x0DEE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              WindUpSmoothingExponentClamp;                      // 0x0DF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            WindUpCurve;                                       // 0x0DF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerspectiveCurveFloat                 ComboWindUpCurve;                                  // 0x0E00(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AnimationTimeFor3PTransition;                      // 0x0E10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E14[0x4];                                      // 0x0E14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ReleaseCurve;                                      // 0x0E18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RiposteReleaseCurve;                               // 0x0E20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBlockFromReleaseAfterHit;                      // 0x0E28(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKnockbackOnNoFlinch;                              // 0x0E29(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackMove                                   ComingFromMove;                                    // 0x0E2A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2B[0x5];                                      // 0x0E2B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UParryMotion*                           ComingFromAsParry;                                 // 0x0E30(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttackInfo                            AttackInfo;                                        // 0x0E38(0x0128)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSpineSpaceAdditive                    TargetAdditive;                                    // 0x0F60(0x0084)(NoDestructor, NativeAccessSpecifierPublic)
	struct FSpineSpaceAdditive                    WindUpAdditive;                                    // 0x0FE4(0x0084)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1068[0x18];                                    // 0x1068(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngleTarget;                                       // 0x1080(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastReleaseNormalizedTime;                         // 0x1084(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastWindupNormalizedTime;                          // 0x1088(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasHitFriendly;                                   // 0x108C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackType                                   Type;                                              // 0x108D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackMove                                   Move;                                              // 0x108E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108F[0x1];                                     // 0x108F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WindupEnd;                                         // 0x1090(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReleaseEnd;                                        // 0x1094(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1098[0x18];                                    // 0x1098(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Montage;                                           // 0x10B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      WindupSequenceUsed;                                // 0x10B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      QueuedAnimFor3PRelease;                            // 0x10C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMordhauWeapon*                         Weapon;                                            // 0x10C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAttackMotion*                          PreviousLastAttackMotion;                          // 0x10D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasQueuedServerCombo;                             // 0x10D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D9[0x3];                                     // 0x10D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QueuedServerComboAngle;                            // 0x10DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackMove                                   QueuedServerComboMove;                             // 0x10E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasQueuedMove;                                    // 0x10E1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E2[0x2];                                     // 0x10E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QueuedAngle;                                       // 0x10E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackMove                                   QueuedMove;                                        // 0x10E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackStage                                  Stage;                                             // 0x10E9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasHit;                                           // 0x10EA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasHitIncludingCosmeticHit;                       // 0x10EB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstHitTime;                                      // 0x10EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstHitIncludingCosmeticReleaseNormalizedTime;    // 0x10F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasChambered;                                     // 0x10F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10F5[0xB];                                     // 0x10F5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float ComputeWindup();
	class AMordhauWeapon* FindWeapon();
	void ModifyAttackInfo();
	bool OverrideAdditionalTrace(struct FVector* OutStart, struct FVector* OutEnd);
	bool OverrideIsUsingAdditionalTracers(bool* OutResult);
	bool OverrideTrace(struct FVector* OutStart, struct FVector* OutEnd);
	void PrepareAnimationData();
	void SetHasHitIncludingCosmeticHit(bool bPlayHitShake);
	bool ShouldStunOnHit(class UMotionSystemComponent* OtherComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackMotion">();
	}
	static class UAttackMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackMotion>();
	}
};
static_assert(alignof(UAttackMotion) == 0x000008, "Wrong alignment on UAttackMotion");
static_assert(sizeof(UAttackMotion) == 0x001100, "Wrong size on UAttackMotion");
static_assert(offsetof(UAttackMotion, VisualizeAttackAccelerationTraces) == 0x0000C0, "Member 'UAttackMotion::VisualizeAttackAccelerationTraces' has a wrong offset!");
static_assert(offsetof(UAttackMotion, VisualizeAttackAccelerationDeltaTimes) == 0x0000D0, "Member 'UAttackMotion::VisualizeAttackAccelerationDeltaTimes' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bShowAutomaticBlendingDebug) == 0x0000E0, "Member 'UAttackMotion::bShowAutomaticBlendingDebug' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bShowAutomaticBlendingVisualDebug) == 0x0000E1, "Member 'UAttackMotion::bShowAutomaticBlendingVisualDebug' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bShowWindUpSmoothingDebug) == 0x0000E2, "Member 'UAttackMotion::bShowWindUpSmoothingDebug' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bUsesTrail) == 0x0000E3, "Member 'UAttackMotion::bUsesTrail' has a wrong offset!");
static_assert(offsetof(UAttackMotion, PlayAttackYellTimeReleaseOffset) == 0x0000E4, "Member 'UAttackMotion::PlayAttackYellTimeReleaseOffset' has a wrong offset!");
static_assert(offsetof(UAttackMotion, WooshTimeFactor) == 0x0000E8, "Member 'UAttackMotion::WooshTimeFactor' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bWantsSlowLookSmoothingInRecovery) == 0x0000EC, "Member 'UAttackMotion::bWantsSlowLookSmoothingInRecovery' has a wrong offset!");
static_assert(offsetof(UAttackMotion, AnglingLimits) == 0x0000F0, "Member 'UAttackMotion::AnglingLimits' has a wrong offset!");
static_assert(offsetof(UAttackMotion, AnglingAdditiveWindUp) == 0x0000F8, "Member 'UAttackMotion::AnglingAdditiveWindUp' has a wrong offset!");
static_assert(offsetof(UAttackMotion, AnglingAdditiveRelease) == 0x000410, "Member 'UAttackMotion::AnglingAdditiveRelease' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteAnglingAdditiveWindUp) == 0x00059C, "Member 'UAttackMotion::RiposteAnglingAdditiveWindUp' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteAnglingAdditiveRelease) == 0x0008B4, "Member 'UAttackMotion::RiposteAnglingAdditiveRelease' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ExperimentalLiveRecoveryDuration) == 0x000A40, "Member 'UAttackMotion::ExperimentalLiveRecoveryDuration' has a wrong offset!");
static_assert(offsetof(UAttackMotion, LiveRecoveryHitsAreThuds) == 0x000A44, "Member 'UAttackMotion::LiveRecoveryHitsAreThuds' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bIncludeMissingDeltaTime) == 0x000A45, "Member 'UAttackMotion::bIncludeMissingDeltaTime' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bDisableWorldCollision) == 0x000A46, "Member 'UAttackMotion::bDisableWorldCollision' has a wrong offset!");
static_assert(offsetof(UAttackMotion, WorldCollisionPercentageTriggerCurve) == 0x000A48, "Member 'UAttackMotion::WorldCollisionPercentageTriggerCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, WorldCollisionAbsoluteTriggerCurve) == 0x000A50, "Member 'UAttackMotion::WorldCollisionAbsoluteTriggerCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, TraceMemoryStayDuration) == 0x000A58, "Member 'UAttackMotion::TraceMemoryStayDuration' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MaxParryAngleForChamberAndActiveParry) == 0x000A5C, "Member 'UAttackMotion::MaxParryAngleForChamberAndActiveParry' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MaxParryWeaponAngleForChamberAndActiveParry) == 0x000A60, "Member 'UAttackMotion::MaxParryWeaponAngleForChamberAndActiveParry' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ActiveParryStaminaCost) == 0x000A64, "Member 'UAttackMotion::ActiveParryStaminaCost' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ActiveParryWindow) == 0x000A68, "Member 'UAttackMotion::ActiveParryWindow' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bCanBeParriedInEarlyRelease) == 0x000A6C, "Member 'UAttackMotion::bCanBeParriedInEarlyRelease' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bNoDamageInEarlyRelease) == 0x000A6D, "Member 'UAttackMotion::bNoDamageInEarlyRelease' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bCanBeParriedByForwardCollider) == 0x000A6E, "Member 'UAttackMotion::bCanBeParriedByForwardCollider' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bCanBeParriedByForwardColliderInEarlyRelease) == 0x000A6F, "Member 'UAttackMotion::bCanBeParriedByForwardColliderInEarlyRelease' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ClashAngle) == 0x000A70, "Member 'UAttackMotion::ClashAngle' has a wrong offset!");
static_assert(offsetof(UAttackMotion, EarlyReleaseIsClashableAfter) == 0x000A74, "Member 'UAttackMotion::EarlyReleaseIsClashableAfter' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ChamberWindow) == 0x000A78, "Member 'UAttackMotion::ChamberWindow' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ChamberStaminaRecover) == 0x000A7C, "Member 'UAttackMotion::ChamberStaminaRecover' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ToChamberAttackAngleTolerance) == 0x000A80, "Member 'UAttackMotion::ToChamberAttackAngleTolerance' has a wrong offset!");
static_assert(offsetof(UAttackMotion, GlanceDamageModifier) == 0x000A88, "Member 'UAttackMotion::GlanceDamageModifier' has a wrong offset!");
static_assert(offsetof(UAttackMotion, PostFriendlyHitModifier) == 0x000A8C, "Member 'UAttackMotion::PostFriendlyHitModifier' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bStopOnHitOnKills) == 0x000A90, "Member 'UAttackMotion::bStopOnHitOnKills' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bCanTraceHitUsingShieldBlockCollider) == 0x000A91, "Member 'UAttackMotion::bCanTraceHitUsingShieldBlockCollider' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bStunsHeldBlock) == 0x000A92, "Member 'UAttackMotion::bStunsHeldBlock' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bIsComboFromMiss) == 0x000A93, "Member 'UAttackMotion::bIsComboFromMiss' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MinAngleToRearHorse) == 0x000A94, "Member 'UAttackMotion::MinAngleToRearHorse' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MissTwiceStaminaCostMultiplier) == 0x000A98, "Member 'UAttackMotion::MissTwiceStaminaCostMultiplier' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteTradeDamageFactor) == 0x000A9C, "Member 'UAttackMotion::RiposteTradeDamageFactor' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteWindUpCanParryWindow) == 0x000AA0, "Member 'UAttackMotion::RiposteWindUpCanParryWindow' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteWindupModifier) == 0x000AA4, "Member 'UAttackMotion::RiposteWindupModifier' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ClashOnParryFollowUpWindup) == 0x000AA8, "Member 'UAttackMotion::ClashOnParryFollowUpWindup' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ClashOnParryCanParryWindow) == 0x000AAC, "Member 'UAttackMotion::ClashOnParryCanParryWindow' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bDoNotMakeRecoveryFlinchable) == 0x000AB0, "Member 'UAttackMotion::bDoNotMakeRecoveryFlinchable' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bUseSeamlessCFTPInRecovery) == 0x000AB1, "Member 'UAttackMotion::bUseSeamlessCFTPInRecovery' has a wrong offset!");
static_assert(offsetof(UAttackMotion, HitRecovery) == 0x000AB4, "Member 'UAttackMotion::HitRecovery' has a wrong offset!");
static_assert(offsetof(UAttackMotion, HitStopRecovery) == 0x000AB8, "Member 'UAttackMotion::HitStopRecovery' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ClashedRecovery) == 0x000ABC, "Member 'UAttackMotion::ClashedRecovery' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MissRecoveryToPlayRate) == 0x000AC0, "Member 'UAttackMotion::MissRecoveryToPlayRate' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MissRecoveryPlayRateClamp) == 0x000AC8, "Member 'UAttackMotion::MissRecoveryPlayRateClamp' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RecoveryQueueWindow) == 0x000AD8, "Member 'UAttackMotion::RecoveryQueueWindow' has a wrong offset!");
static_assert(offsetof(UAttackMotion, BounceMontage) == 0x000AE0, "Member 'UAttackMotion::BounceMontage' has a wrong offset!");
static_assert(offsetof(UAttackMotion, BounceAdditive) == 0x000AE8, "Member 'UAttackMotion::BounceAdditive' has a wrong offset!");
static_assert(offsetof(UAttackMotion, WorldBounceCurve) == 0x000AF8, "Member 'UAttackMotion::WorldBounceCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, WorldBounceScaleCurve) == 0x000B08, "Member 'UAttackMotion::WorldBounceScaleCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ParryBounceCurve) == 0x000B18, "Member 'UAttackMotion::ParryBounceCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ParryLateBounceCurve) == 0x000B28, "Member 'UAttackMotion::ParryLateBounceCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ParryBounceScaleCurve) == 0x000B38, "Member 'UAttackMotion::ParryBounceScaleCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, EarlyRelease) == 0x000B48, "Member 'UAttackMotion::EarlyRelease' has a wrong offset!");
static_assert(offsetof(UAttackMotion, EarlyReleaseTimeFactor) == 0x000B4C, "Member 'UAttackMotion::EarlyReleaseTimeFactor' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteEarlyRelease) == 0x000B50, "Member 'UAttackMotion::RiposteEarlyRelease' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteEarlyReleaseTimeFactor) == 0x000B54, "Member 'UAttackMotion::RiposteEarlyReleaseTimeFactor' has a wrong offset!");
static_assert(offsetof(UAttackMotion, StrikeAnimationNormalizedRecoveryOffset) == 0x000B58, "Member 'UAttackMotion::StrikeAnimationNormalizedRecoveryOffset' has a wrong offset!");
static_assert(offsetof(UAttackMotion, SupersprintDurationByRangeCurve) == 0x000B60, "Member 'UAttackMotion::SupersprintDurationByRangeCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, SupersprintStartOffset) == 0x000B68, "Member 'UAttackMotion::SupersprintStartOffset' has a wrong offset!");
static_assert(offsetof(UAttackMotion, SupersprintDuration) == 0x000B6C, "Member 'UAttackMotion::SupersprintDuration' has a wrong offset!");
static_assert(offsetof(UAttackMotion, FeintWindow) == 0x000B74, "Member 'UAttackMotion::FeintWindow' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ComboFeintWindow) == 0x000B78, "Member 'UAttackMotion::ComboFeintWindow' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bIsRiposteFeintable) == 0x000B7C, "Member 'UAttackMotion::bIsRiposteFeintable' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bCanAttackFromFeintLockout) == 0x000B7D, "Member 'UAttackMotion::bCanAttackFromFeintLockout' has a wrong offset!");
static_assert(offsetof(UAttackMotion, FeintAnimRate) == 0x000B80, "Member 'UAttackMotion::FeintAnimRate' has a wrong offset!");
static_assert(offsetof(UAttackMotion, FeintAnimDurationOffset) == 0x000B88, "Member 'UAttackMotion::FeintAnimDurationOffset' has a wrong offset!");
static_assert(offsetof(UAttackMotion, FeintAnimMinimumDuration) == 0x000B90, "Member 'UAttackMotion::FeintAnimMinimumDuration' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bCanAutoFeintToAttack) == 0x000B98, "Member 'UAttackMotion::bCanAutoFeintToAttack' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bRiposteAteFeintInput) == 0x000B99, "Member 'UAttackMotion::bRiposteAteFeintInput' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MinWindUpTimeBeforeMorphing) == 0x000B9C, "Member 'UAttackMotion::MinWindUpTimeBeforeMorphing' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MorphWindow) == 0x000BA0, "Member 'UAttackMotion::MorphWindow' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MorphWindupModifier) == 0x000BA4, "Member 'UAttackMotion::MorphWindupModifier' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MorphWindupCurve) == 0x000BA8, "Member 'UAttackMotion::MorphWindupCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MaxMorphTotalTime) == 0x000BB0, "Member 'UAttackMotion::MaxMorphTotalTime' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MorphKickExtraTime) == 0x000BB4, "Member 'UAttackMotion::MorphKickExtraTime' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ReleaseJumpBlockTime) == 0x000BB8, "Member 'UAttackMotion::ReleaseJumpBlockTime' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bPerformWeaponSlidingSparks) == 0x000BBC, "Member 'UAttackMotion::bPerformWeaponSlidingSparks' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RegularAttacksUseAutoBlendIn) == 0x000BBD, "Member 'UAttackMotion::RegularAttacksUseAutoBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteAttacksUseAutoBlendIn) == 0x000BBF, "Member 'UAttackMotion::RiposteAttacksUseAutoBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ComboAttacksUseAutoBlendIn) == 0x000BC1, "Member 'UAttackMotion::ComboAttacksUseAutoBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, PostClashAttacksUseAutoBlendIn) == 0x000BC3, "Member 'UAttackMotion::PostClashAttacksUseAutoBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MorphAttacksUseAutoBlendIn) == 0x000BC5, "Member 'UAttackMotion::MorphAttacksUseAutoBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, AutoBlendInWeaponCurve) == 0x000BC8, "Member 'UAttackMotion::AutoBlendInWeaponCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, AutoBlendConsiderUpVectorIfLargerThanAngle) == 0x000BD8, "Member 'UAttackMotion::AutoBlendConsiderUpVectorIfLargerThanAngle' has a wrong offset!");
static_assert(offsetof(UAttackMotion, AutoBlendInSpineCurve) == 0x000BE0, "Member 'UAttackMotion::AutoBlendInSpineCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, AutoBlendOptimizeForwardSteps) == 0x000BF0, "Member 'UAttackMotion::AutoBlendOptimizeForwardSteps' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteAutoBlendOptimizeForwardSteps) == 0x000BF4, "Member 'UAttackMotion::RiposteAutoBlendOptimizeForwardSteps' has a wrong offset!");
static_assert(offsetof(UAttackMotion, AutoBlendOptimizeForwardStepSize) == 0x000BF8, "Member 'UAttackMotion::AutoBlendOptimizeForwardStepSize' has a wrong offset!");
static_assert(offsetof(UAttackMotion, NormalBlendIn) == 0x000BFC, "Member 'UAttackMotion::NormalBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, NormalSlowBlendIn) == 0x000C04, "Member 'UAttackMotion::NormalSlowBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, NormalParrySlowBlendIn) == 0x000C0C, "Member 'UAttackMotion::NormalParrySlowBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ComboBlendIn) == 0x000C14, "Member 'UAttackMotion::ComboBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, PostClashBlendIn) == 0x000C1C, "Member 'UAttackMotion::PostClashBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MorphBlendIn) == 0x000C24, "Member 'UAttackMotion::MorphBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteBlendIn) == 0x000C2C, "Member 'UAttackMotion::RiposteBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteWithShieldBlendIn) == 0x000C34, "Member 'UAttackMotion::RiposteWithShieldBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, BlendInCurve) == 0x000C40, "Member 'UAttackMotion::BlendInCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ComboBlendInCurve) == 0x000C48, "Member 'UAttackMotion::ComboBlendInCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MorphBlendInCurve) == 0x000C58, "Member 'UAttackMotion::MorphBlendInCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteBlendInCurve) == 0x000C60, "Member 'UAttackMotion::RiposteBlendInCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, BlendIn) == 0x000C68, "Member 'UAttackMotion::BlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bUseAutomaticBlendIn) == 0x000C6C, "Member 'UAttackMotion::bUseAutomaticBlendIn' has a wrong offset!");
static_assert(offsetof(UAttackMotion, Animation) == 0x000C70, "Member 'UAttackMotion::Animation' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ComboAnimations) == 0x000C80, "Member 'UAttackMotion::ComboAnimations' has a wrong offset!");
static_assert(offsetof(UAttackMotion, MorphAnimations) == 0x000CD0, "Member 'UAttackMotion::MorphAnimations' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteAnimation) == 0x000D20, "Member 'UAttackMotion::RiposteAnimation' has a wrong offset!");
static_assert(offsetof(UAttackMotion, AltRiposteAnimation) == 0x000D30, "Member 'UAttackMotion::AltRiposteAnimation' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ClashAnimation) == 0x000D40, "Member 'UAttackMotion::ClashAnimation' has a wrong offset!");
static_assert(offsetof(UAttackMotion, LeftTorsoMontage) == 0x000D50, "Member 'UAttackMotion::LeftTorsoMontage' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteLeftTorsoMontage) == 0x000D60, "Member 'UAttackMotion::RiposteLeftTorsoMontage' has a wrong offset!");
static_assert(offsetof(UAttackMotion, CurrentLeftTorsoAnimMontage) == 0x000D70, "Member 'UAttackMotion::CurrentLeftTorsoAnimMontage' has a wrong offset!");
static_assert(offsetof(UAttackMotion, BlendOut) == 0x000D78, "Member 'UAttackMotion::BlendOut' has a wrong offset!");
static_assert(offsetof(UAttackMotion, SuccessfulHitBlendOutAnimTime) == 0x000D80, "Member 'UAttackMotion::SuccessfulHitBlendOutAnimTime' has a wrong offset!");
static_assert(offsetof(UAttackMotion, SuccessfulHitPlayRate) == 0x000D88, "Member 'UAttackMotion::SuccessfulHitPlayRate' has a wrong offset!");
static_assert(offsetof(UAttackMotion, BlockedAttacks) == 0x000D98, "Member 'UAttackMotion::BlockedAttacks' has a wrong offset!");
static_assert(offsetof(UAttackMotion, EnableWindUpSmoothing) == 0x000DEC, "Member 'UAttackMotion::EnableWindUpSmoothing' has a wrong offset!");
static_assert(offsetof(UAttackMotion, WindUpSmoothingExponentClamp) == 0x000DF0, "Member 'UAttackMotion::WindUpSmoothingExponentClamp' has a wrong offset!");
static_assert(offsetof(UAttackMotion, WindUpCurve) == 0x000DF8, "Member 'UAttackMotion::WindUpCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ComboWindUpCurve) == 0x000E00, "Member 'UAttackMotion::ComboWindUpCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, AnimationTimeFor3PTransition) == 0x000E10, "Member 'UAttackMotion::AnimationTimeFor3PTransition' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ReleaseCurve) == 0x000E18, "Member 'UAttackMotion::ReleaseCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, RiposteReleaseCurve) == 0x000E20, "Member 'UAttackMotion::RiposteReleaseCurve' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bCanBlockFromReleaseAfterHit) == 0x000E28, "Member 'UAttackMotion::bCanBlockFromReleaseAfterHit' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bKnockbackOnNoFlinch) == 0x000E29, "Member 'UAttackMotion::bKnockbackOnNoFlinch' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ComingFromMove) == 0x000E2A, "Member 'UAttackMotion::ComingFromMove' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ComingFromAsParry) == 0x000E30, "Member 'UAttackMotion::ComingFromAsParry' has a wrong offset!");
static_assert(offsetof(UAttackMotion, AttackInfo) == 0x000E38, "Member 'UAttackMotion::AttackInfo' has a wrong offset!");
static_assert(offsetof(UAttackMotion, TargetAdditive) == 0x000F60, "Member 'UAttackMotion::TargetAdditive' has a wrong offset!");
static_assert(offsetof(UAttackMotion, WindUpAdditive) == 0x000FE4, "Member 'UAttackMotion::WindUpAdditive' has a wrong offset!");
static_assert(offsetof(UAttackMotion, AngleTarget) == 0x001080, "Member 'UAttackMotion::AngleTarget' has a wrong offset!");
static_assert(offsetof(UAttackMotion, LastReleaseNormalizedTime) == 0x001084, "Member 'UAttackMotion::LastReleaseNormalizedTime' has a wrong offset!");
static_assert(offsetof(UAttackMotion, LastWindupNormalizedTime) == 0x001088, "Member 'UAttackMotion::LastWindupNormalizedTime' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bHasHitFriendly) == 0x00108C, "Member 'UAttackMotion::bHasHitFriendly' has a wrong offset!");
static_assert(offsetof(UAttackMotion, Type) == 0x00108D, "Member 'UAttackMotion::Type' has a wrong offset!");
static_assert(offsetof(UAttackMotion, Move) == 0x00108E, "Member 'UAttackMotion::Move' has a wrong offset!");
static_assert(offsetof(UAttackMotion, WindupEnd) == 0x001090, "Member 'UAttackMotion::WindupEnd' has a wrong offset!");
static_assert(offsetof(UAttackMotion, ReleaseEnd) == 0x001094, "Member 'UAttackMotion::ReleaseEnd' has a wrong offset!");
static_assert(offsetof(UAttackMotion, Montage) == 0x0010B0, "Member 'UAttackMotion::Montage' has a wrong offset!");
static_assert(offsetof(UAttackMotion, WindupSequenceUsed) == 0x0010B8, "Member 'UAttackMotion::WindupSequenceUsed' has a wrong offset!");
static_assert(offsetof(UAttackMotion, QueuedAnimFor3PRelease) == 0x0010C0, "Member 'UAttackMotion::QueuedAnimFor3PRelease' has a wrong offset!");
static_assert(offsetof(UAttackMotion, Weapon) == 0x0010C8, "Member 'UAttackMotion::Weapon' has a wrong offset!");
static_assert(offsetof(UAttackMotion, PreviousLastAttackMotion) == 0x0010D0, "Member 'UAttackMotion::PreviousLastAttackMotion' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bHasQueuedServerCombo) == 0x0010D8, "Member 'UAttackMotion::bHasQueuedServerCombo' has a wrong offset!");
static_assert(offsetof(UAttackMotion, QueuedServerComboAngle) == 0x0010DC, "Member 'UAttackMotion::QueuedServerComboAngle' has a wrong offset!");
static_assert(offsetof(UAttackMotion, QueuedServerComboMove) == 0x0010E0, "Member 'UAttackMotion::QueuedServerComboMove' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bHasQueuedMove) == 0x0010E1, "Member 'UAttackMotion::bHasQueuedMove' has a wrong offset!");
static_assert(offsetof(UAttackMotion, QueuedAngle) == 0x0010E4, "Member 'UAttackMotion::QueuedAngle' has a wrong offset!");
static_assert(offsetof(UAttackMotion, QueuedMove) == 0x0010E8, "Member 'UAttackMotion::QueuedMove' has a wrong offset!");
static_assert(offsetof(UAttackMotion, Stage) == 0x0010E9, "Member 'UAttackMotion::Stage' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bHasHit) == 0x0010EA, "Member 'UAttackMotion::bHasHit' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bHasHitIncludingCosmeticHit) == 0x0010EB, "Member 'UAttackMotion::bHasHitIncludingCosmeticHit' has a wrong offset!");
static_assert(offsetof(UAttackMotion, FirstHitTime) == 0x0010EC, "Member 'UAttackMotion::FirstHitTime' has a wrong offset!");
static_assert(offsetof(UAttackMotion, FirstHitIncludingCosmeticReleaseNormalizedTime) == 0x0010F0, "Member 'UAttackMotion::FirstHitIncludingCosmeticReleaseNormalizedTime' has a wrong offset!");
static_assert(offsetof(UAttackMotion, bHasChambered) == 0x0010F4, "Member 'UAttackMotion::bHasChambered' has a wrong offset!");

// Class Mordhau.CouchedAttackMotion
// 0x0028 (0x1128 - 0x1100)
class UCouchedAttackMotion : public UAttackMotion
{
public:
	float                                         CouchingBlendFrom;                                 // 0x1100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CouchStage;                                        // 0x1104(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1105[0x3];                                     // 0x1105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CouchStart;                                        // 0x1108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CouchFeintLockOut;                                 // 0x110C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCouchTime;                                      // 0x1110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryDuration;                                  // 0x1114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginalSecondaryTurnLimit;                        // 0x1118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AHorse>                  HorsePtr;                                          // 0x111C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1124[0x4];                                     // 0x1124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CouchedAttackMotion">();
	}
	static class UCouchedAttackMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCouchedAttackMotion>();
	}
};
static_assert(alignof(UCouchedAttackMotion) == 0x000008, "Wrong alignment on UCouchedAttackMotion");
static_assert(sizeof(UCouchedAttackMotion) == 0x001128, "Wrong size on UCouchedAttackMotion");
static_assert(offsetof(UCouchedAttackMotion, CouchingBlendFrom) == 0x001100, "Member 'UCouchedAttackMotion::CouchingBlendFrom' has a wrong offset!");
static_assert(offsetof(UCouchedAttackMotion, CouchStage) == 0x001104, "Member 'UCouchedAttackMotion::CouchStage' has a wrong offset!");
static_assert(offsetof(UCouchedAttackMotion, CouchStart) == 0x001108, "Member 'UCouchedAttackMotion::CouchStart' has a wrong offset!");
static_assert(offsetof(UCouchedAttackMotion, CouchFeintLockOut) == 0x00110C, "Member 'UCouchedAttackMotion::CouchFeintLockOut' has a wrong offset!");
static_assert(offsetof(UCouchedAttackMotion, MaxCouchTime) == 0x001110, "Member 'UCouchedAttackMotion::MaxCouchTime' has a wrong offset!");
static_assert(offsetof(UCouchedAttackMotion, RecoveryDuration) == 0x001114, "Member 'UCouchedAttackMotion::RecoveryDuration' has a wrong offset!");
static_assert(offsetof(UCouchedAttackMotion, OriginalSecondaryTurnLimit) == 0x001118, "Member 'UCouchedAttackMotion::OriginalSecondaryTurnLimit' has a wrong offset!");
static_assert(offsetof(UCouchedAttackMotion, HorsePtr) == 0x00111C, "Member 'UCouchedAttackMotion::HorsePtr' has a wrong offset!");

// Class Mordhau.GetPlayerCombinedInfo
// 0x0030 (0x0060 - 0x0030)
class UGetPlayerCombinedInfo final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(bool bWasSuccessful, const class FString& PlayFabId, TArray<struct FPlayerStatisticValue>& PlayerStatistics)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bWasSuccessful, const class FString& PlayFabId, TArray<struct FPlayerStatisticValue>& PlayerStatistics)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 PlayFabId;                                         // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGetPlayerCombinedInfo* GetPlayerCombinedInfo(const class FString& PlayFabId_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetPlayerCombinedInfo">();
	}
	static class UGetPlayerCombinedInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetPlayerCombinedInfo>();
	}
};
static_assert(alignof(UGetPlayerCombinedInfo) == 0x000008, "Wrong alignment on UGetPlayerCombinedInfo");
static_assert(sizeof(UGetPlayerCombinedInfo) == 0x000060, "Wrong size on UGetPlayerCombinedInfo");
static_assert(offsetof(UGetPlayerCombinedInfo, onSuccess) == 0x000030, "Member 'UGetPlayerCombinedInfo::onSuccess' has a wrong offset!");
static_assert(offsetof(UGetPlayerCombinedInfo, onFailure) == 0x000040, "Member 'UGetPlayerCombinedInfo::onFailure' has a wrong offset!");
static_assert(offsetof(UGetPlayerCombinedInfo, PlayFabId) == 0x000050, "Member 'UGetPlayerCombinedInfo::PlayFabId' has a wrong offset!");

// Class Mordhau.AdvRichTextBlockImageDecorator
// 0x0000 (0x0030 - 0x0030)
class UAdvRichTextBlockImageDecorator : public URichTextBlockImageDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdvRichTextBlockImageDecorator">();
	}
	static class UAdvRichTextBlockImageDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdvRichTextBlockImageDecorator>();
	}
};
static_assert(alignof(UAdvRichTextBlockImageDecorator) == 0x000008, "Wrong alignment on UAdvRichTextBlockImageDecorator");
static_assert(sizeof(UAdvRichTextBlockImageDecorator) == 0x000030, "Wrong size on UAdvRichTextBlockImageDecorator");

// Class Mordhau.AdvancedCharacterAnimInstance
// 0x00C0 (0x0380 - 0x02C0)
class UAdvancedCharacterAnimInstance : public UAnimInstance
{
public:
	TArray<ECollisionChannel>                     GroundingChannels;                                 // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bWantsGrounding;                                   // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RootTranslationOffsetInternal;                     // 0x02CC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RootTranslationOffset;                             // 0x02D8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RootRotationOffsetInternal;                        // 0x02E4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RootRotationOffset;                                // 0x02F0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RootRotationPivot;                                 // 0x02FC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslationInterpSpeed;                            // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterpSpeed;                               // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootRotationOffsetFactor;                          // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimbRotationOffsetFactor;                          // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RootLiftLimits;                                    // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundingWeight;                                   // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedLocationLag;                            // 0x0324(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AccumulatedTurnLag;                                // 0x0330(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsAirborne;                                       // 0x033C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33D[0x3];                                      // 0x033D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastLand;                                          // 0x0340(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastJump;                                          // 0x0344(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirborneTime;                                      // 0x0348(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumped;                                           // 0x034C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAirborneFromJump;                                 // 0x034D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x034E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34F[0x1];                                      // 0x034F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeathDirection;                                    // 0x0350(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AdditiveOverrideType;                              // 0x0354(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveOverrideWeight;                            // 0x035C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveOverrideNoneTime;                          // 0x0360(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveOverrideTypeNormalizedTime;                // 0x0364(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchDirection;                                   // 0x0368(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchIsHead;                                      // 0x036C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AltFlinchDirection;                                // 0x0370(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AltFlinchIsHead;                                   // 0x0374(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastDeltaSeconds;                                  // 0x0378(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdvancedCharacterAnimInstance">();
	}
	static class UAdvancedCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdvancedCharacterAnimInstance>();
	}
};
static_assert(alignof(UAdvancedCharacterAnimInstance) == 0x000010, "Wrong alignment on UAdvancedCharacterAnimInstance");
static_assert(sizeof(UAdvancedCharacterAnimInstance) == 0x000380, "Wrong size on UAdvancedCharacterAnimInstance");
static_assert(offsetof(UAdvancedCharacterAnimInstance, GroundingChannels) == 0x0002B8, "Member 'UAdvancedCharacterAnimInstance::GroundingChannels' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, bWantsGrounding) == 0x0002C8, "Member 'UAdvancedCharacterAnimInstance::bWantsGrounding' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, RootTranslationOffsetInternal) == 0x0002CC, "Member 'UAdvancedCharacterAnimInstance::RootTranslationOffsetInternal' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, RootTranslationOffset) == 0x0002D8, "Member 'UAdvancedCharacterAnimInstance::RootTranslationOffset' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, RootRotationOffsetInternal) == 0x0002E4, "Member 'UAdvancedCharacterAnimInstance::RootRotationOffsetInternal' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, RootRotationOffset) == 0x0002F0, "Member 'UAdvancedCharacterAnimInstance::RootRotationOffset' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, RootRotationPivot) == 0x0002FC, "Member 'UAdvancedCharacterAnimInstance::RootRotationPivot' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, TranslationInterpSpeed) == 0x000308, "Member 'UAdvancedCharacterAnimInstance::TranslationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, RotationInterpSpeed) == 0x00030C, "Member 'UAdvancedCharacterAnimInstance::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, RootRotationOffsetFactor) == 0x000310, "Member 'UAdvancedCharacterAnimInstance::RootRotationOffsetFactor' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, LimbRotationOffsetFactor) == 0x000314, "Member 'UAdvancedCharacterAnimInstance::LimbRotationOffsetFactor' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, RootLiftLimits) == 0x000318, "Member 'UAdvancedCharacterAnimInstance::RootLiftLimits' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, GroundingWeight) == 0x000320, "Member 'UAdvancedCharacterAnimInstance::GroundingWeight' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, AccumulatedLocationLag) == 0x000324, "Member 'UAdvancedCharacterAnimInstance::AccumulatedLocationLag' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, AccumulatedTurnLag) == 0x000330, "Member 'UAdvancedCharacterAnimInstance::AccumulatedTurnLag' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, bIsAirborne) == 0x00033C, "Member 'UAdvancedCharacterAnimInstance::bIsAirborne' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, LastLand) == 0x000340, "Member 'UAdvancedCharacterAnimInstance::LastLand' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, LastJump) == 0x000344, "Member 'UAdvancedCharacterAnimInstance::LastJump' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, AirborneTime) == 0x000348, "Member 'UAdvancedCharacterAnimInstance::AirborneTime' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, bJumped) == 0x00034C, "Member 'UAdvancedCharacterAnimInstance::bJumped' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, bAirborneFromJump) == 0x00034D, "Member 'UAdvancedCharacterAnimInstance::bAirborneFromJump' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, bIsDead) == 0x00034E, "Member 'UAdvancedCharacterAnimInstance::bIsDead' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, DeathDirection) == 0x000350, "Member 'UAdvancedCharacterAnimInstance::DeathDirection' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, AdditiveOverrideType) == 0x000354, "Member 'UAdvancedCharacterAnimInstance::AdditiveOverrideType' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, AdditiveOverrideWeight) == 0x00035C, "Member 'UAdvancedCharacterAnimInstance::AdditiveOverrideWeight' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, AdditiveOverrideNoneTime) == 0x000360, "Member 'UAdvancedCharacterAnimInstance::AdditiveOverrideNoneTime' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, AdditiveOverrideTypeNormalizedTime) == 0x000364, "Member 'UAdvancedCharacterAnimInstance::AdditiveOverrideTypeNormalizedTime' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, FlinchDirection) == 0x000368, "Member 'UAdvancedCharacterAnimInstance::FlinchDirection' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, FlinchIsHead) == 0x00036C, "Member 'UAdvancedCharacterAnimInstance::FlinchIsHead' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, AltFlinchDirection) == 0x000370, "Member 'UAdvancedCharacterAnimInstance::AltFlinchDirection' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, AltFlinchIsHead) == 0x000374, "Member 'UAdvancedCharacterAnimInstance::AltFlinchIsHead' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterAnimInstance, LastDeltaSeconds) == 0x000378, "Member 'UAdvancedCharacterAnimInstance::LastDeltaSeconds' has a wrong offset!");

// Class Mordhau.CreatureAnimInstance
// 0x0050 (0x03D0 - 0x0380)
class UCreatureAnimInstance : public UAdvancedCharacterAnimInstance
{
public:
	float                                         MinEndBone2DDistanceToRetrace;                     // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFootGroundingLimb>             GroundingLimbs;                                    // 0x0388(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bComputeGroundingRotation;                         // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LandOffsetBlendInTime;                             // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandOffsetBlendInSpeed;                            // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandOffsetBlendOutSpeed;                           // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LandOffset;                                        // 0x03A8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotAddLandOffsetToGrounding;                    // 0x03B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B5[0x3];                                      // 0x03B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LandOffsetFactorByAirTime;                         // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x10];                                     // 0x03C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoFootstep(int32 Limb);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreatureAnimInstance">();
	}
	static class UCreatureAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreatureAnimInstance>();
	}
};
static_assert(alignof(UCreatureAnimInstance) == 0x000010, "Wrong alignment on UCreatureAnimInstance");
static_assert(sizeof(UCreatureAnimInstance) == 0x0003D0, "Wrong size on UCreatureAnimInstance");
static_assert(offsetof(UCreatureAnimInstance, MinEndBone2DDistanceToRetrace) == 0x000380, "Member 'UCreatureAnimInstance::MinEndBone2DDistanceToRetrace' has a wrong offset!");
static_assert(offsetof(UCreatureAnimInstance, GroundingLimbs) == 0x000388, "Member 'UCreatureAnimInstance::GroundingLimbs' has a wrong offset!");
static_assert(offsetof(UCreatureAnimInstance, bComputeGroundingRotation) == 0x000398, "Member 'UCreatureAnimInstance::bComputeGroundingRotation' has a wrong offset!");
static_assert(offsetof(UCreatureAnimInstance, LandOffsetBlendInTime) == 0x00039C, "Member 'UCreatureAnimInstance::LandOffsetBlendInTime' has a wrong offset!");
static_assert(offsetof(UCreatureAnimInstance, LandOffsetBlendInSpeed) == 0x0003A0, "Member 'UCreatureAnimInstance::LandOffsetBlendInSpeed' has a wrong offset!");
static_assert(offsetof(UCreatureAnimInstance, LandOffsetBlendOutSpeed) == 0x0003A4, "Member 'UCreatureAnimInstance::LandOffsetBlendOutSpeed' has a wrong offset!");
static_assert(offsetof(UCreatureAnimInstance, LandOffset) == 0x0003A8, "Member 'UCreatureAnimInstance::LandOffset' has a wrong offset!");
static_assert(offsetof(UCreatureAnimInstance, bDoNotAddLandOffsetToGrounding) == 0x0003B4, "Member 'UCreatureAnimInstance::bDoNotAddLandOffsetToGrounding' has a wrong offset!");
static_assert(offsetof(UCreatureAnimInstance, LandOffsetFactorByAirTime) == 0x0003B8, "Member 'UCreatureAnimInstance::LandOffsetFactorByAirTime' has a wrong offset!");

// Class Mordhau.AdminListCommand
// 0x0000 (0x0080 - 0x0080)
class UAdminListCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdminListCommand">();
	}
	static class UAdminListCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdminListCommand>();
	}
};
static_assert(alignof(UAdminListCommand) == 0x000008, "Wrong alignment on UAdminListCommand");
static_assert(sizeof(UAdminListCommand) == 0x000080, "Wrong size on UAdminListCommand");

// Class Mordhau.MordhauInventoryItem
// 0x0038 (0x0060 - 0x0028)
class UMordhauInventoryItem : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ItemIcon;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDefID;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemName;                                          // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EItemRarity                                   ItemRarity;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetWasSeen();
	void MarkSeen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauInventoryItem">();
	}
	static class UMordhauInventoryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauInventoryItem>();
	}
};
static_assert(alignof(UMordhauInventoryItem) == 0x000008, "Wrong alignment on UMordhauInventoryItem");
static_assert(sizeof(UMordhauInventoryItem) == 0x000060, "Wrong size on UMordhauInventoryItem");
static_assert(offsetof(UMordhauInventoryItem, ItemIcon) == 0x000030, "Member 'UMordhauInventoryItem::ItemIcon' has a wrong offset!");
static_assert(offsetof(UMordhauInventoryItem, ItemDefID) == 0x000038, "Member 'UMordhauInventoryItem::ItemDefID' has a wrong offset!");
static_assert(offsetof(UMordhauInventoryItem, ItemName) == 0x000040, "Member 'UMordhauInventoryItem::ItemName' has a wrong offset!");
static_assert(offsetof(UMordhauInventoryItem, ItemRarity) == 0x000058, "Member 'UMordhauInventoryItem::ItemRarity' has a wrong offset!");

// Class Mordhau.MordhauWearable
// 0x01C8 (0x0228 - 0x0060)
class UMordhauWearable : public UMordhauInventoryItem
{
public:
	EWearableSlot                                 UseColorsFromSlot;                                 // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             AlbedoMap;                                         // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             NormalMap;                                         // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             RoughnessMap;                                      // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Albedo;                                            // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Metallic;                                          // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roughness;                                         // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetalAlbedoDarken;                                 // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PDO;                                               // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BloodOffsetA;                                      // 0x0094(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BloodOffsetB;                                      // 0x00A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BloodMaskSizeFine;                                 // 0x00AC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BloodMaskSizeSoft;                                 // 0x00B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BloodTextureSize;                                  // 0x00C4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EmblemScale;                                       // 0x00D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EmblemOffset;                                      // 0x00DC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmblemRotation;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEmblem;                                        // 0x00EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMuffleVoice;                                      // 0x00ED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTreatAsMaster;                                    // 0x00EE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideIn1P;                                         // 0x00EF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesReducedBodyPoses;                             // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideEars;                                         // 0x00F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideEarsAmount;                                    // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideHair;                                         // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideBeard;                                        // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideNose;                                         // 0x00FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB[0x1];                                       // 0x00FB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HideNoseAmount;                                    // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideLeftHand;                                     // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideRightHand;                                    // 0x0101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideLeftFoot;                                     // 0x0102(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideRightFoot;                                    // 0x0103(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideLeftLeg;                                      // 0x0104(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideRightLeg;                                     // 0x0105(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideChest;                                        // 0x0106(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideLeftArm;                                      // 0x0107(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideRightArm;                                     // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0110(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Mesh1POverride;                                    // 0x0138(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           AuxiliaryMesh;                                     // 0x0160(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           AuxiliaryMesh1POverride;                           // 0x0188(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresFullArmAuxiliary;                         // 0x01B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresForearmAuxiliary;                         // 0x01B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresUpperChestAuxiliary;                      // 0x01B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresAnkleAuxiliary;                           // 0x01B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertexCameraDisplacement;                          // 0x01B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterPointCost;                                // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ArmorClass;                                        // 0x01BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAllowedForPeasants;                             // 0x01BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BE[0x2];                                      // 0x01BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedFactor;                                       // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationFactor;                                // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPatternInfo>                   Patterns;                                          // 0x01C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pattern;                                           // 0x01D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 Colors;                                            // 0x01E0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ColorTables;                                       // 0x01F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTeamColor1;                                 // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTeamColor2;                                 // 0x0201(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_202[0x2];                                      // 0x0202(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           DefaultColor1Temp;                                 // 0x0204(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultColor2Temp;                                 // 0x0214(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesMaskedMaterial;                               // 0x0224(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauWearable">();
	}
	static class UMordhauWearable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauWearable>();
	}
};
static_assert(alignof(UMordhauWearable) == 0x000008, "Wrong alignment on UMordhauWearable");
static_assert(sizeof(UMordhauWearable) == 0x000228, "Wrong size on UMordhauWearable");
static_assert(offsetof(UMordhauWearable, UseColorsFromSlot) == 0x000060, "Member 'UMordhauWearable::UseColorsFromSlot' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, AlbedoMap) == 0x000068, "Member 'UMordhauWearable::AlbedoMap' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, NormalMap) == 0x000070, "Member 'UMordhauWearable::NormalMap' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, RoughnessMap) == 0x000078, "Member 'UMordhauWearable::RoughnessMap' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, Albedo) == 0x000080, "Member 'UMordhauWearable::Albedo' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, Metallic) == 0x000084, "Member 'UMordhauWearable::Metallic' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, Roughness) == 0x000088, "Member 'UMordhauWearable::Roughness' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, MetalAlbedoDarken) == 0x00008C, "Member 'UMordhauWearable::MetalAlbedoDarken' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, PDO) == 0x000090, "Member 'UMordhauWearable::PDO' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, BloodOffsetA) == 0x000094, "Member 'UMordhauWearable::BloodOffsetA' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, BloodOffsetB) == 0x0000A0, "Member 'UMordhauWearable::BloodOffsetB' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, BloodMaskSizeFine) == 0x0000AC, "Member 'UMordhauWearable::BloodMaskSizeFine' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, BloodMaskSizeSoft) == 0x0000B8, "Member 'UMordhauWearable::BloodMaskSizeSoft' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, BloodTextureSize) == 0x0000C4, "Member 'UMordhauWearable::BloodTextureSize' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, EmblemScale) == 0x0000D0, "Member 'UMordhauWearable::EmblemScale' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, EmblemOffset) == 0x0000DC, "Member 'UMordhauWearable::EmblemOffset' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, EmblemRotation) == 0x0000E8, "Member 'UMordhauWearable::EmblemRotation' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHasEmblem) == 0x0000EC, "Member 'UMordhauWearable::bHasEmblem' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bMuffleVoice) == 0x0000ED, "Member 'UMordhauWearable::bMuffleVoice' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bTreatAsMaster) == 0x0000EE, "Member 'UMordhauWearable::bTreatAsMaster' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideIn1P) == 0x0000EF, "Member 'UMordhauWearable::bHideIn1P' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bUsesReducedBodyPoses) == 0x0000F0, "Member 'UMordhauWearable::bUsesReducedBodyPoses' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideEars) == 0x0000F1, "Member 'UMordhauWearable::bHideEars' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, HideEarsAmount) == 0x0000F4, "Member 'UMordhauWearable::HideEarsAmount' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideHair) == 0x0000F8, "Member 'UMordhauWearable::bHideHair' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideBeard) == 0x0000F9, "Member 'UMordhauWearable::bHideBeard' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideNose) == 0x0000FA, "Member 'UMordhauWearable::bHideNose' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, HideNoseAmount) == 0x0000FC, "Member 'UMordhauWearable::HideNoseAmount' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideLeftHand) == 0x000100, "Member 'UMordhauWearable::bHideLeftHand' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideRightHand) == 0x000101, "Member 'UMordhauWearable::bHideRightHand' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideLeftFoot) == 0x000102, "Member 'UMordhauWearable::bHideLeftFoot' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideRightFoot) == 0x000103, "Member 'UMordhauWearable::bHideRightFoot' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideLeftLeg) == 0x000104, "Member 'UMordhauWearable::bHideLeftLeg' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideRightLeg) == 0x000105, "Member 'UMordhauWearable::bHideRightLeg' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideChest) == 0x000106, "Member 'UMordhauWearable::bHideChest' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideLeftArm) == 0x000107, "Member 'UMordhauWearable::bHideLeftArm' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bHideRightArm) == 0x000108, "Member 'UMordhauWearable::bHideRightArm' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, Mesh) == 0x000110, "Member 'UMordhauWearable::Mesh' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, Mesh1POverride) == 0x000138, "Member 'UMordhauWearable::Mesh1POverride' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, AuxiliaryMesh) == 0x000160, "Member 'UMordhauWearable::AuxiliaryMesh' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, AuxiliaryMesh1POverride) == 0x000188, "Member 'UMordhauWearable::AuxiliaryMesh1POverride' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bRequiresFullArmAuxiliary) == 0x0001B0, "Member 'UMordhauWearable::bRequiresFullArmAuxiliary' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bRequiresForearmAuxiliary) == 0x0001B1, "Member 'UMordhauWearable::bRequiresForearmAuxiliary' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bRequiresUpperChestAuxiliary) == 0x0001B2, "Member 'UMordhauWearable::bRequiresUpperChestAuxiliary' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bRequiresAnkleAuxiliary) == 0x0001B3, "Member 'UMordhauWearable::bRequiresAnkleAuxiliary' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, VertexCameraDisplacement) == 0x0001B4, "Member 'UMordhauWearable::VertexCameraDisplacement' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, CharacterPointCost) == 0x0001B8, "Member 'UMordhauWearable::CharacterPointCost' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, ArmorClass) == 0x0001BC, "Member 'UMordhauWearable::ArmorClass' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bIsAllowedForPeasants) == 0x0001BD, "Member 'UMordhauWearable::bIsAllowedForPeasants' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, SpeedFactor) == 0x0001C0, "Member 'UMordhauWearable::SpeedFactor' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, AccelerationFactor) == 0x0001C4, "Member 'UMordhauWearable::AccelerationFactor' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, Patterns) == 0x0001C8, "Member 'UMordhauWearable::Patterns' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, Pattern) == 0x0001D8, "Member 'UMordhauWearable::Pattern' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, Colors) == 0x0001E0, "Member 'UMordhauWearable::Colors' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, ColorTables) == 0x0001F0, "Member 'UMordhauWearable::ColorTables' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bIgnoreTeamColor1) == 0x000200, "Member 'UMordhauWearable::bIgnoreTeamColor1' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bIgnoreTeamColor2) == 0x000201, "Member 'UMordhauWearable::bIgnoreTeamColor2' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, DefaultColor1Temp) == 0x000204, "Member 'UMordhauWearable::DefaultColor1Temp' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, DefaultColor2Temp) == 0x000214, "Member 'UMordhauWearable::DefaultColor2Temp' has a wrong offset!");
static_assert(offsetof(UMordhauWearable, bUsesMaskedMaterial) == 0x000224, "Member 'UMordhauWearable::bUsesMaskedMaterial' has a wrong offset!");

// Class Mordhau.LegsWearable
// 0x0018 (0x0240 - 0x0228)
class ULegsWearable : public UMordhauWearable
{
public:
	uint8                                         DefaultFeet;                                       // 0x0228(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           FeetWearables;                                     // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void AddFeetWearable(TSoftClassPtr<class UClass> Wearable);
	TSubclassOf<class UMordhauWearable> GetFeetWearable(int32 Index_0);

	int32 GetFeetWearablesNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LegsWearable">();
	}
	static class ULegsWearable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULegsWearable>();
	}
};
static_assert(alignof(ULegsWearable) == 0x000008, "Wrong alignment on ULegsWearable");
static_assert(sizeof(ULegsWearable) == 0x000240, "Wrong size on ULegsWearable");
static_assert(offsetof(ULegsWearable, DefaultFeet) == 0x000228, "Member 'ULegsWearable::DefaultFeet' has a wrong offset!");
static_assert(offsetof(ULegsWearable, FeetWearables) == 0x000230, "Member 'ULegsWearable::FeetWearables' has a wrong offset!");

// Class Mordhau.AliveCommand
// 0x0000 (0x0080 - 0x0080)
class UAliveCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AliveCommand">();
	}
	static class UAliveCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAliveCommand>();
	}
};
static_assert(alignof(UAliveCommand) == 0x000008, "Wrong alignment on UAliveCommand");
static_assert(sizeof(UAliveCommand) == 0x000080, "Wrong size on UAliveCommand");

// Class Mordhau.MordhauColor
// 0x0020 (0x0080 - 0x0060)
class UMordhauColor : public UMordhauInventoryItem
{
public:
	struct FLinearColor                           Color;                                             // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DisplayColor;                                      // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauColor">();
	}
	static class UMordhauColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauColor>();
	}
};
static_assert(alignof(UMordhauColor) == 0x000008, "Wrong alignment on UMordhauColor");
static_assert(sizeof(UMordhauColor) == 0x000080, "Wrong size on UMordhauColor");
static_assert(offsetof(UMordhauColor, Color) == 0x000060, "Member 'UMordhauColor::Color' has a wrong offset!");
static_assert(offsetof(UMordhauColor, DisplayColor) == 0x000070, "Member 'UMordhauColor::DisplayColor' has a wrong offset!");

// Class Mordhau.CrowdObstacleComponent
// 0x0028 (0x00D8 - 0x00B0)
class UCrowdObstacleComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnabledOnStart;                                   // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObstacleRadius;                                    // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ObstacleHalfHeigth;                                // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LocationOffset;                                    // 0x00C4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterObstacle();
	void UnregisterObstacle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrowdObstacleComponent">();
	}
	static class UCrowdObstacleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrowdObstacleComponent>();
	}
};
static_assert(alignof(UCrowdObstacleComponent) == 0x000008, "Wrong alignment on UCrowdObstacleComponent");
static_assert(sizeof(UCrowdObstacleComponent) == 0x0000D8, "Wrong size on UCrowdObstacleComponent");
static_assert(offsetof(UCrowdObstacleComponent, bEnabledOnStart) == 0x0000B8, "Member 'UCrowdObstacleComponent::bEnabledOnStart' has a wrong offset!");
static_assert(offsetof(UCrowdObstacleComponent, ObstacleRadius) == 0x0000BC, "Member 'UCrowdObstacleComponent::ObstacleRadius' has a wrong offset!");
static_assert(offsetof(UCrowdObstacleComponent, ObstacleHalfHeigth) == 0x0000C0, "Member 'UCrowdObstacleComponent::ObstacleHalfHeigth' has a wrong offset!");
static_assert(offsetof(UCrowdObstacleComponent, LocationOffset) == 0x0000C4, "Member 'UCrowdObstacleComponent::LocationOffset' has a wrong offset!");

// Class Mordhau.InteractionSystemComponent
// 0x0048 (0x00F8 - 0x00B0)
class UInteractionSystemComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  RequestedInteractionTarget;                        // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfSweeps;                                    // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SweepSphereRadius;                                 // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SweepRadius;                                       // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepDistance;                                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActorInteractionDistance;                          // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawAllSections;                                  // 0x00D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  InteractionTarget;                                 // 0x00D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UseHoldTime;                                       // 0x00E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x14];                                      // 0x00E4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterDestroyed(class AAdvancedCharacter* Character);
	void OnLateTick(float DeltaTime);
	void OnLODTick(float DeltaTime);
	void OnUnPossessed(class AAdvancedCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionSystemComponent">();
	}
	static class UInteractionSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionSystemComponent>();
	}
};
static_assert(alignof(UInteractionSystemComponent) == 0x000008, "Wrong alignment on UInteractionSystemComponent");
static_assert(sizeof(UInteractionSystemComponent) == 0x0000F8, "Wrong size on UInteractionSystemComponent");
static_assert(offsetof(UInteractionSystemComponent, RequestedInteractionTarget) == 0x0000B8, "Member 'UInteractionSystemComponent::RequestedInteractionTarget' has a wrong offset!");
static_assert(offsetof(UInteractionSystemComponent, NumberOfSweeps) == 0x0000C0, "Member 'UInteractionSystemComponent::NumberOfSweeps' has a wrong offset!");
static_assert(offsetof(UInteractionSystemComponent, SweepSphereRadius) == 0x0000C4, "Member 'UInteractionSystemComponent::SweepSphereRadius' has a wrong offset!");
static_assert(offsetof(UInteractionSystemComponent, SweepRadius) == 0x0000C8, "Member 'UInteractionSystemComponent::SweepRadius' has a wrong offset!");
static_assert(offsetof(UInteractionSystemComponent, SweepDistance) == 0x0000CC, "Member 'UInteractionSystemComponent::SweepDistance' has a wrong offset!");
static_assert(offsetof(UInteractionSystemComponent, ActorInteractionDistance) == 0x0000D0, "Member 'UInteractionSystemComponent::ActorInteractionDistance' has a wrong offset!");
static_assert(offsetof(UInteractionSystemComponent, bDrawAllSections) == 0x0000D4, "Member 'UInteractionSystemComponent::bDrawAllSections' has a wrong offset!");
static_assert(offsetof(UInteractionSystemComponent, InteractionTarget) == 0x0000D8, "Member 'UInteractionSystemComponent::InteractionTarget' has a wrong offset!");
static_assert(offsetof(UInteractionSystemComponent, UseHoldTime) == 0x0000E0, "Member 'UInteractionSystemComponent::UseHoldTime' has a wrong offset!");

// Class Mordhau.AdvancedCharacter
// 0x0650 (0x0B10 - 0x04C0)
#pragma pack(push, 0x1)
class alignas(0x10) AAdvancedCharacter : public ACharacter
{
public:
	uint8                                         Pad_4B8[0x28];                                     // 0x04B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class APlayerState>            LastPlayerState;                                   // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0x14];                                     // 0x04E8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AMordhauPlayerController> InstanceOwner;                                     // 0x04FC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x0504(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRagdollFalling;                                 // 0x0505(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_506[0x2];                                      // 0x0506(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RagdollFallingFromPerchRadius;                     // 0x0508(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsBurningSmoothed;                                 // 0x050C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceIntoFireFieldSmoothed;                     // 0x0510(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceIntoFireField;                             // 0x0514(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceIntoSmokeFieldSmoothed;                    // 0x0518(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceIntoSmokeField;                            // 0x051C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpValue;                                       // 0x0520(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_524[0x4];                                      // 0x0524(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          OriginalMesh;                                      // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AAdvancedCharacter* Character)> OnCharacterDied;                                   // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AAdvancedCharacter* Character, struct FMordhauDamageInfo& DamageInfo, class AController* EventInstigator, class AActor* DamageCauser)> OnTakeDamage;                                      // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_550[0x8];                                      // 0x0550(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AAdvancedCharacter* Character)> OnCharacterDestroyed;                              // 0x0558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AAdvancedCharacter* Character)> OnTornOff;                                         // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AAdvancedCharacter* Character)> OnUnPossessed;                                     // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AAdvancedCharacter* Character)> OnChangedTeam;                                     // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AAdvancedCharacter* Character)> OnCharacterBecomeViewTarget;                       // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AAdvancedCharacter* Character)> OnCharacterEndViewTarget;                          // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x30];                                     // 0x05B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UniqueAdvancedCharacterIndex;                      // 0x05E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSmoothedTurnValue;                            // 0x05EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSmoothingTurnVelocity;                        // 0x05F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSmoothedLookUpValue;                          // 0x05F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSmoothingLookUpVelocity;                      // 0x05F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrePhysTickFunction                   PrePhysTickFunction;                               // 0x0600(0x0030)(NativeAccessSpecifierPublic)
	float                                         LODDeltaTime;                                      // 0x0630(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LateLODDeltaTime;                                  // 0x0634(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_638[0x28];                                     // 0x0638(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         Team;                                              // 0x0660(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableOverlapsIfClientNotViewTarget;             // 0x0661(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_662[0x6];                                      // 0x0662(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTagSystemComponent*                    TagSystemComponent;                                // 0x0668(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDismemberableComponent*                DismemberableComponent;                            // 0x0670(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEquipmentSystemComponent*              EquipmentSystemComponent;                          // 0x0678(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDriverComponent*                       DriverComponent;                                   // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMotionSystemComponent*                 MotionSystemComponent;                             // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPerkSystemComponent*                   PerkSystemComponent;                               // 0x0690(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionSystemComponent*            InteractionSystemComponent;                        // 0x0698(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterVoiceComponent*               CharacterVoiceComponent;                           // 0x06A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaminaStatComponent*                  StaminaStatComponent;                              // 0x06A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageableComponent*                   DamageableComponent;                               // 0x06B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHealthStatComponent*                   HealthStatComponent;                               // 0x06B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UThudderComponent*                      BodyThudder;                                       // 0x06C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FootstepAudioComponentCount;                       // 0x06C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6CC[0x4];                                      // 0x06CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAudioComponent*>                FootstepAudioComponents;                           // 0x06D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E0[0x4];                                      // 0x06E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootstepLODDistance;                               // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootstepEffectsMaxCameraDist;                      // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6EC[0x4];                                      // 0x06EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           FeetBones;                                         // 0x06F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                FootstepDecalSize;                                 // 0x0700(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70C[0x4];                                      // 0x070C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             FootstepDecals;                                    // 0x0710(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UParticleSystem*>                FootstepParticles;                                 // 0x0720(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class USoundCue*                              FootstepSound;                                     // 0x0730(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootstepSoundZOffset;                              // 0x0738(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FootstepVolumeVelocityRangeIn;                     // 0x073C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FootstepVolumeVelocityRangeOut;                    // 0x0744(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FootstepPitchVelocityRangeIn;                      // 0x074C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FootstepPitchVelocityRangeOut;                     // 0x0754(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootstepVolumeModifierViewTarget;                  // 0x075C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootstepVolumeModifierAlly;                        // 0x0760(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootstepVolumeModifierEnemy;                       // 0x0764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FootstepArmorTier;                                 // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76C[0x4];                                      // 0x076C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          ClientPhysicsAsset;                                // 0x0770(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          BodyRagdollPhysicsAsset;                           // 0x0778(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDismemberedQueue                      DismemberedQueue;                                  // 0x0780(0x0060)(NativeAccessSpecifierPublic)
	struct FVector                                MoveCompVelocityBeforeDeath;                       // 0x07E0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastNonZeroVelocityTime;                           // 0x07EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanReceiveClientsideHits;                         // 0x07F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F1[0x3];                                      // 0x07F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DamageArmorTierOverride;                           // 0x07F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableRagdollFalling;                            // 0x07F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F9[0x3];                                      // 0x07F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DissolveDuration;                                  // 0x07FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULateTickComponent*                     LateTickComponent;                                 // 0x0800(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToCameraHeuristic;                         // 0x0808(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToCamera;                                  // 0x080C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionToCamera;                                 // 0x0810(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipAnimPoseOnClientWhenNotRendered;              // 0x0814(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_815[0x3];                                      // 0x0815(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DistanceToCameraMeshOffset;                        // 0x0818(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODRank;                                           // 0x0824(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODBucketLevel;                                    // 0x0828(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFancyMeshEffects;                                 // 0x082C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82D[0x3];                                      // 0x082D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FancyMeshEffectsTurnOnDistance;                    // 0x0830(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FancyMeshEffectsTurnOffDistance;                   // 0x0834(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceMaxQuality;                                  // 0x0838(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedCharacterFlags;                          // 0x0839(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasEverPossessedByLocalPlayer;                    // 0x083A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83B[0x1];                                      // 0x083B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastPossessionTime;                                // 0x083C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollFallingGetUpDuration;                       // 0x0840(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollFallingGetUpStartTime;                      // 0x0844(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollFallingStartTime;                           // 0x0848(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollFallingMinTime;                             // 0x084C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollFallingMinVelocityToGetUp;                  // 0x0850(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollFallingTimeAtMinVelocityToGetUp;            // 0x0854(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_858[0xC];                                      // 0x0858(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpCooldown;                                      // 0x0864(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumped;                                           // 0x0868(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAirborneFromJump;                               // 0x0869(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86A[0x2];                                      // 0x086A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AirborneTime;                                      // 0x086C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmokeDistanceMaxValue;                             // 0x0870(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmokeDistanceSmoothInterpSpeed;                    // 0x0874(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMasterField>            CurrentSmokeField;                                 // 0x0878(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBurnableComponent*                     BurnableComponent;                                 // 0x0880(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMeshesReceiveDecals;                              // 0x0888(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_889[0x7];                                      // 0x0889(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMordhauProjectile*                     CurrentProjectile;                                 // 0x0890(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnUsesControllerInputYawScale;                  // 0x0898(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddForwardAxisToMovementInput;                    // 0x0899(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddRightAxisToMovementInput;                      // 0x089A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89B[0x1];                                      // 0x089B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnTurnValue;                                    // 0x089C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpLimit;                                       // 0x08A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookDownLimit;                                     // 0x08A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnLimit;                                         // 0x08A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedLookUpValue;                             // 0x08AC(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8AD[0x3];                                      // 0x08AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookUpValueSmoothingTarget;                        // 0x08B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpValueSmoothingFrom;                          // 0x08B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpValueSmoothingStartTime;                     // 0x08B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpValueSmoothingEndTime;                       // 0x08BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookSmoothingSlowAlpha;                            // 0x08C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnRateCap;                                       // 0x08C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnRateCapTarget;                                 // 0x08C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpRateCap;                                     // 0x08CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpRateCapTarget;                               // 0x08D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnRateIgnoresCap;                               // 0x08D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D5[0x3];                                      // 0x08D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnCapRemaining;                                  // 0x08D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpCapRemaining;                                // 0x08DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastObservedLocation;                              // 0x08E0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedLocationLag;                            // 0x08EC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFloatAndVector>                DelayedLocationDeltas;                             // 0x08F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CurrentLocationLagInduction;                       // 0x0908(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationLagInductionTarget;                        // 0x090C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationLagInductionChangeSpeed;                   // 0x0910(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationLagInductionCounterweight;                 // 0x0914(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastObservedLook;                                  // 0x0918(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedLookLag;                                // 0x0924(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFloatAndVector>                DelayedLookDeltas;                                 // 0x0930(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CurrentLookLagInduction;                           // 0x0940(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookLagInductionTarget;                            // 0x0944(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookLagInductionChangeSpeed;                       // 0x0948(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookLagInductionCounterweight;                     // 0x094C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPerformCustomDepthHighlight;                      // 0x0950(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHighlighted;                                    // 0x0951(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInteractable;                                   // 0x0952(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_953[0x5];                                      // 0x0953(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMordhauWidgetComponent>    MarkerWidgetComponentClass;                        // 0x0958(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMordhauUserWidget>         MarkerWidgetClass;                                 // 0x0960(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_968[0x8];                                      // 0x0968(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MarkerWidgetRelativeTransform;                     // 0x0970(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   MarkerWidgetAttachSocket;                          // 0x09A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMordhauWidgetComponent*                MarkerWidgetComponent;                             // 0x09A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCannotRequestSuicide;                             // 0x09B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillStopMelee;                                    // 0x09B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillBleedOutOnKill;                               // 0x09B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B3[0x1];                                      // 0x09B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BleedingOutRemainingTime;                          // 0x09B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBleedingOut;                                    // 0x09B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B9[0x7];                                      // 0x09B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        DeathParticles;                                    // 0x09C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DeathParticlesSocket;                              // 0x09C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableHealingItems;                              // 0x09D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Health;                                            // 0x09D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedHealth;                                  // 0x09D2(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D3[0x1];                                      // 0x09D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealthRegenDelay;                                  // 0x09D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HealthRegenPerTick;                                // 0x09D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D9[0x3];                                      // 0x09D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealthRegenTickRate;                               // 0x09DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreGameStateHealthRegenRestriction;            // 0x09E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E1[0x3];                                      // 0x09E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutOfBoundsKillTime;                               // 0x09E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAllowedOutOfBounds;                             // 0x09E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeamkillsCountForAutoKick;                        // 0x09E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9EA[0x2];                                      // 0x09EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReflectMeleeDamagePercentage;                      // 0x09EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLastChance;                                    // 0x09F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F1[0x3];                                      // 0x09F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LastChanceHealAmount;                              // 0x09F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReceivedDamageModifier;                            // 0x09F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReceivedFallDamageModifier;                        // 0x09FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReceivedTeamDamageModifier;                        // 0x0A00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReceivedFireDamageModifier;                        // 0x0A04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReceivedRangedDamageModifier;                      // 0x0A08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReceivedDamageAbsorption;                          // 0x0A0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReceivedDamageMax;                                 // 0x0A10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackFlinch;                                   // 0x0A14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     HitEffect;                                         // 0x0A18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        BurningParticles;                                  // 0x0A20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BurningAttachSocket;                               // 0x0A28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              BurningSound;                                      // 0x0A30(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              FallDamageSound;                                   // 0x0A38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   FallDamageForceFeedback;                           // 0x0A40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   DisarmedForceFeedback;                             // 0x0A48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   StunnedForceFeedback;                              // 0x0A50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   OnFireForceFeedback;                               // 0x0A58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FallDamageSoundAttachToBone;                       // 0x0A60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UParticleSystemComponent> CurrentBurningParticles;                           // 0x0A68(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         CurrentBurningSound;                               // 0x0A70(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNetDamage                             NetDamage;                                         // 0x0A78(0x0024)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DeathTime;                                         // 0x0A9C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewTargetAttenuationVolumeMultiplier;             // 0x0AA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA4[0x4];                                      // 0x0AA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      ViewTargetAttenuationOverride;                     // 0x0AA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceLongDeathYell;                               // 0x0AB0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB1[0x7];                                      // 0x0AB1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              HurtYell;                                          // 0x0AB8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DeathYell;                                         // 0x0AC0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DedicatedServerAnimFrameSkipLOD;                   // 0x0AC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AdditiveOverrideType;                              // 0x0ACC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveOverrideEndTime;                           // 0x0AD4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveOverrideStartTime;                         // 0x0AD8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastFlinchAdditiveName;                            // 0x0ADC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastFlinchAdditiveTime;                            // 0x0AE4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              CharacterSurface;                                  // 0x0AE8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE9[0x7];                                      // 0x0AE9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSphericalLimbBounds>           SphericalLimbs;                                    // 0x0AF0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RagdollForceMultIfDmgAgent;                        // 0x0B00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceRagdollIfDmgAgent;                           // 0x0B04(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B05[0x3];                                      // 0x0B05(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTurnDegrees(float Delta);
	void AddWound(const struct FVector& ImpactPoint, const struct FVector& ImpactNormal, class FName bone, class AActor* Agent, EMordhauDamageType DamageType, uint8 DamageSubType);
	void ApplyRagdollForce(float Angle, EMordhauDamageType Type, uint8 SubType, class FName bone, const struct FVector& Point, class AActor* Source, class AActor* Agent);
	void BeginFlinchAdditiveOverride(const class FName& FlinchOverrideName, const class FName& AltFlinchOverrideName, float Duration, float Degree, bool bIsHead, float SnapDegreeToSteps);
	void BoostAnimBlendWeight(class UAnimMontage** Montage, float BoostAmount);
	class UAudioComponent* BP_PlayCharacterSound(class USoundBase* Sound, class FName bone, const struct FVector& Location, EAttachLocation AttachLocation, bool bAttach);
	void BPLODTick(float DeltaTime);
	bool CanBleedOutFromHit(const struct FHitResult& HitResult, EMordhauDamageType Type, uint8 SubType, class AActor* Source, class AActor* Agent, class AController* EventInstigator);
	class FName GetAdditiveOverrideType();
	float GetAdditiveOverrideTypeNormalizedTime();
	float GetAnimWeight(class UAnimMontage* Montage);
	uint8 GetArmorTierForBone(class FName BoneName);
	bool GetBestStickyLocation(const struct FVector& InLocation, struct FVector* OutLocation, struct FVector* OutNormal, class FName* OutBone);
	struct FVector GetLastDismemberedBoneForceDir();
	class AActor* GetLastNetDamageSource();
	EMordhauDamageType GetLastNetDamageType();
	bool IsAnimActive(class UAnimMontage* Montage);
	bool IsLastDismemberedBoneBluntForce();
	bool IsLastDismemberedBonePartial();
	bool Knockback(const struct FVector& Amount);
	void LookUp(float Val, bool bIsAbsolute);
	void LookUpAtRate(float Val);
	void LookUpNotAbsolute(float Value);
	float ModifyDamage(float DamageAmount, const struct FMordhauDamageInfo& DamageInfo, class AController* EventInstigator);
	float MordhauTakeDamage(float DamageAmount, const struct FHitResult& Hit, EMordhauDamageType DamageType, uint8 DamageSubType, class AActor* Source, class AActor* Agent, class AController* EventInstigator);
	void MoveForward(float Val);
	void MoveRight(float Val);
	void OffsetHealth(int32 Amount, bool bReplicate);
	void OnAfterDied(float Angle, EMordhauDamageType Type, uint8 SubType, class FName bone, const struct FVector& Point, class AActor* Source, class AActor* Agent);
	void OnCosmeticHit(EMordhauDamageType DamageType, uint8 SubType, const struct FHitResult& Hit, class AActor* Agent);
	void OnDied(float Angle, EMordhauDamageType Type, uint8 SubType, class FName bone, const struct FVector& Point, class AActor* Source, class AActor* Agent);
	void OnHealthChanged();
	void OnHit(class AActor* Actor, class FName bone, const struct FVector& WorldLocation, uint8 Tier, uint8 SurfaceType);
	void OnKilled(class AController* EventInstigator);
	void OnRep_NetDamage();
	void OnRep_ReplicatedCharacterFlags(uint8 OldValue);
	void OnRep_ReplicatedHealth();
	void OnRep_ReplicatedLookUpValue();
	void OnRep_SpawnTurnValue();
	void OnRep_Team();
	void OnTookDamage(bool bWillKill, EMordhauDamageType Type, uint8 SubType, const class FName& bone, const struct FVector& Point, class AActor* Source, class AActor* Agent);
	class UAnimMontage* PlayAnim(class UAnimMontage* Montage, float PlayRate, bool bStopExistingMontages);
	class UAnimMontage* PlayAnimSequenceBP(class UAnimSequence* Seq, float PlayRate, float BlendIn, float BlendOut, EAlphaBlendOption BlendInOption, EAlphaBlendOption BlendOutOption, float BlendOutTriggerTime, class FName Slot, class UCurveFloat* CustomIn, class UCurveFloat* CustomOut, bool bStopExistingMontages);
	void PlayCharacterForceFeeback(class UForceFeedbackEffect* ForceFeedbackEffect);
	void PlayCharacterForceFeebackParams(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag, bool bLooping);
	class UAudioComponent* PlayCharacterSound(class USoundBase* Sound, class FName bone, const struct FVector& InLocation, EAttachLocation AttachLocation, bool bAttach, class USoundAttenuation* Override, float VolumeMultiplier, float PitchMultiplier);
	bool PlayHitEffectParticle(const struct FVector& Location, const struct FRotator& Rotation, class FName bone, bool bFindOptimalSpot);
	void ReceiveMordhauDamage(float Damage, const struct FHitResult& HitResult, EMordhauDamageType DamageType, uint8 SubDamageType, class AActor* Source, class AActor* Agent, class AController* EventInstigator);
	void RegisterMaterialToDissolve(class UMaterialInstanceDynamic* Mat);
	void RequestMeshEnablePhysics(float Duration);
	void RequestSuicide();
	void RequestTrip();
	void ResetAdditiveOverrideType();
	void ResetLagInductionTargets();
	void ResetLocationLagInductionTarget();
	void ResetLookLagInductionTarget();
	void ServerLookUp(float NewLookUp);
	void ServerSuicide();
	void ServerTrip();
	void SetAdditiveOverrideType(class FName NewType, float Duration);
	void SetAnimPosition(class UAnimMontage* Montage, float NewPosition);
	void SetAnimRate(class UAnimMontage* Montage, float NewRate);
	void SetIsRagdollFalling(bool bInIsRagdollFalling);
	void SetLocationLagInductionTarget(float Amount, float ChangeSpeed);
	void SetLookLagInductionTarget(float Amount, float ChangeSpeed);
	void SetMaxAnimBlendWeight(class UAnimMontage** Montage, float MaxAmount);
	void SetOnSmoke(class AMasterField* SmokeField);
	void SetTurnCaps(float Turn_0, float LookUp);
	class UParticleSystemComponent* SpawnParticlesAttached(class UParticleSystem* Particle, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation AttachType, class FName Socket, bool bForce);
	void StartRagdoll();
	void StartRagdollWithBlend(float BlendDuration);
	void StopAnim(float FadeOut);
	void StopCharacterForceFeeback(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag);
	void StopHealthRegen(float ExtraTime);
	void StopMontage(class UAnimMontage* Montage, float FadeOut);
	void StopRegen(float ExtraTime);
	void Suicide();
	bool TraceSphericalLimbs(const struct FVector& TraceStart, const struct FVector& TraceEnd, struct FHitResult* OutResult);
	bool Trip();
	void Turn(float Val, bool bIsAbsolute);
	void TurnAtRate(float Val);
	void TurnNotAbsolute(float Value);

	class AController* GetControllerIncludingVehicle() const;
	float GetDistanceIntoSmokeField() const;
	float GetDistanceIntoSmokeFieldSmoothed() const;
	bool GetIsDead() const;
	float GetLookUpValue() const;
	class UMordhauMotion* GetMotion() const;
	float GetRawLookUpValue() const;
	bool IsAirborne() const;
	bool IsLocallyControlledIncludingVehicle() const;
	bool IsLocallyControlledOrUncontrolled() const;
	bool IsLocallyPlayerControlled() const;
	bool IsLocallyPlayerControlledIncludingVehicle() const;
	bool IsPlayerControlledIncludingVehicle() const;
	bool IsViewTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdvancedCharacter">();
	}
	static class AAdvancedCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAdvancedCharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(AAdvancedCharacter) == 0x000010, "Wrong alignment on AAdvancedCharacter");
static_assert(sizeof(AAdvancedCharacter) == 0x000B10, "Wrong size on AAdvancedCharacter");
static_assert(offsetof(AAdvancedCharacter, LastPlayerState) == 0x0004E0, "Member 'AAdvancedCharacter::LastPlayerState' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, InstanceOwner) == 0x0004FC, "Member 'AAdvancedCharacter::InstanceOwner' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bIsDead) == 0x000504, "Member 'AAdvancedCharacter::bIsDead' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bIsRagdollFalling) == 0x000505, "Member 'AAdvancedCharacter::bIsRagdollFalling' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, RagdollFallingFromPerchRadius) == 0x000508, "Member 'AAdvancedCharacter::RagdollFallingFromPerchRadius' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, IsBurningSmoothed) == 0x00050C, "Member 'AAdvancedCharacter::IsBurningSmoothed' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DistanceIntoFireFieldSmoothed) == 0x000510, "Member 'AAdvancedCharacter::DistanceIntoFireFieldSmoothed' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DistanceIntoFireField) == 0x000514, "Member 'AAdvancedCharacter::DistanceIntoFireField' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DistanceIntoSmokeFieldSmoothed) == 0x000518, "Member 'AAdvancedCharacter::DistanceIntoSmokeFieldSmoothed' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DistanceIntoSmokeField) == 0x00051C, "Member 'AAdvancedCharacter::DistanceIntoSmokeField' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookUpValue) == 0x000520, "Member 'AAdvancedCharacter::LookUpValue' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, OriginalMesh) == 0x000528, "Member 'AAdvancedCharacter::OriginalMesh' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, OnCharacterDied) == 0x000530, "Member 'AAdvancedCharacter::OnCharacterDied' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, OnTakeDamage) == 0x000540, "Member 'AAdvancedCharacter::OnTakeDamage' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, OnCharacterDestroyed) == 0x000558, "Member 'AAdvancedCharacter::OnCharacterDestroyed' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, OnTornOff) == 0x000568, "Member 'AAdvancedCharacter::OnTornOff' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, OnUnPossessed) == 0x000578, "Member 'AAdvancedCharacter::OnUnPossessed' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, OnChangedTeam) == 0x000588, "Member 'AAdvancedCharacter::OnChangedTeam' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, OnCharacterBecomeViewTarget) == 0x000598, "Member 'AAdvancedCharacter::OnCharacterBecomeViewTarget' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, OnCharacterEndViewTarget) == 0x0005A8, "Member 'AAdvancedCharacter::OnCharacterEndViewTarget' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, UniqueAdvancedCharacterIndex) == 0x0005E8, "Member 'AAdvancedCharacter::UniqueAdvancedCharacterIndex' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, MouseSmoothedTurnValue) == 0x0005EC, "Member 'AAdvancedCharacter::MouseSmoothedTurnValue' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, MouseSmoothingTurnVelocity) == 0x0005F0, "Member 'AAdvancedCharacter::MouseSmoothingTurnVelocity' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, MouseSmoothedLookUpValue) == 0x0005F4, "Member 'AAdvancedCharacter::MouseSmoothedLookUpValue' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, MouseSmoothingLookUpVelocity) == 0x0005F8, "Member 'AAdvancedCharacter::MouseSmoothingLookUpVelocity' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, PrePhysTickFunction) == 0x000600, "Member 'AAdvancedCharacter::PrePhysTickFunction' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LODDeltaTime) == 0x000630, "Member 'AAdvancedCharacter::LODDeltaTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LateLODDeltaTime) == 0x000634, "Member 'AAdvancedCharacter::LateLODDeltaTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, Team) == 0x000660, "Member 'AAdvancedCharacter::Team' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bDisableOverlapsIfClientNotViewTarget) == 0x000661, "Member 'AAdvancedCharacter::bDisableOverlapsIfClientNotViewTarget' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, TagSystemComponent) == 0x000668, "Member 'AAdvancedCharacter::TagSystemComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DismemberableComponent) == 0x000670, "Member 'AAdvancedCharacter::DismemberableComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, EquipmentSystemComponent) == 0x000678, "Member 'AAdvancedCharacter::EquipmentSystemComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DriverComponent) == 0x000680, "Member 'AAdvancedCharacter::DriverComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, MotionSystemComponent) == 0x000688, "Member 'AAdvancedCharacter::MotionSystemComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, PerkSystemComponent) == 0x000690, "Member 'AAdvancedCharacter::PerkSystemComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, InteractionSystemComponent) == 0x000698, "Member 'AAdvancedCharacter::InteractionSystemComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, CharacterVoiceComponent) == 0x0006A0, "Member 'AAdvancedCharacter::CharacterVoiceComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, StaminaStatComponent) == 0x0006A8, "Member 'AAdvancedCharacter::StaminaStatComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DamageableComponent) == 0x0006B0, "Member 'AAdvancedCharacter::DamageableComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, HealthStatComponent) == 0x0006B8, "Member 'AAdvancedCharacter::HealthStatComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, BodyThudder) == 0x0006C0, "Member 'AAdvancedCharacter::BodyThudder' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepAudioComponentCount) == 0x0006C8, "Member 'AAdvancedCharacter::FootstepAudioComponentCount' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepAudioComponents) == 0x0006D0, "Member 'AAdvancedCharacter::FootstepAudioComponents' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepLODDistance) == 0x0006E4, "Member 'AAdvancedCharacter::FootstepLODDistance' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepEffectsMaxCameraDist) == 0x0006E8, "Member 'AAdvancedCharacter::FootstepEffectsMaxCameraDist' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FeetBones) == 0x0006F0, "Member 'AAdvancedCharacter::FeetBones' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepDecalSize) == 0x000700, "Member 'AAdvancedCharacter::FootstepDecalSize' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepDecals) == 0x000710, "Member 'AAdvancedCharacter::FootstepDecals' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepParticles) == 0x000720, "Member 'AAdvancedCharacter::FootstepParticles' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepSound) == 0x000730, "Member 'AAdvancedCharacter::FootstepSound' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepSoundZOffset) == 0x000738, "Member 'AAdvancedCharacter::FootstepSoundZOffset' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepVolumeVelocityRangeIn) == 0x00073C, "Member 'AAdvancedCharacter::FootstepVolumeVelocityRangeIn' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepVolumeVelocityRangeOut) == 0x000744, "Member 'AAdvancedCharacter::FootstepVolumeVelocityRangeOut' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepPitchVelocityRangeIn) == 0x00074C, "Member 'AAdvancedCharacter::FootstepPitchVelocityRangeIn' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepPitchVelocityRangeOut) == 0x000754, "Member 'AAdvancedCharacter::FootstepPitchVelocityRangeOut' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepVolumeModifierViewTarget) == 0x00075C, "Member 'AAdvancedCharacter::FootstepVolumeModifierViewTarget' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepVolumeModifierAlly) == 0x000760, "Member 'AAdvancedCharacter::FootstepVolumeModifierAlly' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepVolumeModifierEnemy) == 0x000764, "Member 'AAdvancedCharacter::FootstepVolumeModifierEnemy' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FootstepArmorTier) == 0x000768, "Member 'AAdvancedCharacter::FootstepArmorTier' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ClientPhysicsAsset) == 0x000770, "Member 'AAdvancedCharacter::ClientPhysicsAsset' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, BodyRagdollPhysicsAsset) == 0x000778, "Member 'AAdvancedCharacter::BodyRagdollPhysicsAsset' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DismemberedQueue) == 0x000780, "Member 'AAdvancedCharacter::DismemberedQueue' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, MoveCompVelocityBeforeDeath) == 0x0007E0, "Member 'AAdvancedCharacter::MoveCompVelocityBeforeDeath' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LastNonZeroVelocityTime) == 0x0007EC, "Member 'AAdvancedCharacter::LastNonZeroVelocityTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bCanReceiveClientsideHits) == 0x0007F0, "Member 'AAdvancedCharacter::bCanReceiveClientsideHits' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DamageArmorTierOverride) == 0x0007F4, "Member 'AAdvancedCharacter::DamageArmorTierOverride' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bDisableRagdollFalling) == 0x0007F8, "Member 'AAdvancedCharacter::bDisableRagdollFalling' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DissolveDuration) == 0x0007FC, "Member 'AAdvancedCharacter::DissolveDuration' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LateTickComponent) == 0x000800, "Member 'AAdvancedCharacter::LateTickComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DistanceToCameraHeuristic) == 0x000808, "Member 'AAdvancedCharacter::DistanceToCameraHeuristic' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DistanceToCamera) == 0x00080C, "Member 'AAdvancedCharacter::DistanceToCamera' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, OcclusionToCamera) == 0x000810, "Member 'AAdvancedCharacter::OcclusionToCamera' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bSkipAnimPoseOnClientWhenNotRendered) == 0x000814, "Member 'AAdvancedCharacter::bSkipAnimPoseOnClientWhenNotRendered' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DistanceToCameraMeshOffset) == 0x000818, "Member 'AAdvancedCharacter::DistanceToCameraMeshOffset' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LODRank) == 0x000824, "Member 'AAdvancedCharacter::LODRank' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LODBucketLevel) == 0x000828, "Member 'AAdvancedCharacter::LODBucketLevel' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bFancyMeshEffects) == 0x00082C, "Member 'AAdvancedCharacter::bFancyMeshEffects' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FancyMeshEffectsTurnOnDistance) == 0x000830, "Member 'AAdvancedCharacter::FancyMeshEffectsTurnOnDistance' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FancyMeshEffectsTurnOffDistance) == 0x000834, "Member 'AAdvancedCharacter::FancyMeshEffectsTurnOffDistance' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bForceMaxQuality) == 0x000838, "Member 'AAdvancedCharacter::bForceMaxQuality' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ReplicatedCharacterFlags) == 0x000839, "Member 'AAdvancedCharacter::ReplicatedCharacterFlags' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bWasEverPossessedByLocalPlayer) == 0x00083A, "Member 'AAdvancedCharacter::bWasEverPossessedByLocalPlayer' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LastPossessionTime) == 0x00083C, "Member 'AAdvancedCharacter::LastPossessionTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, RagdollFallingGetUpDuration) == 0x000840, "Member 'AAdvancedCharacter::RagdollFallingGetUpDuration' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, RagdollFallingGetUpStartTime) == 0x000844, "Member 'AAdvancedCharacter::RagdollFallingGetUpStartTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, RagdollFallingStartTime) == 0x000848, "Member 'AAdvancedCharacter::RagdollFallingStartTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, RagdollFallingMinTime) == 0x00084C, "Member 'AAdvancedCharacter::RagdollFallingMinTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, RagdollFallingMinVelocityToGetUp) == 0x000850, "Member 'AAdvancedCharacter::RagdollFallingMinVelocityToGetUp' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, RagdollFallingTimeAtMinVelocityToGetUp) == 0x000854, "Member 'AAdvancedCharacter::RagdollFallingTimeAtMinVelocityToGetUp' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, JumpCooldown) == 0x000864, "Member 'AAdvancedCharacter::JumpCooldown' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bJumped) == 0x000868, "Member 'AAdvancedCharacter::bJumped' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bIsAirborneFromJump) == 0x000869, "Member 'AAdvancedCharacter::bIsAirborneFromJump' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, AirborneTime) == 0x00086C, "Member 'AAdvancedCharacter::AirborneTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, SmokeDistanceMaxValue) == 0x000870, "Member 'AAdvancedCharacter::SmokeDistanceMaxValue' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, SmokeDistanceSmoothInterpSpeed) == 0x000874, "Member 'AAdvancedCharacter::SmokeDistanceSmoothInterpSpeed' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, CurrentSmokeField) == 0x000878, "Member 'AAdvancedCharacter::CurrentSmokeField' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, BurnableComponent) == 0x000880, "Member 'AAdvancedCharacter::BurnableComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bMeshesReceiveDecals) == 0x000888, "Member 'AAdvancedCharacter::bMeshesReceiveDecals' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, CurrentProjectile) == 0x000890, "Member 'AAdvancedCharacter::CurrentProjectile' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bTurnUsesControllerInputYawScale) == 0x000898, "Member 'AAdvancedCharacter::bTurnUsesControllerInputYawScale' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bAddForwardAxisToMovementInput) == 0x000899, "Member 'AAdvancedCharacter::bAddForwardAxisToMovementInput' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bAddRightAxisToMovementInput) == 0x00089A, "Member 'AAdvancedCharacter::bAddRightAxisToMovementInput' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, SpawnTurnValue) == 0x00089C, "Member 'AAdvancedCharacter::SpawnTurnValue' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookUpLimit) == 0x0008A0, "Member 'AAdvancedCharacter::LookUpLimit' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookDownLimit) == 0x0008A4, "Member 'AAdvancedCharacter::LookDownLimit' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, TurnLimit) == 0x0008A8, "Member 'AAdvancedCharacter::TurnLimit' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ReplicatedLookUpValue) == 0x0008AC, "Member 'AAdvancedCharacter::ReplicatedLookUpValue' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookUpValueSmoothingTarget) == 0x0008B0, "Member 'AAdvancedCharacter::LookUpValueSmoothingTarget' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookUpValueSmoothingFrom) == 0x0008B4, "Member 'AAdvancedCharacter::LookUpValueSmoothingFrom' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookUpValueSmoothingStartTime) == 0x0008B8, "Member 'AAdvancedCharacter::LookUpValueSmoothingStartTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookUpValueSmoothingEndTime) == 0x0008BC, "Member 'AAdvancedCharacter::LookUpValueSmoothingEndTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookSmoothingSlowAlpha) == 0x0008C0, "Member 'AAdvancedCharacter::LookSmoothingSlowAlpha' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, TurnRateCap) == 0x0008C4, "Member 'AAdvancedCharacter::TurnRateCap' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, TurnRateCapTarget) == 0x0008C8, "Member 'AAdvancedCharacter::TurnRateCapTarget' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookUpRateCap) == 0x0008CC, "Member 'AAdvancedCharacter::LookUpRateCap' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookUpRateCapTarget) == 0x0008D0, "Member 'AAdvancedCharacter::LookUpRateCapTarget' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bTurnRateIgnoresCap) == 0x0008D4, "Member 'AAdvancedCharacter::bTurnRateIgnoresCap' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, TurnCapRemaining) == 0x0008D8, "Member 'AAdvancedCharacter::TurnCapRemaining' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookUpCapRemaining) == 0x0008DC, "Member 'AAdvancedCharacter::LookUpCapRemaining' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LastObservedLocation) == 0x0008E0, "Member 'AAdvancedCharacter::LastObservedLocation' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, AccumulatedLocationLag) == 0x0008EC, "Member 'AAdvancedCharacter::AccumulatedLocationLag' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DelayedLocationDeltas) == 0x0008F8, "Member 'AAdvancedCharacter::DelayedLocationDeltas' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, CurrentLocationLagInduction) == 0x000908, "Member 'AAdvancedCharacter::CurrentLocationLagInduction' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LocationLagInductionTarget) == 0x00090C, "Member 'AAdvancedCharacter::LocationLagInductionTarget' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LocationLagInductionChangeSpeed) == 0x000910, "Member 'AAdvancedCharacter::LocationLagInductionChangeSpeed' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LocationLagInductionCounterweight) == 0x000914, "Member 'AAdvancedCharacter::LocationLagInductionCounterweight' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LastObservedLook) == 0x000918, "Member 'AAdvancedCharacter::LastObservedLook' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, AccumulatedLookLag) == 0x000924, "Member 'AAdvancedCharacter::AccumulatedLookLag' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DelayedLookDeltas) == 0x000930, "Member 'AAdvancedCharacter::DelayedLookDeltas' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, CurrentLookLagInduction) == 0x000940, "Member 'AAdvancedCharacter::CurrentLookLagInduction' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookLagInductionTarget) == 0x000944, "Member 'AAdvancedCharacter::LookLagInductionTarget' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookLagInductionChangeSpeed) == 0x000948, "Member 'AAdvancedCharacter::LookLagInductionChangeSpeed' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LookLagInductionCounterweight) == 0x00094C, "Member 'AAdvancedCharacter::LookLagInductionCounterweight' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bPerformCustomDepthHighlight) == 0x000950, "Member 'AAdvancedCharacter::bPerformCustomDepthHighlight' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bIsHighlighted) == 0x000951, "Member 'AAdvancedCharacter::bIsHighlighted' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bIsInteractable) == 0x000952, "Member 'AAdvancedCharacter::bIsInteractable' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, MarkerWidgetComponentClass) == 0x000958, "Member 'AAdvancedCharacter::MarkerWidgetComponentClass' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, MarkerWidgetClass) == 0x000960, "Member 'AAdvancedCharacter::MarkerWidgetClass' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, MarkerWidgetRelativeTransform) == 0x000970, "Member 'AAdvancedCharacter::MarkerWidgetRelativeTransform' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, MarkerWidgetAttachSocket) == 0x0009A0, "Member 'AAdvancedCharacter::MarkerWidgetAttachSocket' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, MarkerWidgetComponent) == 0x0009A8, "Member 'AAdvancedCharacter::MarkerWidgetComponent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bCannotRequestSuicide) == 0x0009B0, "Member 'AAdvancedCharacter::bCannotRequestSuicide' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bWillStopMelee) == 0x0009B1, "Member 'AAdvancedCharacter::bWillStopMelee' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bWillBleedOutOnKill) == 0x0009B2, "Member 'AAdvancedCharacter::bWillBleedOutOnKill' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, BleedingOutRemainingTime) == 0x0009B4, "Member 'AAdvancedCharacter::BleedingOutRemainingTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bIsBleedingOut) == 0x0009B8, "Member 'AAdvancedCharacter::bIsBleedingOut' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DeathParticles) == 0x0009C0, "Member 'AAdvancedCharacter::DeathParticles' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DeathParticlesSocket) == 0x0009C8, "Member 'AAdvancedCharacter::DeathParticlesSocket' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bDisableHealingItems) == 0x0009D0, "Member 'AAdvancedCharacter::bDisableHealingItems' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, Health) == 0x0009D1, "Member 'AAdvancedCharacter::Health' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ReplicatedHealth) == 0x0009D2, "Member 'AAdvancedCharacter::ReplicatedHealth' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, HealthRegenDelay) == 0x0009D4, "Member 'AAdvancedCharacter::HealthRegenDelay' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, HealthRegenPerTick) == 0x0009D8, "Member 'AAdvancedCharacter::HealthRegenPerTick' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, HealthRegenTickRate) == 0x0009DC, "Member 'AAdvancedCharacter::HealthRegenTickRate' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bIgnoreGameStateHealthRegenRestriction) == 0x0009E0, "Member 'AAdvancedCharacter::bIgnoreGameStateHealthRegenRestriction' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, OutOfBoundsKillTime) == 0x0009E4, "Member 'AAdvancedCharacter::OutOfBoundsKillTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bIsAllowedOutOfBounds) == 0x0009E8, "Member 'AAdvancedCharacter::bIsAllowedOutOfBounds' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bTeamkillsCountForAutoKick) == 0x0009E9, "Member 'AAdvancedCharacter::bTeamkillsCountForAutoKick' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ReflectMeleeDamagePercentage) == 0x0009EC, "Member 'AAdvancedCharacter::ReflectMeleeDamagePercentage' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bHasLastChance) == 0x0009F0, "Member 'AAdvancedCharacter::bHasLastChance' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LastChanceHealAmount) == 0x0009F4, "Member 'AAdvancedCharacter::LastChanceHealAmount' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ReceivedDamageModifier) == 0x0009F8, "Member 'AAdvancedCharacter::ReceivedDamageModifier' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ReceivedFallDamageModifier) == 0x0009FC, "Member 'AAdvancedCharacter::ReceivedFallDamageModifier' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ReceivedTeamDamageModifier) == 0x000A00, "Member 'AAdvancedCharacter::ReceivedTeamDamageModifier' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ReceivedFireDamageModifier) == 0x000A04, "Member 'AAdvancedCharacter::ReceivedFireDamageModifier' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ReceivedRangedDamageModifier) == 0x000A08, "Member 'AAdvancedCharacter::ReceivedRangedDamageModifier' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ReceivedDamageAbsorption) == 0x000A0C, "Member 'AAdvancedCharacter::ReceivedDamageAbsorption' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ReceivedDamageMax) == 0x000A10, "Member 'AAdvancedCharacter::ReceivedDamageMax' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, KnockbackFlinch) == 0x000A14, "Member 'AAdvancedCharacter::KnockbackFlinch' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, HitEffect) == 0x000A18, "Member 'AAdvancedCharacter::HitEffect' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, BurningParticles) == 0x000A20, "Member 'AAdvancedCharacter::BurningParticles' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, BurningAttachSocket) == 0x000A28, "Member 'AAdvancedCharacter::BurningAttachSocket' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, BurningSound) == 0x000A30, "Member 'AAdvancedCharacter::BurningSound' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FallDamageSound) == 0x000A38, "Member 'AAdvancedCharacter::FallDamageSound' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FallDamageForceFeedback) == 0x000A40, "Member 'AAdvancedCharacter::FallDamageForceFeedback' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DisarmedForceFeedback) == 0x000A48, "Member 'AAdvancedCharacter::DisarmedForceFeedback' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, StunnedForceFeedback) == 0x000A50, "Member 'AAdvancedCharacter::StunnedForceFeedback' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, OnFireForceFeedback) == 0x000A58, "Member 'AAdvancedCharacter::OnFireForceFeedback' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, FallDamageSoundAttachToBone) == 0x000A60, "Member 'AAdvancedCharacter::FallDamageSoundAttachToBone' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, CurrentBurningParticles) == 0x000A68, "Member 'AAdvancedCharacter::CurrentBurningParticles' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, CurrentBurningSound) == 0x000A70, "Member 'AAdvancedCharacter::CurrentBurningSound' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, NetDamage) == 0x000A78, "Member 'AAdvancedCharacter::NetDamage' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DeathTime) == 0x000A9C, "Member 'AAdvancedCharacter::DeathTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ViewTargetAttenuationVolumeMultiplier) == 0x000AA0, "Member 'AAdvancedCharacter::ViewTargetAttenuationVolumeMultiplier' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, ViewTargetAttenuationOverride) == 0x000AA8, "Member 'AAdvancedCharacter::ViewTargetAttenuationOverride' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bForceLongDeathYell) == 0x000AB0, "Member 'AAdvancedCharacter::bForceLongDeathYell' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, HurtYell) == 0x000AB8, "Member 'AAdvancedCharacter::HurtYell' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DeathYell) == 0x000AC0, "Member 'AAdvancedCharacter::DeathYell' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, DedicatedServerAnimFrameSkipLOD) == 0x000AC8, "Member 'AAdvancedCharacter::DedicatedServerAnimFrameSkipLOD' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, AdditiveOverrideType) == 0x000ACC, "Member 'AAdvancedCharacter::AdditiveOverrideType' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, AdditiveOverrideEndTime) == 0x000AD4, "Member 'AAdvancedCharacter::AdditiveOverrideEndTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, AdditiveOverrideStartTime) == 0x000AD8, "Member 'AAdvancedCharacter::AdditiveOverrideStartTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LastFlinchAdditiveName) == 0x000ADC, "Member 'AAdvancedCharacter::LastFlinchAdditiveName' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, LastFlinchAdditiveTime) == 0x000AE4, "Member 'AAdvancedCharacter::LastFlinchAdditiveTime' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, CharacterSurface) == 0x000AE8, "Member 'AAdvancedCharacter::CharacterSurface' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, SphericalLimbs) == 0x000AF0, "Member 'AAdvancedCharacter::SphericalLimbs' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, RagdollForceMultIfDmgAgent) == 0x000B00, "Member 'AAdvancedCharacter::RagdollForceMultIfDmgAgent' has a wrong offset!");
static_assert(offsetof(AAdvancedCharacter, bForceRagdollIfDmgAgent) == 0x000B04, "Member 'AAdvancedCharacter::bForceRagdollIfDmgAgent' has a wrong offset!");

// Class Mordhau.CustomizationReplicationActor
// 0x0220 (0x0440 - 0x0220)
class ACustomizationReplicationActor final : public AActor
{
public:
	bool                                          bHasReplicatedAnything;                            // 0x0220(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         LastRebuiltVersionTracker;                         // 0x0221(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_222[0x6];                                      // 0x0222(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterProfile                      LastAssignedProfile;                               // 0x0228(0x00B8)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AMordhauCharacter>> RegisteredCharacters;                              // 0x02E0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bWasEverAssigned;                                  // 0x02F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillDestroyOnUnregister;                          // 0x02F1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F2[0x6];                                      // 0x02F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          Cached1PMesh;                                      // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          Cached1PDeadMesh;                                  // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          CachedUnifiedMesh;                                 // 0x0308(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     EyesMat;                                           // 0x0310(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TorsoMat;                                          // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Arm1PMat;                                          // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     HairMat;                                           // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     FacialHairMat;                                     // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRepFaceArrayShortWithVersion          ReplicatedFaceBonesTranslate;                      // 0x0338(0x0018)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FRepFaceArrayShortWithVersion          ReplicatedFaceBonesRotate;                         // 0x0350(0x0018)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FRepFaceArrayShortWithVersion          ReplicatedFaceBonesScale;                          // 0x0368(0x0018)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FRepArrayAppearanceWithVersion         ReplicatedAppearanceCustomization;                 // 0x0380(0x0030)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FRepArraySkillsWithVersion             ReplicatedSkillsCustomization;                     // 0x03B0(0x0008)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FRepArrayByteWithVersion               ReplicatedDefaultEquipmentId;                      // 0x03B8(0x0018)(Net, RepNotify, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AMordhauEquipment>>  DefaultEquipment;                                  // 0x03D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FRepArrayByteWithVersion               ReplicatedWearableId;                              // 0x03E0(0x0018)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FRepArrayByteWithVersion               ReplicatedWearableColor1;                          // 0x03F8(0x0018)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FRepArrayByteWithVersion               ReplicatedWearableColor2;                          // 0x0410(0x0018)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FRepArrayByteWithVersion               ReplicatedWearablePattern;                         // 0x0428(0x0018)(Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void AssignDataFromProfile(const struct FCharacterProfile& Profile);
	bool IsUpToDate();
	void OnRep_ReplicatedAppearanceCustomization();
	void OnRep_ReplicatedDefaultEquipmentId();
	void OnRep_ReplicatedFaceBonesRotate();
	void OnRep_ReplicatedFaceBonesScale();
	void OnRep_ReplicatedFaceBonesTranslate();
	void OnRep_ReplicatedSkillsCustomization();
	void OnRep_ReplicatedWearableColor1();
	void OnRep_ReplicatedWearableColor2();
	void OnRep_ReplicatedWearableId();
	void OnRep_ReplicatedWearablePattern();
	void RegisterCharacter(class AMordhauCharacter* Character);
	void TriggerUpdateIfUpToDate();
	void UnregisterCharacter(class AMordhauCharacter* Character);
	void UpdateCharacterProfile(class AMordhauCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationReplicationActor">();
	}
	static class ACustomizationReplicationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationReplicationActor>();
	}
};
static_assert(alignof(ACustomizationReplicationActor) == 0x000008, "Wrong alignment on ACustomizationReplicationActor");
static_assert(sizeof(ACustomizationReplicationActor) == 0x000440, "Wrong size on ACustomizationReplicationActor");
static_assert(offsetof(ACustomizationReplicationActor, bHasReplicatedAnything) == 0x000220, "Member 'ACustomizationReplicationActor::bHasReplicatedAnything' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, LastRebuiltVersionTracker) == 0x000221, "Member 'ACustomizationReplicationActor::LastRebuiltVersionTracker' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, LastAssignedProfile) == 0x000228, "Member 'ACustomizationReplicationActor::LastAssignedProfile' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, RegisteredCharacters) == 0x0002E0, "Member 'ACustomizationReplicationActor::RegisteredCharacters' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, bWasEverAssigned) == 0x0002F0, "Member 'ACustomizationReplicationActor::bWasEverAssigned' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, bWillDestroyOnUnregister) == 0x0002F1, "Member 'ACustomizationReplicationActor::bWillDestroyOnUnregister' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, Cached1PMesh) == 0x0002F8, "Member 'ACustomizationReplicationActor::Cached1PMesh' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, Cached1PDeadMesh) == 0x000300, "Member 'ACustomizationReplicationActor::Cached1PDeadMesh' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, CachedUnifiedMesh) == 0x000308, "Member 'ACustomizationReplicationActor::CachedUnifiedMesh' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, EyesMat) == 0x000310, "Member 'ACustomizationReplicationActor::EyesMat' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, TorsoMat) == 0x000318, "Member 'ACustomizationReplicationActor::TorsoMat' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, Arm1PMat) == 0x000320, "Member 'ACustomizationReplicationActor::Arm1PMat' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, HairMat) == 0x000328, "Member 'ACustomizationReplicationActor::HairMat' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, FacialHairMat) == 0x000330, "Member 'ACustomizationReplicationActor::FacialHairMat' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, ReplicatedFaceBonesTranslate) == 0x000338, "Member 'ACustomizationReplicationActor::ReplicatedFaceBonesTranslate' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, ReplicatedFaceBonesRotate) == 0x000350, "Member 'ACustomizationReplicationActor::ReplicatedFaceBonesRotate' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, ReplicatedFaceBonesScale) == 0x000368, "Member 'ACustomizationReplicationActor::ReplicatedFaceBonesScale' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, ReplicatedAppearanceCustomization) == 0x000380, "Member 'ACustomizationReplicationActor::ReplicatedAppearanceCustomization' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, ReplicatedSkillsCustomization) == 0x0003B0, "Member 'ACustomizationReplicationActor::ReplicatedSkillsCustomization' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, ReplicatedDefaultEquipmentId) == 0x0003B8, "Member 'ACustomizationReplicationActor::ReplicatedDefaultEquipmentId' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, DefaultEquipment) == 0x0003D0, "Member 'ACustomizationReplicationActor::DefaultEquipment' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, ReplicatedWearableId) == 0x0003E0, "Member 'ACustomizationReplicationActor::ReplicatedWearableId' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, ReplicatedWearableColor1) == 0x0003F8, "Member 'ACustomizationReplicationActor::ReplicatedWearableColor1' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, ReplicatedWearableColor2) == 0x000410, "Member 'ACustomizationReplicationActor::ReplicatedWearableColor2' has a wrong offset!");
static_assert(offsetof(ACustomizationReplicationActor, ReplicatedWearablePattern) == 0x000428, "Member 'ACustomizationReplicationActor::ReplicatedWearablePattern' has a wrong offset!");

// Class Mordhau.MordhauNewsWidget
// 0x00D0 (0x0330 - 0x0260)
class UMordhauNewsWidget : public UUserWidget
{
public:
	class FString                                 NewsURL;                                           // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Verb;                                              // 0x0270(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Filename;                                          // 0x0280(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             StyleH1;                                           // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             StyleH22;                                          // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             StyleH3;                                           // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             StyleH4;                                           // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             StyleH5;                                           // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             StyleH6;                                           // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             StyleNormal;                                       // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             StyleSubtitle;                                     // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FMordhauML& MordhauMLData, int32 ResponseCode, float ElapsedTime)> FOnRefreshCompleted;                               // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x50];                                     // 0x02E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAndBroadcastErrorMessage(const class FString& Message, int32 ResponseCode, int32 ElapsedTime);
	bool SendHTTPRequest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauNewsWidget">();
	}
	static class UMordhauNewsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauNewsWidget>();
	}
};
static_assert(alignof(UMordhauNewsWidget) == 0x000008, "Wrong alignment on UMordhauNewsWidget");
static_assert(sizeof(UMordhauNewsWidget) == 0x000330, "Wrong size on UMordhauNewsWidget");
static_assert(offsetof(UMordhauNewsWidget, NewsURL) == 0x000260, "Member 'UMordhauNewsWidget::NewsURL' has a wrong offset!");
static_assert(offsetof(UMordhauNewsWidget, Verb) == 0x000270, "Member 'UMordhauNewsWidget::Verb' has a wrong offset!");
static_assert(offsetof(UMordhauNewsWidget, Filename) == 0x000280, "Member 'UMordhauNewsWidget::Filename' has a wrong offset!");
static_assert(offsetof(UMordhauNewsWidget, StyleH1) == 0x000290, "Member 'UMordhauNewsWidget::StyleH1' has a wrong offset!");
static_assert(offsetof(UMordhauNewsWidget, StyleH22) == 0x000298, "Member 'UMordhauNewsWidget::StyleH22' has a wrong offset!");
static_assert(offsetof(UMordhauNewsWidget, StyleH3) == 0x0002A0, "Member 'UMordhauNewsWidget::StyleH3' has a wrong offset!");
static_assert(offsetof(UMordhauNewsWidget, StyleH4) == 0x0002A8, "Member 'UMordhauNewsWidget::StyleH4' has a wrong offset!");
static_assert(offsetof(UMordhauNewsWidget, StyleH5) == 0x0002B0, "Member 'UMordhauNewsWidget::StyleH5' has a wrong offset!");
static_assert(offsetof(UMordhauNewsWidget, StyleH6) == 0x0002B8, "Member 'UMordhauNewsWidget::StyleH6' has a wrong offset!");
static_assert(offsetof(UMordhauNewsWidget, StyleNormal) == 0x0002C0, "Member 'UMordhauNewsWidget::StyleNormal' has a wrong offset!");
static_assert(offsetof(UMordhauNewsWidget, StyleSubtitle) == 0x0002C8, "Member 'UMordhauNewsWidget::StyleSubtitle' has a wrong offset!");
static_assert(offsetof(UMordhauNewsWidget, FOnRefreshCompleted) == 0x0002D0, "Member 'UMordhauNewsWidget::FOnRefreshCompleted' has a wrong offset!");

// Class Mordhau.DamageableComponent
// 0x0078 (0x0128 - 0x00B0)
class UDamageableComponent final : public UActorComponent
{
public:
	TWeakObjectPtr<class AActor>                  LastDamageAgent;                                   // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  LastDamageSource;                                  // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AController>             LastDamageInstigator;                              // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeamDamageModifier;                                // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireDamageModifier;                                // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallDamageModifier;                                // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedDamageModifier;                              // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageModifier;                                    // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDamage;                                         // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAbsorption;                                  // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnProtectionDuration;                           // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              Surface;                                           // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopsMeleeAttacks;                                // 0x00E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x2];                                       // 0x00EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNetDamage                             NetDamage;                                         // 0x00EC(0x0024)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x18];                                     // 0x0110(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float ModifyDamage(float DamageAmount, const struct FMordhauDamageInfo& DamageInfo, class AController* EventInstigator, class AActor* DamageCauser);
	void OnKilled();
	void OnPostTakeDamage(float DamageAmount, const struct FMordhauDamageInfo& DamageInfo, class AController* EventInstigator, class AActor* DamageCauser);
	void OnRep_NetDamage();
	float OnTakeDamage(float DamageAmount, const struct FMordhauDamageInfo& DamageInfo, class AController* EventInstigator, class AActor* DamageCauser);
	void OnTookDamage(bool bWillKill, EMordhauDamageType Type, uint8 SubType, const class FName& bone, const struct FVector& Point, class AActor* Source, class AActor* Agent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageableComponent">();
	}
	static class UDamageableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageableComponent>();
	}
};
static_assert(alignof(UDamageableComponent) == 0x000008, "Wrong alignment on UDamageableComponent");
static_assert(sizeof(UDamageableComponent) == 0x000128, "Wrong size on UDamageableComponent");
static_assert(offsetof(UDamageableComponent, LastDamageAgent) == 0x0000B0, "Member 'UDamageableComponent::LastDamageAgent' has a wrong offset!");
static_assert(offsetof(UDamageableComponent, LastDamageSource) == 0x0000B8, "Member 'UDamageableComponent::LastDamageSource' has a wrong offset!");
static_assert(offsetof(UDamageableComponent, LastDamageInstigator) == 0x0000C0, "Member 'UDamageableComponent::LastDamageInstigator' has a wrong offset!");
static_assert(offsetof(UDamageableComponent, TeamDamageModifier) == 0x0000C8, "Member 'UDamageableComponent::TeamDamageModifier' has a wrong offset!");
static_assert(offsetof(UDamageableComponent, FireDamageModifier) == 0x0000CC, "Member 'UDamageableComponent::FireDamageModifier' has a wrong offset!");
static_assert(offsetof(UDamageableComponent, FallDamageModifier) == 0x0000D0, "Member 'UDamageableComponent::FallDamageModifier' has a wrong offset!");
static_assert(offsetof(UDamageableComponent, RangedDamageModifier) == 0x0000D4, "Member 'UDamageableComponent::RangedDamageModifier' has a wrong offset!");
static_assert(offsetof(UDamageableComponent, DamageModifier) == 0x0000D8, "Member 'UDamageableComponent::DamageModifier' has a wrong offset!");
static_assert(offsetof(UDamageableComponent, MaxDamage) == 0x0000DC, "Member 'UDamageableComponent::MaxDamage' has a wrong offset!");
static_assert(offsetof(UDamageableComponent, DamageAbsorption) == 0x0000E0, "Member 'UDamageableComponent::DamageAbsorption' has a wrong offset!");
static_assert(offsetof(UDamageableComponent, SpawnProtectionDuration) == 0x0000E4, "Member 'UDamageableComponent::SpawnProtectionDuration' has a wrong offset!");
static_assert(offsetof(UDamageableComponent, Surface) == 0x0000E8, "Member 'UDamageableComponent::Surface' has a wrong offset!");
static_assert(offsetof(UDamageableComponent, bStopsMeleeAttacks) == 0x0000E9, "Member 'UDamageableComponent::bStopsMeleeAttacks' has a wrong offset!");
static_assert(offsetof(UDamageableComponent, NetDamage) == 0x0000EC, "Member 'UDamageableComponent::NetDamage' has a wrong offset!");

// Class Mordhau.MordhauCameraComponent
// 0x01F0 (0x09B0 - 0x07C0)
class UMordhauCameraComponent : public UCameraComponent
{
public:
	uint8                                         Pad_7C0[0x20];                                     // 0x07C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCameraCycleFrequency;                           // 0x07E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstPersonLookUpOffset;                           // 0x07E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingCameraActivateChangeSpeed;                   // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingCameraDisableChangeSpeed;                    // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F0[0x4];                                      // 0x07F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CinematicCameraBlendWeight;                        // 0x07F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumCinematicCameraBlendWeight;                 // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FirstPersonCinematicCameraOffset;                  // 0x07FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ThirdPersonCinematicCameraOffset;                  // 0x0808(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CinematicCameraRotationOffset;                     // 0x0814(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxThirdPersonFOV;                                 // 0x0820(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ThirdPersonRotationOffset;                         // 0x0824(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ThirdPersonCameraOffset;                           // 0x0830(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ThirdPersonAimingCameraRotationOffset;             // 0x083C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ThirdPersonAimingCameraOffset;                     // 0x0848(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdPersonHipsSmoothSpeed;                        // 0x0854(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ThirdPersonHipsSmoothLimits;                       // 0x0858(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdPersonTeleportThreshold;                      // 0x0864(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadCameraLocationSmoothSpeed;                     // 0x0868(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadCameraLocationSmoothMaxDistance;               // 0x086C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadCameraRotationSmoothSpeed;                     // 0x0870(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SmoothedHeadLocation;                              // 0x0874(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SmoothedHeadRotation;                              // 0x0880(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88C[0x4];                                      // 0x088C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PreviousHeadTransform;                             // 0x0890(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TurnOnFirstPersonModelDistance;                    // 0x08C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnOnThirdPersonModelDistance;                    // 0x08C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ThirdToFirstBlendCurve;                            // 0x08C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FirstToThirdBlendCurve;                            // 0x08D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MapToFirstBlendCurve;                              // 0x08D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MapToThirdBlendCurve;                              // 0x08E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MapToFirstRotationBlendCurve;                      // 0x08E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MapToThirdRotationBlendCurve;                      // 0x08F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CameraStyleBlendingFrom;                           // 0x08F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CameraStyleBlendingTo;                             // 0x08F9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8FA[0x2];                                      // 0x08FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPOV                                   LastCameraStyleChangeCameraPOV;                    // 0x08FC(0x001C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPOV                                   LastVehicleCameraPOV;                              // 0x0918(0x001C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPOV                                   LastNonVehicleCameraPOV;                           // 0x0934(0x001C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPOV                                   LastCameraPOV;                                     // 0x0950(0x001C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsBlendingCameraStyle;                            // 0x096C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96D[0x3];                                      // 0x096D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraStyleChangeBlendDuration;                    // 0x0970(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MapCameraStyleChangeBlendDuration;                 // 0x0974(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SmoothedHipsOffset;                                // 0x0978(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousHipsLocation;                              // 0x0984(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CameraFOVToLocationOffsetScaleCurve;               // 0x0990(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousCharacterMeshLocation;                     // 0x0998(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A4[0xC];                                      // 0x09A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FPOV ComputeCameraPOV();
	void UpdateCamera();

	bool IsBlendingFromMapView() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauCameraComponent">();
	}
	static class UMordhauCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauCameraComponent>();
	}
};
static_assert(alignof(UMordhauCameraComponent) == 0x000010, "Wrong alignment on UMordhauCameraComponent");
static_assert(sizeof(UMordhauCameraComponent) == 0x0009B0, "Wrong size on UMordhauCameraComponent");
static_assert(offsetof(UMordhauCameraComponent, MaxCameraCycleFrequency) == 0x0007E0, "Member 'UMordhauCameraComponent::MaxCameraCycleFrequency' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, FirstPersonLookUpOffset) == 0x0007E4, "Member 'UMordhauCameraComponent::FirstPersonLookUpOffset' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, AimingCameraActivateChangeSpeed) == 0x0007E8, "Member 'UMordhauCameraComponent::AimingCameraActivateChangeSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, AimingCameraDisableChangeSpeed) == 0x0007EC, "Member 'UMordhauCameraComponent::AimingCameraDisableChangeSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, CinematicCameraBlendWeight) == 0x0007F4, "Member 'UMordhauCameraComponent::CinematicCameraBlendWeight' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, MinimumCinematicCameraBlendWeight) == 0x0007F8, "Member 'UMordhauCameraComponent::MinimumCinematicCameraBlendWeight' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, FirstPersonCinematicCameraOffset) == 0x0007FC, "Member 'UMordhauCameraComponent::FirstPersonCinematicCameraOffset' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, ThirdPersonCinematicCameraOffset) == 0x000808, "Member 'UMordhauCameraComponent::ThirdPersonCinematicCameraOffset' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, CinematicCameraRotationOffset) == 0x000814, "Member 'UMordhauCameraComponent::CinematicCameraRotationOffset' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, MaxThirdPersonFOV) == 0x000820, "Member 'UMordhauCameraComponent::MaxThirdPersonFOV' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, ThirdPersonRotationOffset) == 0x000824, "Member 'UMordhauCameraComponent::ThirdPersonRotationOffset' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, ThirdPersonCameraOffset) == 0x000830, "Member 'UMordhauCameraComponent::ThirdPersonCameraOffset' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, ThirdPersonAimingCameraRotationOffset) == 0x00083C, "Member 'UMordhauCameraComponent::ThirdPersonAimingCameraRotationOffset' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, ThirdPersonAimingCameraOffset) == 0x000848, "Member 'UMordhauCameraComponent::ThirdPersonAimingCameraOffset' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, ThirdPersonHipsSmoothSpeed) == 0x000854, "Member 'UMordhauCameraComponent::ThirdPersonHipsSmoothSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, ThirdPersonHipsSmoothLimits) == 0x000858, "Member 'UMordhauCameraComponent::ThirdPersonHipsSmoothLimits' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, ThirdPersonTeleportThreshold) == 0x000864, "Member 'UMordhauCameraComponent::ThirdPersonTeleportThreshold' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, DeadCameraLocationSmoothSpeed) == 0x000868, "Member 'UMordhauCameraComponent::DeadCameraLocationSmoothSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, DeadCameraLocationSmoothMaxDistance) == 0x00086C, "Member 'UMordhauCameraComponent::DeadCameraLocationSmoothMaxDistance' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, DeadCameraRotationSmoothSpeed) == 0x000870, "Member 'UMordhauCameraComponent::DeadCameraRotationSmoothSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, SmoothedHeadLocation) == 0x000874, "Member 'UMordhauCameraComponent::SmoothedHeadLocation' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, SmoothedHeadRotation) == 0x000880, "Member 'UMordhauCameraComponent::SmoothedHeadRotation' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, PreviousHeadTransform) == 0x000890, "Member 'UMordhauCameraComponent::PreviousHeadTransform' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, TurnOnFirstPersonModelDistance) == 0x0008C0, "Member 'UMordhauCameraComponent::TurnOnFirstPersonModelDistance' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, TurnOnThirdPersonModelDistance) == 0x0008C4, "Member 'UMordhauCameraComponent::TurnOnThirdPersonModelDistance' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, ThirdToFirstBlendCurve) == 0x0008C8, "Member 'UMordhauCameraComponent::ThirdToFirstBlendCurve' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, FirstToThirdBlendCurve) == 0x0008D0, "Member 'UMordhauCameraComponent::FirstToThirdBlendCurve' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, MapToFirstBlendCurve) == 0x0008D8, "Member 'UMordhauCameraComponent::MapToFirstBlendCurve' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, MapToThirdBlendCurve) == 0x0008E0, "Member 'UMordhauCameraComponent::MapToThirdBlendCurve' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, MapToFirstRotationBlendCurve) == 0x0008E8, "Member 'UMordhauCameraComponent::MapToFirstRotationBlendCurve' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, MapToThirdRotationBlendCurve) == 0x0008F0, "Member 'UMordhauCameraComponent::MapToThirdRotationBlendCurve' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, CameraStyleBlendingFrom) == 0x0008F8, "Member 'UMordhauCameraComponent::CameraStyleBlendingFrom' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, CameraStyleBlendingTo) == 0x0008F9, "Member 'UMordhauCameraComponent::CameraStyleBlendingTo' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, LastCameraStyleChangeCameraPOV) == 0x0008FC, "Member 'UMordhauCameraComponent::LastCameraStyleChangeCameraPOV' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, LastVehicleCameraPOV) == 0x000918, "Member 'UMordhauCameraComponent::LastVehicleCameraPOV' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, LastNonVehicleCameraPOV) == 0x000934, "Member 'UMordhauCameraComponent::LastNonVehicleCameraPOV' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, LastCameraPOV) == 0x000950, "Member 'UMordhauCameraComponent::LastCameraPOV' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, bIsBlendingCameraStyle) == 0x00096C, "Member 'UMordhauCameraComponent::bIsBlendingCameraStyle' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, CameraStyleChangeBlendDuration) == 0x000970, "Member 'UMordhauCameraComponent::CameraStyleChangeBlendDuration' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, MapCameraStyleChangeBlendDuration) == 0x000974, "Member 'UMordhauCameraComponent::MapCameraStyleChangeBlendDuration' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, SmoothedHipsOffset) == 0x000978, "Member 'UMordhauCameraComponent::SmoothedHipsOffset' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, PreviousHipsLocation) == 0x000984, "Member 'UMordhauCameraComponent::PreviousHipsLocation' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, CameraFOVToLocationOffsetScaleCurve) == 0x000990, "Member 'UMordhauCameraComponent::CameraFOVToLocationOffsetScaleCurve' has a wrong offset!");
static_assert(offsetof(UMordhauCameraComponent, PreviousCharacterMeshLocation) == 0x000998, "Member 'UMordhauCameraComponent::PreviousCharacterMeshLocation' has a wrong offset!");

// Class Mordhau.AdvancedCharacterMovement
// 0x0150 (0x0C50 - 0x0B00)
#pragma pack(push, 0x1)
class alignas(0x10) UAdvancedCharacterMovement : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_B00[0x8];                                      // 0x0B00(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TWeakObjectPtr<class AAdvancedCharacter>> DealtFallingDamageTo;                              // 0x0B08(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         LastFallingCheckVelocityZ;                         // 0x0B58(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5C[0x4];                                      // 0x0B5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrowdManager*                          CrowdManager;                                      // 0x0B60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMordhauRotationInterpMode;                     // 0x0B68(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B69[0x3];                                      // 0x0B69(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BounceOffBumpForce;                                // 0x0B6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MordhauRotationSmoothStartTime;                    // 0x0B70(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MordhauRotationSmoothEndTime;                      // 0x0B74(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B78[0x8];                                      // 0x0B78(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  MordhauRotationSmoothFrom;                         // 0x0B80(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StillTimeWhileRagdollFalling;                      // 0x0B90(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerchRadiusThresholdRagdollFalling;                // 0x0B94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVelocityForFallDamage;                          // 0x0B98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallDamageOffset;                                  // 0x0B9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallDamageFactor;                                  // 0x0BA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollMinVelocityForFallDamage;                   // 0x0BA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollFallDamageOffset;                           // 0x0BA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollFallDamageFactor;                           // 0x0BAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseBackwardsTurning;                          // 0x0BB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePendingRotationToOrientMovement;               // 0x0BB1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB2[0x2];                                      // 0x0BB2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PreviousVelocity;                                  // 0x0BB4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PendingTurnValue;                                  // 0x0BC0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreMovementInput;                              // 0x0BC4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC5[0xB];                                      // 0x0BC5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ChildrenSkipperCachedArray;                        // 0x0BD0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                OffsetMeshTranslation;                             // 0x0BE0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetExtrapolation;                               // 0x0BEC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetExtrapolationTarget;                         // 0x0BF8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetCorrectionLeftover;                          // 0x0C04(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetNetSmoothLeftover;                           // 0x0C10(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetNetSmoothPending;                            // 0x0C1C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MovementComponentMeshOffset;                       // 0x0C28(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AuthNetSmoothTime;                                 // 0x0C34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AuthNetMaxSmoothDist;                              // 0x0C38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAuthNetSmoothing;                          // 0x0C3C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C3D[0x3];                                      // 0x0C3D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkipPredictionForAnimTickSkipOrGreater;            // 0x0C40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C44[0x4];                                      // 0x0C44(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdvancedCharacterMovement">();
	}
	static class UAdvancedCharacterMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdvancedCharacterMovement>();
	}
};
#pragma pack(pop)
static_assert(alignof(UAdvancedCharacterMovement) == 0x000010, "Wrong alignment on UAdvancedCharacterMovement");
static_assert(sizeof(UAdvancedCharacterMovement) == 0x000C50, "Wrong size on UAdvancedCharacterMovement");
static_assert(offsetof(UAdvancedCharacterMovement, DealtFallingDamageTo) == 0x000B08, "Member 'UAdvancedCharacterMovement::DealtFallingDamageTo' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, LastFallingCheckVelocityZ) == 0x000B58, "Member 'UAdvancedCharacterMovement::LastFallingCheckVelocityZ' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, CrowdManager) == 0x000B60, "Member 'UAdvancedCharacterMovement::CrowdManager' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, bUseMordhauRotationInterpMode) == 0x000B68, "Member 'UAdvancedCharacterMovement::bUseMordhauRotationInterpMode' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, BounceOffBumpForce) == 0x000B6C, "Member 'UAdvancedCharacterMovement::BounceOffBumpForce' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, MordhauRotationSmoothStartTime) == 0x000B70, "Member 'UAdvancedCharacterMovement::MordhauRotationSmoothStartTime' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, MordhauRotationSmoothEndTime) == 0x000B74, "Member 'UAdvancedCharacterMovement::MordhauRotationSmoothEndTime' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, MordhauRotationSmoothFrom) == 0x000B80, "Member 'UAdvancedCharacterMovement::MordhauRotationSmoothFrom' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, StillTimeWhileRagdollFalling) == 0x000B90, "Member 'UAdvancedCharacterMovement::StillTimeWhileRagdollFalling' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, PerchRadiusThresholdRagdollFalling) == 0x000B94, "Member 'UAdvancedCharacterMovement::PerchRadiusThresholdRagdollFalling' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, MinVelocityForFallDamage) == 0x000B98, "Member 'UAdvancedCharacterMovement::MinVelocityForFallDamage' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, FallDamageOffset) == 0x000B9C, "Member 'UAdvancedCharacterMovement::FallDamageOffset' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, FallDamageFactor) == 0x000BA0, "Member 'UAdvancedCharacterMovement::FallDamageFactor' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, RagdollMinVelocityForFallDamage) == 0x000BA4, "Member 'UAdvancedCharacterMovement::RagdollMinVelocityForFallDamage' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, RagdollFallDamageOffset) == 0x000BA8, "Member 'UAdvancedCharacterMovement::RagdollFallDamageOffset' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, RagdollFallDamageFactor) == 0x000BAC, "Member 'UAdvancedCharacterMovement::RagdollFallDamageFactor' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, bReverseBackwardsTurning) == 0x000BB0, "Member 'UAdvancedCharacterMovement::bReverseBackwardsTurning' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, bUsePendingRotationToOrientMovement) == 0x000BB1, "Member 'UAdvancedCharacterMovement::bUsePendingRotationToOrientMovement' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, PreviousVelocity) == 0x000BB4, "Member 'UAdvancedCharacterMovement::PreviousVelocity' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, PendingTurnValue) == 0x000BC0, "Member 'UAdvancedCharacterMovement::PendingTurnValue' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, bIgnoreMovementInput) == 0x000BC4, "Member 'UAdvancedCharacterMovement::bIgnoreMovementInput' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, ChildrenSkipperCachedArray) == 0x000BD0, "Member 'UAdvancedCharacterMovement::ChildrenSkipperCachedArray' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, OffsetMeshTranslation) == 0x000BE0, "Member 'UAdvancedCharacterMovement::OffsetMeshTranslation' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, OffsetExtrapolation) == 0x000BEC, "Member 'UAdvancedCharacterMovement::OffsetExtrapolation' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, OffsetExtrapolationTarget) == 0x000BF8, "Member 'UAdvancedCharacterMovement::OffsetExtrapolationTarget' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, OffsetCorrectionLeftover) == 0x000C04, "Member 'UAdvancedCharacterMovement::OffsetCorrectionLeftover' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, OffsetNetSmoothLeftover) == 0x000C10, "Member 'UAdvancedCharacterMovement::OffsetNetSmoothLeftover' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, OffsetNetSmoothPending) == 0x000C1C, "Member 'UAdvancedCharacterMovement::OffsetNetSmoothPending' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, MovementComponentMeshOffset) == 0x000C28, "Member 'UAdvancedCharacterMovement::MovementComponentMeshOffset' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, AuthNetSmoothTime) == 0x000C34, "Member 'UAdvancedCharacterMovement::AuthNetSmoothTime' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, AuthNetMaxSmoothDist) == 0x000C38, "Member 'UAdvancedCharacterMovement::AuthNetMaxSmoothDist' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, bDisableAuthNetSmoothing) == 0x000C3C, "Member 'UAdvancedCharacterMovement::bDisableAuthNetSmoothing' has a wrong offset!");
static_assert(offsetof(UAdvancedCharacterMovement, SkipPredictionForAnimTickSkipOrGreater) == 0x000C40, "Member 'UAdvancedCharacterMovement::SkipPredictionForAnimTickSkipOrGreater' has a wrong offset!");

// Class Mordhau.MordhauCharacterTypes
// 0x0000 (0x0028 - 0x0028)
class UMordhauCharacterTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauCharacterTypes">();
	}
	static class UMordhauCharacterTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauCharacterTypes>();
	}
};
static_assert(alignof(UMordhauCharacterTypes) == 0x000008, "Wrong alignment on UMordhauCharacterTypes");
static_assert(sizeof(UMordhauCharacterTypes) == 0x000028, "Wrong size on UMordhauCharacterTypes");

// Class Mordhau.AdvProjectileMovementComponent
// 0x0010 (0x01E0 - 0x01D0)
class UAdvProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	float                                         DragDeceleration;                                  // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0xC];                                      // 0x01D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdvProjectileMovementComponent">();
	}
	static class UAdvProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdvProjectileMovementComponent>();
	}
};
static_assert(alignof(UAdvProjectileMovementComponent) == 0x000010, "Wrong alignment on UAdvProjectileMovementComponent");
static_assert(sizeof(UAdvProjectileMovementComponent) == 0x0001E0, "Wrong size on UAdvProjectileMovementComponent");
static_assert(offsetof(UAdvProjectileMovementComponent, DragDeceleration) == 0x0001D0, "Member 'UAdvProjectileMovementComponent::DragDeceleration' has a wrong offset!");

// Class Mordhau.Archetype
// 0x0008 (0x0030 - 0x0028)
class UArchetype : public UObject
{
public:
	int32                                         CharacterPoints;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Archetype">();
	}
	static class UArchetype* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchetype>();
	}
};
static_assert(alignof(UArchetype) == 0x000008, "Wrong alignment on UArchetype");
static_assert(sizeof(UArchetype) == 0x000030, "Wrong size on UArchetype");
static_assert(offsetof(UArchetype, CharacterPoints) == 0x000028, "Member 'UArchetype::CharacterPoints' has a wrong offset!");

// Class Mordhau.MordhauActor
// 0x01C0 (0x03E0 - 0x0220)
class AMordhauActor : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AMordhauPlayerController> InstanceOwner;                                     // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedThud;                                    // 0x0230(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageableComponent*                   DamageableComponent;                               // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ThudSound;                                         // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ThudPitchMultiplierRange;                          // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ThudVolumeMultiplierRange;                         // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldReplicateThud;                              // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThudMinVelocity;                                   // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThudMaxVelocity;                                   // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayBetweenThuds;                              // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoThudUntilTime;                                   // 0x0268(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPreventClimbing;                                  // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TeamkillsCountForAutoKick;                         // 0x0271(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_272[0x2];                                      // 0x0272(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStat                                  KillsStat;                                         // 0x0274(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoresBleedOut;                                  // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceLongDeathYell;                               // 0x0281(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReceiveCosmeticHits;                              // 0x0282(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_283[0x1];                                      // 0x0283(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RagdollForceMultiplier;                            // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceRagdollOnDeath;                              // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastDamageLocation;                                // 0x028C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastDamageNormal;                                  // 0x0298(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReplayPriorityFactor;                              // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationSmoothTime;                           // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothNetworkMovement;                            // 0x02AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD[0x3];                                      // 0x02AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SmoothedLocationOffset;                            // 0x02B0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  SmoothedRotationOffset;                            // 0x02C0(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNetworkMovementSmoothingCompleted;                // 0x02D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMordhauWidgetComponent>    InteractionWidgetComponentClass;                   // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMordhauUserWidget>         InteractionWidgetClass;                            // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   HeldInteractionText;                               // 0x02E8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   InteractionText;                                   // 0x0300(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bNoInteractionWidgetWhenAttachedToChar;            // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InteractionWidgetRelativeTransform;                // 0x0320(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAutoDetermineWidgetTransform;                     // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMordhauWidgetComponent*                InteractionWidgetComponent;                        // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPerformCustomDepthHighlight;                      // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHighlighted;                                    // 0x0361(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_362[0x2];                                      // 0x0362(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxInteractWithDistance;                           // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInteractable;                                   // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPassivelyInteractable;                          // 0x0369(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36A[0x2];                                      // 0x036A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxInteractionHoldTime;                            // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCooperativeInteraction;                      // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_371[0x3];                                      // 0x0371(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CooperativeHoldProgress;                           // 0x0374(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CooperativeHoldCount;                              // 0x0378(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CooperativeProgressCurve;                          // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class AMordhauCharacter*>                CurrentlyHolding;                                  // 0x0388(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         LastLocallyRequestedPassiveInteractionTime;        // 0x03D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCooperativeHoldProgressUpdated(float Progress, float OldValue);
	void OnHoldCountChanged();
	void OnLocalPlayerUsedToKillOther(class AAdvancedCharacter* Character, EMordhauDamageType Type, uint8 SubType, class FName bone, const struct FVector& Point, class AActor* Source);
	void OnPostDismemberedOther(class FName bone, class ASeparatedBodyPart* Part);
	void OnReceiveCosmeticHit(class AActor* Source, class AActor* Agent, EAttackMove Move, const struct FHitResult& Hit);
	void OnRep_CooperativeHoldCount();
	void OnRep_CooperativeHoldProgress();
	void OnRep_ReplicatedThud();
	void OnThud();
	void OnUsedToKillOther(class AAdvancedCharacter* Character, EMordhauDamageType Type, uint8 SubType, class FName bone, const struct FVector& Point, class AActor* Source);
	void PostInteractionWidgetCreated();
	void ResetCooperativeProgress();
	void UpdateThudVelocity(float NewThudVelocity);

	float GetCooperativeHoldProgress() const;
	bool IsAnyInstanceOwner(const TArray<class AMordhauPlayerController*>& ControllerArray) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauActor">();
	}
	static class AMordhauActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauActor>();
	}
};
static_assert(alignof(AMordhauActor) == 0x000010, "Wrong alignment on AMordhauActor");
static_assert(sizeof(AMordhauActor) == 0x0003E0, "Wrong size on AMordhauActor");
static_assert(offsetof(AMordhauActor, InstanceOwner) == 0x000228, "Member 'AMordhauActor::InstanceOwner' has a wrong offset!");
static_assert(offsetof(AMordhauActor, ReplicatedThud) == 0x000230, "Member 'AMordhauActor::ReplicatedThud' has a wrong offset!");
static_assert(offsetof(AMordhauActor, DamageableComponent) == 0x000238, "Member 'AMordhauActor::DamageableComponent' has a wrong offset!");
static_assert(offsetof(AMordhauActor, ThudSound) == 0x000240, "Member 'AMordhauActor::ThudSound' has a wrong offset!");
static_assert(offsetof(AMordhauActor, ThudPitchMultiplierRange) == 0x000248, "Member 'AMordhauActor::ThudPitchMultiplierRange' has a wrong offset!");
static_assert(offsetof(AMordhauActor, ThudVolumeMultiplierRange) == 0x000250, "Member 'AMordhauActor::ThudVolumeMultiplierRange' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bShouldReplicateThud) == 0x000258, "Member 'AMordhauActor::bShouldReplicateThud' has a wrong offset!");
static_assert(offsetof(AMordhauActor, ThudMinVelocity) == 0x00025C, "Member 'AMordhauActor::ThudMinVelocity' has a wrong offset!");
static_assert(offsetof(AMordhauActor, ThudMaxVelocity) == 0x000260, "Member 'AMordhauActor::ThudMaxVelocity' has a wrong offset!");
static_assert(offsetof(AMordhauActor, MinDelayBetweenThuds) == 0x000264, "Member 'AMordhauActor::MinDelayBetweenThuds' has a wrong offset!");
static_assert(offsetof(AMordhauActor, NoThudUntilTime) == 0x000268, "Member 'AMordhauActor::NoThudUntilTime' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bPreventClimbing) == 0x000270, "Member 'AMordhauActor::bPreventClimbing' has a wrong offset!");
static_assert(offsetof(AMordhauActor, TeamkillsCountForAutoKick) == 0x000271, "Member 'AMordhauActor::TeamkillsCountForAutoKick' has a wrong offset!");
static_assert(offsetof(AMordhauActor, KillsStat) == 0x000274, "Member 'AMordhauActor::KillsStat' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bIgnoresBleedOut) == 0x000280, "Member 'AMordhauActor::bIgnoresBleedOut' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bForceLongDeathYell) == 0x000281, "Member 'AMordhauActor::bForceLongDeathYell' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bReceiveCosmeticHits) == 0x000282, "Member 'AMordhauActor::bReceiveCosmeticHits' has a wrong offset!");
static_assert(offsetof(AMordhauActor, RagdollForceMultiplier) == 0x000284, "Member 'AMordhauActor::RagdollForceMultiplier' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bForceRagdollOnDeath) == 0x000288, "Member 'AMordhauActor::bForceRagdollOnDeath' has a wrong offset!");
static_assert(offsetof(AMordhauActor, LastDamageLocation) == 0x00028C, "Member 'AMordhauActor::LastDamageLocation' has a wrong offset!");
static_assert(offsetof(AMordhauActor, LastDamageNormal) == 0x000298, "Member 'AMordhauActor::LastDamageNormal' has a wrong offset!");
static_assert(offsetof(AMordhauActor, ReplayPriorityFactor) == 0x0002A4, "Member 'AMordhauActor::ReplayPriorityFactor' has a wrong offset!");
static_assert(offsetof(AMordhauActor, InterpolationSmoothTime) == 0x0002A8, "Member 'AMordhauActor::InterpolationSmoothTime' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bSmoothNetworkMovement) == 0x0002AC, "Member 'AMordhauActor::bSmoothNetworkMovement' has a wrong offset!");
static_assert(offsetof(AMordhauActor, SmoothedLocationOffset) == 0x0002B0, "Member 'AMordhauActor::SmoothedLocationOffset' has a wrong offset!");
static_assert(offsetof(AMordhauActor, SmoothedRotationOffset) == 0x0002C0, "Member 'AMordhauActor::SmoothedRotationOffset' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bNetworkMovementSmoothingCompleted) == 0x0002D0, "Member 'AMordhauActor::bNetworkMovementSmoothingCompleted' has a wrong offset!");
static_assert(offsetof(AMordhauActor, InteractionWidgetComponentClass) == 0x0002D8, "Member 'AMordhauActor::InteractionWidgetComponentClass' has a wrong offset!");
static_assert(offsetof(AMordhauActor, InteractionWidgetClass) == 0x0002E0, "Member 'AMordhauActor::InteractionWidgetClass' has a wrong offset!");
static_assert(offsetof(AMordhauActor, HeldInteractionText) == 0x0002E8, "Member 'AMordhauActor::HeldInteractionText' has a wrong offset!");
static_assert(offsetof(AMordhauActor, InteractionText) == 0x000300, "Member 'AMordhauActor::InteractionText' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bNoInteractionWidgetWhenAttachedToChar) == 0x000318, "Member 'AMordhauActor::bNoInteractionWidgetWhenAttachedToChar' has a wrong offset!");
static_assert(offsetof(AMordhauActor, InteractionWidgetRelativeTransform) == 0x000320, "Member 'AMordhauActor::InteractionWidgetRelativeTransform' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bAutoDetermineWidgetTransform) == 0x000350, "Member 'AMordhauActor::bAutoDetermineWidgetTransform' has a wrong offset!");
static_assert(offsetof(AMordhauActor, InteractionWidgetComponent) == 0x000358, "Member 'AMordhauActor::InteractionWidgetComponent' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bPerformCustomDepthHighlight) == 0x000360, "Member 'AMordhauActor::bPerformCustomDepthHighlight' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bIsHighlighted) == 0x000361, "Member 'AMordhauActor::bIsHighlighted' has a wrong offset!");
static_assert(offsetof(AMordhauActor, MaxInteractWithDistance) == 0x000364, "Member 'AMordhauActor::MaxInteractWithDistance' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bIsInteractable) == 0x000368, "Member 'AMordhauActor::bIsInteractable' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bIsPassivelyInteractable) == 0x000369, "Member 'AMordhauActor::bIsPassivelyInteractable' has a wrong offset!");
static_assert(offsetof(AMordhauActor, MaxInteractionHoldTime) == 0x00036C, "Member 'AMordhauActor::MaxInteractionHoldTime' has a wrong offset!");
static_assert(offsetof(AMordhauActor, bAllowCooperativeInteraction) == 0x000370, "Member 'AMordhauActor::bAllowCooperativeInteraction' has a wrong offset!");
static_assert(offsetof(AMordhauActor, CooperativeHoldProgress) == 0x000374, "Member 'AMordhauActor::CooperativeHoldProgress' has a wrong offset!");
static_assert(offsetof(AMordhauActor, CooperativeHoldCount) == 0x000378, "Member 'AMordhauActor::CooperativeHoldCount' has a wrong offset!");
static_assert(offsetof(AMordhauActor, CooperativeProgressCurve) == 0x000380, "Member 'AMordhauActor::CooperativeProgressCurve' has a wrong offset!");
static_assert(offsetof(AMordhauActor, CurrentlyHolding) == 0x000388, "Member 'AMordhauActor::CurrentlyHolding' has a wrong offset!");
static_assert(offsetof(AMordhauActor, LastLocallyRequestedPassiveInteractionTime) == 0x0003D8, "Member 'AMordhauActor::LastLocallyRequestedPassiveInteractionTime' has a wrong offset!");

// Class Mordhau.MordhauEquipment
// 0x0950 (0x0D30 - 0x03E0)
#pragma pack(push, 0x1)
class alignas(0x10) AMordhauEquipment : public AMordhauActor
{
public:
	uint8                                         Ammo;                                              // 0x03E0(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PreviousAmmo;                                      // 0x03E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsStateDirty;                                     // 0x03E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsTick;                                        // 0x03E9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEquipmentToAlwaysTick;                       // 0x03EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceRefPoseOnMesh;                               // 0x03EB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSwitchOnLastRangedShot;                       // 0x03EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3ED[0x3];                                      // 0x03ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           EquipmentTraitNames;                               // 0x03F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, class FText>              ActionToDescriptionMap;                            // 0x0400(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, class FText>              SecondActionToDescriptionMap;                      // 0x0450(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTransform                             DefaultMeshRelativeTransform;                      // 0x04A0(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         HideInGameOverride;                                // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D4[0xC];                                      // 0x04D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EquippedOffset;                                    // 0x04E0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseEquippedOffset;                                // 0x0510(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanThrowPommel;                                   // 0x0511(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondUseEquippedOffset;                          // 0x0512(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHeldInHand;                                     // 0x0513(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsParentInFirstPerson;                            // 0x0514(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_515[0x3];                                      // 0x0515(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachedToSocket;                                  // 0x0518(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsToRebuildParts;                              // 0x0520(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LastOwnerTeam;                                     // 0x0521(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceTeamColor1;                                  // 0x0522(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceTeamColor2;                                  // 0x0523(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasColor1;                                        // 0x0524(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasColor2;                                        // 0x0525(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasColor3;                                        // 0x0526(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_527[0x1];                                      // 0x0527(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMordhauEquipmentPart*>          PartInstances;                                     // 0x0528(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauCharacter>       ParentCharacter;                                   // 0x0538(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauCharacter>       YoinkTrackingParentCharacter;                      // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasLastParentCharacterLocalPlayer;                // 0x0548(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeldInteractIsSwap;                               // 0x0549(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipmentType                                EquipmentUIType;                                   // 0x054A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipmentCategory                            EquipmentUICategory;                               // 0x054B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54C[0x4];                                      // 0x054C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EquipmentName;                                     // 0x0550(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bDisablesDodge;                                    // 0x0568(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRightHanded;                                    // 0x0569(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondIsRightHanded;                              // 0x056A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTwoHanded;                                      // 0x056B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondIsTwoHanded;                                // 0x056C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56D[0x3];                                      // 0x056D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EquipTimeModifier;                                 // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRangedActionAllowsRegen;                          // 0x0574(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTakesHuntsmanDamage;                              // 0x0575(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_576[0x2];                                      // 0x0576(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangedDrawFOVOffset;                               // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           RangedDrawSway;                                    // 0x0580(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRangedSwayCameraBased;                          // 0x0588(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_589[0x3];                                      // 0x0589(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RangedAirborneSway;                                // 0x058C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedAirborneSwayBlendInSpeed;                    // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedAirborneSwayBlendOutSpeed;                   // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RangedDrawSwayLoopSegment;                         // 0x05A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedDrawTremblingStartAfter;                     // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedDrawTremblingMaxAfter;                       // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedDrawTremblingMagnitude;                      // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedDrawTremblingFrequency;                      // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 AuxiliarySkeletalMeshComponent;                    // 0x05C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAuxiliaryMeshMode                            AuxiliaryMeshMode;                                 // 0x05C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C9[0x7];                                      // 0x05C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AuxiliaryMeshOffset;                               // 0x05D0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             DefaultAuxiliaryMeshRelativeTransform;             // 0x0600(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          CombinedSkeletalMesh;                              // 0x0630(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFollowingProjectile;                            // 0x0638(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              EquipmentPhysicalSurface;                          // 0x0639(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63A[0x6];                                      // 0x063A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AMordhauProjectile*                     CurrentProjectile;                                 // 0x0640(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AMordhauProjectile>         ProjectileClass;                                   // 0x0648(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AMordhauEquipment>>  RestockAmmoForEquipment;                           // 0x0650(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         MaxAmountPerLoadout;                               // 0x0660(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanRestockFromEquipmentDefaults;                  // 0x0664(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_665[0x3];                                      // 0x0665(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAmmoBoxRestockAmount;                           // 0x0668(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaxAmmoBoxRestockAmountCategory;                   // 0x066C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_674[0x4];                                      // 0x0674(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APhysicsProxy*                          PhysicsProxy;                                      // 0x0678(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          PhysicsAsset;                                      // 0x0680(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotDisarmOnMeleeWeaponHit;                      // 0x0688(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCannotChaseOthers;                                // 0x0689(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeChasedFromFront;                             // 0x068A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanRagdoll;                                       // 0x068B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesPhysicsProxy;                                 // 0x068C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyPeasants;                                     // 0x068D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAllowedForPeasants;                             // 0x068E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68F[0x1];                                      // 0x068F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ArmoryTransformOffset;                             // 0x0690(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CharacterPointCost;                                // 0x06C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullDistanceHeld;                                  // 0x06C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullDistanceNotHeld;                               // 0x06C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullDistanceAuxiliaryHeld;                         // 0x06CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullDistanceAuxiliaryNotHeld;                      // 0x06D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInstantMeshUpdate;                           // 0x06D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceMipStreaming;                                // 0x06D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceMaxLOD;                                      // 0x06D6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPartsUseAuxiliaryMesh;                            // 0x06D7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UMeshComponent>>  MeshComponents;                                    // 0x06D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UQuiver>                    Quiver;                                            // 0x06E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxAmmo;                                           // 0x06F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxAmmoWithoutQuiver;                              // 0x06F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LastReplicatedAmmo;                                // 0x06F2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyIfNoAmmo;                                  // 0x06F3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementRestriction                          MovementRestriction;                               // 0x06F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventsClimbing;                                 // 0x06F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F6[0x2];                                      // 0x06F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SubSprintSpeedBonusEquipped;                       // 0x06F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondSubSprintSpeedBonusEquipped;                 // 0x06FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedOverrideEquipped;                             // 0x0700(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackpedalSpeedFactorEquipped;                      // 0x0704(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedBonusPercentageEquipped;                      // 0x0708(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationBonusPercentageEquipped;               // 0x070C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedBonusPercentageHolstered;                     // 0x0710(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationBonusPercentageHolstered;              // 0x0714(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEquipmentCustomization                AssignedCustomization;                             // 0x0718(0x0030)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedColors[0x3];                             // 0x0748(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedPartsId[0x3];                            // 0x074B(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedSkin;                                    // 0x074E(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedEmblem;                                  // 0x074F(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedEmblemColors[0x2];                       // 0x0750(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedPattern;                                 // 0x0752(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasReplicatedColors;                              // 0x0753(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasReplicatedPartsId;                             // 0x0754(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasReplicatedSkin;                                // 0x0755(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasReplicatedEmblem;                              // 0x0756(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasReplicatedEmblemColors;                        // 0x0757(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasReplicatedPattern;                             // 0x0758(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_759[0x7];                                      // 0x0759(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEquipmentSkinEntry>            Skins;                                             // 0x0760(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Colors[0x3];                                       // 0x0770(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PartsId[0x3];                                      // 0x0773(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Skin;                                              // 0x0776(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pattern;                                           // 0x0777(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Emblem;                                            // 0x0778(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EmblemColors[0x2];                                 // 0x0779(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAssignCustomizationOnBeginPlay;               // 0x077B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77C[0x4];                                      // 0x077C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEquipmentCustomization                AutoAssignCustomization;                           // 0x0780(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         AutoAssignCustomizationEmblem;                     // 0x07B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AutoAssignCustomizationEmblemColor1;               // 0x07B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AutoAssignCustomizationEmblemColor2;               // 0x07B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmotingAllowed;                                 // 0x07B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B4[0x4];                                      // 0x07B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEmoteEntry>                    EquipmentEmotes;                                   // 0x07B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      KickAnimation;                                     // 0x07C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpKickAnimation;                                 // 0x07D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      KickRiposteAnimation;                              // 0x07D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpKickRiposteAnimation;                          // 0x07E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      KickComboAnimation;                                // 0x07E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      JumpKickComboAnimation;                            // 0x07F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           KickBounce;                                        // 0x07F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        UpperBlendSpace1P;                                 // 0x0800(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UpperAdditive1P;                                   // 0x0808(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        UpperBlendSpaceUnloaded1P;                         // 0x0810(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UpperAdditiveUnloaded1P;                           // 0x0818(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        UpperBlendSpace;                                   // 0x0820(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UpperAdditive;                                     // 0x0828(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        UpperBlendSpaceUnloaded;                           // 0x0830(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UpperAdditiveUnloaded;                             // 0x0838(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LowerAnimation;                                    // 0x0840(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        ShieldUpperBlendSpace1P;                           // 0x0848(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ShieldUpperAdditive1P;                             // 0x0850(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        ShieldUpperBlendSpace;                             // 0x0858(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ShieldUpperAdditive;                               // 0x0860(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ShieldLowerAnimation;                              // 0x0868(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        ShieldHorseUpperBlendSpace1P;                      // 0x0870(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ShieldHorseUpperAdditive1P;                        // 0x0878(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        ShieldHorseUpperBlendSpace;                        // 0x0880(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ShieldHorseUpperAdditive;                          // 0x0888(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        HorseUpperBlendSpace1P;                            // 0x0890(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUpperAdditive1P;                              // 0x0898(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        HorseUpperBlendSpaceUnloaded1P;                    // 0x08A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUpperAdditiveUnloaded1P;                      // 0x08A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        HorseUpperBlendSpace;                              // 0x08B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUpperAdditive;                                // 0x08B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        HorseUpperBlendSpaceUnloaded;                      // 0x08C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUpperAdditiveUnloaded;                        // 0x08C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUpperRearing;                                 // 0x08D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUpperRearing1P;                               // 0x08D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUpperJump;                                    // 0x08E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUpperJump1P;                                  // 0x08E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ModeSwitchAnimation;                               // 0x08F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DropAnimation;                                     // 0x08F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           InteractWithAnimation;                             // 0x0900(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           InteractWith1PAnimation;                           // 0x0908(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpUnloadedAnimation;                             // 0x0910(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpAnimation;                                     // 0x0918(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpAnimationShield;                               // 0x0920(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpUnloadedAnimation1P;                           // 0x0928(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpAnimation1P;                                   // 0x0930(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpAnimationShield1P;                             // 0x0938(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FallingUnloadedAnimation;                          // 0x0940(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FallingAnimation;                                  // 0x0948(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FallingAnimationShield;                            // 0x0950(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FallingUnloadedAnimation1P;                        // 0x0958(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FallingAnimation1P;                                // 0x0960(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FallingAnimationShield1P;                          // 0x0968(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LandUnloadedAnimation;                             // 0x0970(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LandAnimation;                                     // 0x0978(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LandAnimationShield;                               // 0x0980(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LandUnloadedAnimation1P;                           // 0x0988(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LandAnimation1P;                                   // 0x0990(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LandAnimationShield1P;                             // 0x0998(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SecondDropAnimation;                               // 0x09A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SecondInteractWithAnimation;                       // 0x09A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SecondInteractWith1PAnimation;                     // 0x09B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondJumpUnloadedAnimation;                       // 0x09B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondJumpAnimation;                               // 0x09C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondJumpUnloadedAnimation1P;                     // 0x09C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondJumpAnimation1P;                             // 0x09D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondFallingUnloadedAnimation;                    // 0x09D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondFallingAnimation;                            // 0x09E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondFallingUnloadedAnimation1P;                  // 0x09E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondFallingAnimation1P;                          // 0x09F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondLandUnloadedAnimation;                       // 0x09F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondLandAnimation;                               // 0x0A00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondLandUnloadedAnimation1P;                     // 0x0A08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondLandAnimation1P;                             // 0x0A10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   CharacterPreviewPoses;                             // 0x0A18(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RangedDrawAnimation;                               // 0x0A28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RangedDrawAnimation1P;                             // 0x0A30(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        RangedDrawnAdditive;                               // 0x0A38(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RangedDrawEquipmentAnimation;                      // 0x0A40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RangedDrawEquipmentAnimation1P;                    // 0x0A48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RangedReleaseAnimation;                            // 0x0A50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RangedReleaseAnimation1P;                          // 0x0A58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RangedReleaseEquipmentAnimation;                   // 0x0A60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RangedReleaseEquipmentAnimation1P;                 // 0x0A68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReloadAnimation;                                   // 0x0A70(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ReloadSound;                                       // 0x0A78(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReloadAnimation1P;                                 // 0x0A80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ReloadSound1P;                                     // 0x0A88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReloadEquipmentAnimation;                          // 0x0A90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReloadEquipmentAnimation1P;                        // 0x0A98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           QuickthrowAnimation1P;                             // 0x0AA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           QuickthrowAnimation;                               // 0x0AA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSpineArmsCompensation1P;                   // 0x0AB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableHandSpringAnimation;                       // 0x0AB1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB2[0x2];                                      // 0x0AB2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RightHandIKPositionOffset;                         // 0x0AB4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightShoulderOffset1P;                             // 0x0AC0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftShoulderOffset1P;                              // 0x0ACC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftShoulderIdleOffset1P;                          // 0x0AD8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesOffhandIK;                                    // 0x0AE4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertOffhandUp;                                  // 0x0AE5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondInvertOffhandUp;                            // 0x0AE6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE7[0x1];                                      // 0x0AE7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        SecondUpperBlendSpace1P;                           // 0x0AE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondUpperAdditive1P;                             // 0x0AF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        SecondUpperBlendSpaceUnloaded1P;                   // 0x0AF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondUpperAdditiveUnloaded1P;                     // 0x0B00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        SecondUpperBlendSpace;                             // 0x0B08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondUpperAdditive;                               // 0x0B10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        SecondUpperBlendSpaceUnloaded;                     // 0x0B18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondUpperAdditiveUnloaded;                       // 0x0B20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SecondLowerAnimation;                              // 0x0B28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SecondModeSwitchAnimation;                         // 0x0B30(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondUsesOffhandIK;                              // 0x0B38(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B39[0x3];                                      // 0x0B39(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffhandIKUpOffset;                                 // 0x0B3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffhandIKUpOffset1P;                               // 0x0B40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondOffhandIKUpOffset;                           // 0x0B44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondOffhandIKUpOffset1P;                         // 0x0B48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandEquipOffset;                              // 0x0B4C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B58[0x8];                                      // 0x0B58(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RightWeaponBoneCosmeticTransform;                  // 0x0B60(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             RightWeaponBoneCosmeticTransform1P;                // 0x0B90(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             SecondRightWeaponBoneCosmeticTransform;            // 0x0BC0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             SecondRightWeaponBoneCosmeticTransform1P;          // 0x0BF0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0C20(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SecondRotationOffset;                              // 0x0C2C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                GripLocationLocal;                                 // 0x0C38(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondGripLocationLocal;                           // 0x0C44(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C50[0x10];                                     // 0x0C50(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEquipmentHolsterInfo>          HolsterInfo;                                       // 0x0C60(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCanHolster;                                       // 0x0C70(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEquipOnHorse;                                  // 0x0C71(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEquipOnLadder;                                 // 0x0C72(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondCanEquipOnHorse;                            // 0x0C73(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondCanEquipOnLadder;                           // 0x0C74(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C75[0x3];                                      // 0x0C75(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              AmmoRefillSound;                                   // 0x0C78(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              EquipSound;                                        // 0x0C80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              HolsterSound;                                      // 0x0C88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DrawSound;                                         // 0x0C90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawSoundPlayAtNormalizedTime;                     // 0x0C98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawSoundPlayAtNormalizedTime1P;                   // 0x0C9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              RangedCancelSound;                                 // 0x0CA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              FireSound;                                         // 0x0CA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysDestroyOnDeath;                             // 0x0CB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeferDestroyUntilRagdoll;                         // 0x0CB1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB2[0x2];                                      // 0x0CB2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RagdollStayTime;                                   // 0x0CB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDrop;                                        // 0x0CB8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAttack;                                        // 0x0CB9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAttackOnFoot;                                  // 0x0CBA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAttackOnHorseback;                             // 0x0CBB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowFire;                                        // 0x0CBC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireThrowsEquipment;                              // 0x0CBD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CBE[0x2];                                      // 0x0CBE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExtraSwitchTime;                                   // 0x0CC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRangedReleasePlaysAttackYell;                     // 0x0CC4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesRangedCamera;                                 // 0x0CC5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowHoldDraw;                                    // 0x0CC6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCancelDraw;                                  // 0x0CC7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHoldDrawTime;                                   // 0x0CC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementRestriction                          ReloadMovementRestriction;                         // 0x0CCC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementRestriction                          RangedDrawMovementRestriction;                     // 0x0CCD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CCE[0x2];                                      // 0x0CCE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangedDrawSpeedFactor;                             // 0x0CD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedDrawSpeedFactorWithRangerPerk;               // 0x0CD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RangedDrawTurnCaps;                                // 0x0CD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementRestriction                          RangedReleaseMovementRestriction;                  // 0x0CE0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotFireAfterMaxHoldDrawTime;                    // 0x0CE1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuickthrowOnly;                                   // 0x0CE2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE3[0x1];                                      // 0x0CE3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceAppliedOnDrop;                                // 0x0CE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCleanup;                                     // 0x0CE8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE9[0x3];                                      // 0x0CE9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RangedDrawTime;                                    // 0x0CEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedCancelTime;                                  // 0x0CF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedReleaseTime;                                 // 0x0CF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        RangedReleaseCameraShake;                          // 0x0CF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedReloadTime;                                  // 0x0D00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RangedReloadTurnCaps;                              // 0x0D04(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedReloadGrabAmmoNormTime;                      // 0x0D0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedReloadFinishReloadNormTime;                  // 0x0D10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoReloadTime;                                    // 0x0D14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoReloadTimeSpent;                               // 0x0D18(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanReload;                                        // 0x0D1C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnloadOnUnequip;                                  // 0x0D1D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoadOnUnequip;                                    // 0x0D1E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoaded;                                         // 0x0D1F(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenWhenUnloaded;                               // 0x0D20(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D21[0x1];                                      // 0x0D21(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsUsingAlternateMode;                             // 0x0D22(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAlternateMode;                                 // 0x0D23(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRevertModeOnUnequip;                              // 0x0D24(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRevertModeOnDrop;                                 // 0x0D25(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D26[0x2];                                      // 0x0D26(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignCustomization(const struct FEquipmentCustomization& Customization, uint8 CustomizationEmblem, uint8 CustomizationEmblemColor1, uint8 CustomizationEmblemColor2);
	void AssignCustomizationToProjectile(class AMordhauProjectile* Projectile);
	struct FBoxSphereBounds ComputeAccurateBounds();
	void DestroyPhysicsProxy();
	void EquipmentCommand(int32 Command);
	struct FEquipmentHolsterInfo FindCurrentHolsterInfo();
	void FireProjectile(const struct FVector& Origin, const struct FRotator& Orientation, class AController* OwningController, float ExpectedDelay);
	class AMordhauProjectile* FireProjectile_Internal(const struct FVector& InOrigin, const struct FRotator& InOrientation, class AController* Controller, float ExpectedDelay, bool bIsLocal);
	struct FEquipmentCustomization GetRandomCustomization(bool bOnlyColors);
	bool GetWasSeen();
	bool GetWasSkinSeen(int32 SkinIdx);
	void LateTick(float DeltaSeconds);
	void LocalPlayerLateTick(float DeltaTime);
	void LocalPlayerTick(float DeltaTime);
	void MarkSeen();
	void MarkSkinSeen(int32 SkinIdx);
	void OnAmmoChanged();
	void OnDropped(class AMordhauCharacter* Character);
	void OnEquipped(class AMordhauCharacter* Character);
	void OnHolstered(class AMordhauCharacter* Character);
	void OnHolsteredOrDropped(class AMordhauCharacter* Character);
	void OnLoadedChanged();
	void OnPartsChanged();
	void OnPickedUp(class AMordhauCharacter* Character);
	void OnRep_Ammo();
	void OnRep_IsLoaded();
	void OnRep_IsUsingAlternateMode();
	void OnRep_ReplicatedColors();
	void OnRep_ReplicatedEmblem();
	void OnRep_ReplicatedEmblemColors();
	void OnRep_ReplicatedPartsId();
	void OnRep_ReplicatedPattern();
	void OnRep_ReplicatedSkin();
	bool OnRequestFire(class AMordhauCharacter* Character);
	bool OnRequestModeSwitch(class AMordhauCharacter* Character);
	void RebuildEquipment(bool bDoOnlyQuickJob);
	void RebuildIfAllReplicated();
	void RequestAttack(EAttackMove Move, float Angle);
	void ResetMeshRelativeTransform();
	bool RestockOtherEquipmentOnCharacter(class AMordhauCharacter* Character);
	void SetAmmo(uint8 NewAmmo);
	void SetColors(const TArray<uint8>& NewColors);
	void SetLoaded(bool bNewLoaded);
	void SetParts(const TArray<uint8>& NewPartsId, bool bRebuild);
	void SetPartsUseAuxiliaryMesh(bool bNewValue);
	bool ShouldShine();
	void SwitchMode();
	void UpdateCapsuleShadowStatus();
	void UpdateEquipmentState();
	void UpdateEquipmentVisualState();
	void UpdateInteractionCollision();
	void UpdateMaterial(class USkeletalMeshComponent* SkeletalMeshComp);

	bool BelongsToCharacter() const;
	bool CanPerformAttack(class AMordhauCharacter* Character, EAttackMove Move) const;
	uint8 GetAmmo() const;
	uint8 GetCurrentMaxAmmo() const;
	class AMordhauCharacter* GetParentCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauEquipment">();
	}
	static class AMordhauEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauEquipment>();
	}
};
#pragma pack(pop)
static_assert(alignof(AMordhauEquipment) == 0x000010, "Wrong alignment on AMordhauEquipment");
static_assert(sizeof(AMordhauEquipment) == 0x000D30, "Wrong size on AMordhauEquipment");
static_assert(offsetof(AMordhauEquipment, Ammo) == 0x0003E0, "Member 'AMordhauEquipment::Ammo' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, PreviousAmmo) == 0x0003E4, "Member 'AMordhauEquipment::PreviousAmmo' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bIsStateDirty) == 0x0003E8, "Member 'AMordhauEquipment::bIsStateDirty' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bWantsTick) == 0x0003E9, "Member 'AMordhauEquipment::bWantsTick' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bForceEquipmentToAlwaysTick) == 0x0003EA, "Member 'AMordhauEquipment::bForceEquipmentToAlwaysTick' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bForceRefPoseOnMesh) == 0x0003EB, "Member 'AMordhauEquipment::bForceRefPoseOnMesh' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bAutoSwitchOnLastRangedShot) == 0x0003EC, "Member 'AMordhauEquipment::bAutoSwitchOnLastRangedShot' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, EquipmentTraitNames) == 0x0003F0, "Member 'AMordhauEquipment::EquipmentTraitNames' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ActionToDescriptionMap) == 0x000400, "Member 'AMordhauEquipment::ActionToDescriptionMap' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondActionToDescriptionMap) == 0x000450, "Member 'AMordhauEquipment::SecondActionToDescriptionMap' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, DefaultMeshRelativeTransform) == 0x0004A0, "Member 'AMordhauEquipment::DefaultMeshRelativeTransform' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HideInGameOverride) == 0x0004D0, "Member 'AMordhauEquipment::HideInGameOverride' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, EquippedOffset) == 0x0004E0, "Member 'AMordhauEquipment::EquippedOffset' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bUseEquippedOffset) == 0x000510, "Member 'AMordhauEquipment::bUseEquippedOffset' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bCanThrowPommel) == 0x000511, "Member 'AMordhauEquipment::bCanThrowPommel' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bSecondUseEquippedOffset) == 0x000512, "Member 'AMordhauEquipment::bSecondUseEquippedOffset' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bIsHeldInHand) == 0x000513, "Member 'AMordhauEquipment::bIsHeldInHand' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bIsParentInFirstPerson) == 0x000514, "Member 'AMordhauEquipment::bIsParentInFirstPerson' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AttachedToSocket) == 0x000518, "Member 'AMordhauEquipment::AttachedToSocket' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bWantsToRebuildParts) == 0x000520, "Member 'AMordhauEquipment::bWantsToRebuildParts' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, LastOwnerTeam) == 0x000521, "Member 'AMordhauEquipment::LastOwnerTeam' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bForceTeamColor1) == 0x000522, "Member 'AMordhauEquipment::bForceTeamColor1' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bForceTeamColor2) == 0x000523, "Member 'AMordhauEquipment::bForceTeamColor2' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bHasColor1) == 0x000524, "Member 'AMordhauEquipment::bHasColor1' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bHasColor2) == 0x000525, "Member 'AMordhauEquipment::bHasColor2' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bHasColor3) == 0x000526, "Member 'AMordhauEquipment::bHasColor3' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, PartInstances) == 0x000528, "Member 'AMordhauEquipment::PartInstances' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ParentCharacter) == 0x000538, "Member 'AMordhauEquipment::ParentCharacter' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, YoinkTrackingParentCharacter) == 0x000540, "Member 'AMordhauEquipment::YoinkTrackingParentCharacter' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bWasLastParentCharacterLocalPlayer) == 0x000548, "Member 'AMordhauEquipment::bWasLastParentCharacterLocalPlayer' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bHeldInteractIsSwap) == 0x000549, "Member 'AMordhauEquipment::bHeldInteractIsSwap' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, EquipmentUIType) == 0x00054A, "Member 'AMordhauEquipment::EquipmentUIType' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, EquipmentUICategory) == 0x00054B, "Member 'AMordhauEquipment::EquipmentUICategory' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, EquipmentName) == 0x000550, "Member 'AMordhauEquipment::EquipmentName' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bDisablesDodge) == 0x000568, "Member 'AMordhauEquipment::bDisablesDodge' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bIsRightHanded) == 0x000569, "Member 'AMordhauEquipment::bIsRightHanded' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bSecondIsRightHanded) == 0x00056A, "Member 'AMordhauEquipment::bSecondIsRightHanded' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bIsTwoHanded) == 0x00056B, "Member 'AMordhauEquipment::bIsTwoHanded' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bSecondIsTwoHanded) == 0x00056C, "Member 'AMordhauEquipment::bSecondIsTwoHanded' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, EquipTimeModifier) == 0x000570, "Member 'AMordhauEquipment::EquipTimeModifier' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bRangedActionAllowsRegen) == 0x000574, "Member 'AMordhauEquipment::bRangedActionAllowsRegen' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bTakesHuntsmanDamage) == 0x000575, "Member 'AMordhauEquipment::bTakesHuntsmanDamage' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawFOVOffset) == 0x000578, "Member 'AMordhauEquipment::RangedDrawFOVOffset' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawSway) == 0x000580, "Member 'AMordhauEquipment::RangedDrawSway' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bIsRangedSwayCameraBased) == 0x000588, "Member 'AMordhauEquipment::bIsRangedSwayCameraBased' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedAirborneSway) == 0x00058C, "Member 'AMordhauEquipment::RangedAirborneSway' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedAirborneSwayBlendInSpeed) == 0x000598, "Member 'AMordhauEquipment::RangedAirborneSwayBlendInSpeed' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedAirborneSwayBlendOutSpeed) == 0x00059C, "Member 'AMordhauEquipment::RangedAirborneSwayBlendOutSpeed' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawSwayLoopSegment) == 0x0005A0, "Member 'AMordhauEquipment::RangedDrawSwayLoopSegment' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawTremblingStartAfter) == 0x0005A8, "Member 'AMordhauEquipment::RangedDrawTremblingStartAfter' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawTremblingMaxAfter) == 0x0005AC, "Member 'AMordhauEquipment::RangedDrawTremblingMaxAfter' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawTremblingMagnitude) == 0x0005B0, "Member 'AMordhauEquipment::RangedDrawTremblingMagnitude' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawTremblingFrequency) == 0x0005B4, "Member 'AMordhauEquipment::RangedDrawTremblingFrequency' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SkeletalMeshComponent) == 0x0005B8, "Member 'AMordhauEquipment::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AuxiliarySkeletalMeshComponent) == 0x0005C0, "Member 'AMordhauEquipment::AuxiliarySkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AuxiliaryMeshMode) == 0x0005C8, "Member 'AMordhauEquipment::AuxiliaryMeshMode' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AuxiliaryMeshOffset) == 0x0005D0, "Member 'AMordhauEquipment::AuxiliaryMeshOffset' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, DefaultAuxiliaryMeshRelativeTransform) == 0x000600, "Member 'AMordhauEquipment::DefaultAuxiliaryMeshRelativeTransform' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, CombinedSkeletalMesh) == 0x000630, "Member 'AMordhauEquipment::CombinedSkeletalMesh' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bIsFollowingProjectile) == 0x000638, "Member 'AMordhauEquipment::bIsFollowingProjectile' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, EquipmentPhysicalSurface) == 0x000639, "Member 'AMordhauEquipment::EquipmentPhysicalSurface' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, CurrentProjectile) == 0x000640, "Member 'AMordhauEquipment::CurrentProjectile' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ProjectileClass) == 0x000648, "Member 'AMordhauEquipment::ProjectileClass' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RestockAmmoForEquipment) == 0x000650, "Member 'AMordhauEquipment::RestockAmmoForEquipment' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, MaxAmountPerLoadout) == 0x000660, "Member 'AMordhauEquipment::MaxAmountPerLoadout' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bCanRestockFromEquipmentDefaults) == 0x000664, "Member 'AMordhauEquipment::bCanRestockFromEquipmentDefaults' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, MaxAmmoBoxRestockAmount) == 0x000668, "Member 'AMordhauEquipment::MaxAmmoBoxRestockAmount' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, MaxAmmoBoxRestockAmountCategory) == 0x00066C, "Member 'AMordhauEquipment::MaxAmmoBoxRestockAmountCategory' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, PhysicsProxy) == 0x000678, "Member 'AMordhauEquipment::PhysicsProxy' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, PhysicsAsset) == 0x000680, "Member 'AMordhauEquipment::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bDoNotDisarmOnMeleeWeaponHit) == 0x000688, "Member 'AMordhauEquipment::bDoNotDisarmOnMeleeWeaponHit' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bCannotChaseOthers) == 0x000689, "Member 'AMordhauEquipment::bCannotChaseOthers' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bCanBeChasedFromFront) == 0x00068A, "Member 'AMordhauEquipment::bCanBeChasedFromFront' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bCanRagdoll) == 0x00068B, "Member 'AMordhauEquipment::bCanRagdoll' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bUsesPhysicsProxy) == 0x00068C, "Member 'AMordhauEquipment::bUsesPhysicsProxy' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bOnlyPeasants) == 0x00068D, "Member 'AMordhauEquipment::bOnlyPeasants' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bIsAllowedForPeasants) == 0x00068E, "Member 'AMordhauEquipment::bIsAllowedForPeasants' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ArmoryTransformOffset) == 0x000690, "Member 'AMordhauEquipment::ArmoryTransformOffset' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, CharacterPointCost) == 0x0006C0, "Member 'AMordhauEquipment::CharacterPointCost' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, CullDistanceHeld) == 0x0006C4, "Member 'AMordhauEquipment::CullDistanceHeld' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, CullDistanceNotHeld) == 0x0006C8, "Member 'AMordhauEquipment::CullDistanceNotHeld' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, CullDistanceAuxiliaryHeld) == 0x0006CC, "Member 'AMordhauEquipment::CullDistanceAuxiliaryHeld' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, CullDistanceAuxiliaryNotHeld) == 0x0006D0, "Member 'AMordhauEquipment::CullDistanceAuxiliaryNotHeld' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bForceInstantMeshUpdate) == 0x0006D4, "Member 'AMordhauEquipment::bForceInstantMeshUpdate' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bForceMipStreaming) == 0x0006D5, "Member 'AMordhauEquipment::bForceMipStreaming' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bForceMaxLOD) == 0x0006D6, "Member 'AMordhauEquipment::bForceMaxLOD' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bPartsUseAuxiliaryMesh) == 0x0006D7, "Member 'AMordhauEquipment::bPartsUseAuxiliaryMesh' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, MeshComponents) == 0x0006D8, "Member 'AMordhauEquipment::MeshComponents' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, Quiver) == 0x0006E8, "Member 'AMordhauEquipment::Quiver' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, MaxAmmo) == 0x0006F0, "Member 'AMordhauEquipment::MaxAmmo' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, MaxAmmoWithoutQuiver) == 0x0006F1, "Member 'AMordhauEquipment::MaxAmmoWithoutQuiver' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, LastReplicatedAmmo) == 0x0006F2, "Member 'AMordhauEquipment::LastReplicatedAmmo' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bDestroyIfNoAmmo) == 0x0006F3, "Member 'AMordhauEquipment::bDestroyIfNoAmmo' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, MovementRestriction) == 0x0006F4, "Member 'AMordhauEquipment::MovementRestriction' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bPreventsClimbing) == 0x0006F5, "Member 'AMordhauEquipment::bPreventsClimbing' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SubSprintSpeedBonusEquipped) == 0x0006F8, "Member 'AMordhauEquipment::SubSprintSpeedBonusEquipped' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondSubSprintSpeedBonusEquipped) == 0x0006FC, "Member 'AMordhauEquipment::SecondSubSprintSpeedBonusEquipped' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SpeedOverrideEquipped) == 0x000700, "Member 'AMordhauEquipment::SpeedOverrideEquipped' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, BackpedalSpeedFactorEquipped) == 0x000704, "Member 'AMordhauEquipment::BackpedalSpeedFactorEquipped' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SpeedBonusPercentageEquipped) == 0x000708, "Member 'AMordhauEquipment::SpeedBonusPercentageEquipped' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AccelerationBonusPercentageEquipped) == 0x00070C, "Member 'AMordhauEquipment::AccelerationBonusPercentageEquipped' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SpeedBonusPercentageHolstered) == 0x000710, "Member 'AMordhauEquipment::SpeedBonusPercentageHolstered' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AccelerationBonusPercentageHolstered) == 0x000714, "Member 'AMordhauEquipment::AccelerationBonusPercentageHolstered' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AssignedCustomization) == 0x000718, "Member 'AMordhauEquipment::AssignedCustomization' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ReplicatedColors) == 0x000748, "Member 'AMordhauEquipment::ReplicatedColors' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ReplicatedPartsId) == 0x00074B, "Member 'AMordhauEquipment::ReplicatedPartsId' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ReplicatedSkin) == 0x00074E, "Member 'AMordhauEquipment::ReplicatedSkin' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ReplicatedEmblem) == 0x00074F, "Member 'AMordhauEquipment::ReplicatedEmblem' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ReplicatedEmblemColors) == 0x000750, "Member 'AMordhauEquipment::ReplicatedEmblemColors' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ReplicatedPattern) == 0x000752, "Member 'AMordhauEquipment::ReplicatedPattern' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bHasReplicatedColors) == 0x000753, "Member 'AMordhauEquipment::bHasReplicatedColors' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bHasReplicatedPartsId) == 0x000754, "Member 'AMordhauEquipment::bHasReplicatedPartsId' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bHasReplicatedSkin) == 0x000755, "Member 'AMordhauEquipment::bHasReplicatedSkin' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bHasReplicatedEmblem) == 0x000756, "Member 'AMordhauEquipment::bHasReplicatedEmblem' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bHasReplicatedEmblemColors) == 0x000757, "Member 'AMordhauEquipment::bHasReplicatedEmblemColors' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bHasReplicatedPattern) == 0x000758, "Member 'AMordhauEquipment::bHasReplicatedPattern' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, Skins) == 0x000760, "Member 'AMordhauEquipment::Skins' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, Colors) == 0x000770, "Member 'AMordhauEquipment::Colors' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, PartsId) == 0x000773, "Member 'AMordhauEquipment::PartsId' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, Skin) == 0x000776, "Member 'AMordhauEquipment::Skin' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, Pattern) == 0x000777, "Member 'AMordhauEquipment::Pattern' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, Emblem) == 0x000778, "Member 'AMordhauEquipment::Emblem' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, EmblemColors) == 0x000779, "Member 'AMordhauEquipment::EmblemColors' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bAutoAssignCustomizationOnBeginPlay) == 0x00077B, "Member 'AMordhauEquipment::bAutoAssignCustomizationOnBeginPlay' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AutoAssignCustomization) == 0x000780, "Member 'AMordhauEquipment::AutoAssignCustomization' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AutoAssignCustomizationEmblem) == 0x0007B0, "Member 'AMordhauEquipment::AutoAssignCustomizationEmblem' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AutoAssignCustomizationEmblemColor1) == 0x0007B1, "Member 'AMordhauEquipment::AutoAssignCustomizationEmblemColor1' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AutoAssignCustomizationEmblemColor2) == 0x0007B2, "Member 'AMordhauEquipment::AutoAssignCustomizationEmblemColor2' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bIsEmotingAllowed) == 0x0007B3, "Member 'AMordhauEquipment::bIsEmotingAllowed' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, EquipmentEmotes) == 0x0007B8, "Member 'AMordhauEquipment::EquipmentEmotes' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, KickAnimation) == 0x0007C8, "Member 'AMordhauEquipment::KickAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, JumpKickAnimation) == 0x0007D0, "Member 'AMordhauEquipment::JumpKickAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, KickRiposteAnimation) == 0x0007D8, "Member 'AMordhauEquipment::KickRiposteAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, JumpKickRiposteAnimation) == 0x0007E0, "Member 'AMordhauEquipment::JumpKickRiposteAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, KickComboAnimation) == 0x0007E8, "Member 'AMordhauEquipment::KickComboAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, JumpKickComboAnimation) == 0x0007F0, "Member 'AMordhauEquipment::JumpKickComboAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, KickBounce) == 0x0007F8, "Member 'AMordhauEquipment::KickBounce' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, UpperBlendSpace1P) == 0x000800, "Member 'AMordhauEquipment::UpperBlendSpace1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, UpperAdditive1P) == 0x000808, "Member 'AMordhauEquipment::UpperAdditive1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, UpperBlendSpaceUnloaded1P) == 0x000810, "Member 'AMordhauEquipment::UpperBlendSpaceUnloaded1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, UpperAdditiveUnloaded1P) == 0x000818, "Member 'AMordhauEquipment::UpperAdditiveUnloaded1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, UpperBlendSpace) == 0x000820, "Member 'AMordhauEquipment::UpperBlendSpace' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, UpperAdditive) == 0x000828, "Member 'AMordhauEquipment::UpperAdditive' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, UpperBlendSpaceUnloaded) == 0x000830, "Member 'AMordhauEquipment::UpperBlendSpaceUnloaded' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, UpperAdditiveUnloaded) == 0x000838, "Member 'AMordhauEquipment::UpperAdditiveUnloaded' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, LowerAnimation) == 0x000840, "Member 'AMordhauEquipment::LowerAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ShieldUpperBlendSpace1P) == 0x000848, "Member 'AMordhauEquipment::ShieldUpperBlendSpace1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ShieldUpperAdditive1P) == 0x000850, "Member 'AMordhauEquipment::ShieldUpperAdditive1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ShieldUpperBlendSpace) == 0x000858, "Member 'AMordhauEquipment::ShieldUpperBlendSpace' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ShieldUpperAdditive) == 0x000860, "Member 'AMordhauEquipment::ShieldUpperAdditive' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ShieldLowerAnimation) == 0x000868, "Member 'AMordhauEquipment::ShieldLowerAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ShieldHorseUpperBlendSpace1P) == 0x000870, "Member 'AMordhauEquipment::ShieldHorseUpperBlendSpace1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ShieldHorseUpperAdditive1P) == 0x000878, "Member 'AMordhauEquipment::ShieldHorseUpperAdditive1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ShieldHorseUpperBlendSpace) == 0x000880, "Member 'AMordhauEquipment::ShieldHorseUpperBlendSpace' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ShieldHorseUpperAdditive) == 0x000888, "Member 'AMordhauEquipment::ShieldHorseUpperAdditive' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HorseUpperBlendSpace1P) == 0x000890, "Member 'AMordhauEquipment::HorseUpperBlendSpace1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HorseUpperAdditive1P) == 0x000898, "Member 'AMordhauEquipment::HorseUpperAdditive1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HorseUpperBlendSpaceUnloaded1P) == 0x0008A0, "Member 'AMordhauEquipment::HorseUpperBlendSpaceUnloaded1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HorseUpperAdditiveUnloaded1P) == 0x0008A8, "Member 'AMordhauEquipment::HorseUpperAdditiveUnloaded1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HorseUpperBlendSpace) == 0x0008B0, "Member 'AMordhauEquipment::HorseUpperBlendSpace' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HorseUpperAdditive) == 0x0008B8, "Member 'AMordhauEquipment::HorseUpperAdditive' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HorseUpperBlendSpaceUnloaded) == 0x0008C0, "Member 'AMordhauEquipment::HorseUpperBlendSpaceUnloaded' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HorseUpperAdditiveUnloaded) == 0x0008C8, "Member 'AMordhauEquipment::HorseUpperAdditiveUnloaded' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HorseUpperRearing) == 0x0008D0, "Member 'AMordhauEquipment::HorseUpperRearing' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HorseUpperRearing1P) == 0x0008D8, "Member 'AMordhauEquipment::HorseUpperRearing1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HorseUpperJump) == 0x0008E0, "Member 'AMordhauEquipment::HorseUpperJump' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HorseUpperJump1P) == 0x0008E8, "Member 'AMordhauEquipment::HorseUpperJump1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ModeSwitchAnimation) == 0x0008F0, "Member 'AMordhauEquipment::ModeSwitchAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, DropAnimation) == 0x0008F8, "Member 'AMordhauEquipment::DropAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, InteractWithAnimation) == 0x000900, "Member 'AMordhauEquipment::InteractWithAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, InteractWith1PAnimation) == 0x000908, "Member 'AMordhauEquipment::InteractWith1PAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, JumpUnloadedAnimation) == 0x000910, "Member 'AMordhauEquipment::JumpUnloadedAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, JumpAnimation) == 0x000918, "Member 'AMordhauEquipment::JumpAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, JumpAnimationShield) == 0x000920, "Member 'AMordhauEquipment::JumpAnimationShield' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, JumpUnloadedAnimation1P) == 0x000928, "Member 'AMordhauEquipment::JumpUnloadedAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, JumpAnimation1P) == 0x000930, "Member 'AMordhauEquipment::JumpAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, JumpAnimationShield1P) == 0x000938, "Member 'AMordhauEquipment::JumpAnimationShield1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, FallingUnloadedAnimation) == 0x000940, "Member 'AMordhauEquipment::FallingUnloadedAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, FallingAnimation) == 0x000948, "Member 'AMordhauEquipment::FallingAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, FallingAnimationShield) == 0x000950, "Member 'AMordhauEquipment::FallingAnimationShield' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, FallingUnloadedAnimation1P) == 0x000958, "Member 'AMordhauEquipment::FallingUnloadedAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, FallingAnimation1P) == 0x000960, "Member 'AMordhauEquipment::FallingAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, FallingAnimationShield1P) == 0x000968, "Member 'AMordhauEquipment::FallingAnimationShield1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, LandUnloadedAnimation) == 0x000970, "Member 'AMordhauEquipment::LandUnloadedAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, LandAnimation) == 0x000978, "Member 'AMordhauEquipment::LandAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, LandAnimationShield) == 0x000980, "Member 'AMordhauEquipment::LandAnimationShield' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, LandUnloadedAnimation1P) == 0x000988, "Member 'AMordhauEquipment::LandUnloadedAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, LandAnimation1P) == 0x000990, "Member 'AMordhauEquipment::LandAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, LandAnimationShield1P) == 0x000998, "Member 'AMordhauEquipment::LandAnimationShield1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondDropAnimation) == 0x0009A0, "Member 'AMordhauEquipment::SecondDropAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondInteractWithAnimation) == 0x0009A8, "Member 'AMordhauEquipment::SecondInteractWithAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondInteractWith1PAnimation) == 0x0009B0, "Member 'AMordhauEquipment::SecondInteractWith1PAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondJumpUnloadedAnimation) == 0x0009B8, "Member 'AMordhauEquipment::SecondJumpUnloadedAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondJumpAnimation) == 0x0009C0, "Member 'AMordhauEquipment::SecondJumpAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondJumpUnloadedAnimation1P) == 0x0009C8, "Member 'AMordhauEquipment::SecondJumpUnloadedAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondJumpAnimation1P) == 0x0009D0, "Member 'AMordhauEquipment::SecondJumpAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondFallingUnloadedAnimation) == 0x0009D8, "Member 'AMordhauEquipment::SecondFallingUnloadedAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondFallingAnimation) == 0x0009E0, "Member 'AMordhauEquipment::SecondFallingAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondFallingUnloadedAnimation1P) == 0x0009E8, "Member 'AMordhauEquipment::SecondFallingUnloadedAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondFallingAnimation1P) == 0x0009F0, "Member 'AMordhauEquipment::SecondFallingAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondLandUnloadedAnimation) == 0x0009F8, "Member 'AMordhauEquipment::SecondLandUnloadedAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondLandAnimation) == 0x000A00, "Member 'AMordhauEquipment::SecondLandAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondLandUnloadedAnimation1P) == 0x000A08, "Member 'AMordhauEquipment::SecondLandUnloadedAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondLandAnimation1P) == 0x000A10, "Member 'AMordhauEquipment::SecondLandAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, CharacterPreviewPoses) == 0x000A18, "Member 'AMordhauEquipment::CharacterPreviewPoses' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawAnimation) == 0x000A28, "Member 'AMordhauEquipment::RangedDrawAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawAnimation1P) == 0x000A30, "Member 'AMordhauEquipment::RangedDrawAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawnAdditive) == 0x000A38, "Member 'AMordhauEquipment::RangedDrawnAdditive' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawEquipmentAnimation) == 0x000A40, "Member 'AMordhauEquipment::RangedDrawEquipmentAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawEquipmentAnimation1P) == 0x000A48, "Member 'AMordhauEquipment::RangedDrawEquipmentAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedReleaseAnimation) == 0x000A50, "Member 'AMordhauEquipment::RangedReleaseAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedReleaseAnimation1P) == 0x000A58, "Member 'AMordhauEquipment::RangedReleaseAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedReleaseEquipmentAnimation) == 0x000A60, "Member 'AMordhauEquipment::RangedReleaseEquipmentAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedReleaseEquipmentAnimation1P) == 0x000A68, "Member 'AMordhauEquipment::RangedReleaseEquipmentAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ReloadAnimation) == 0x000A70, "Member 'AMordhauEquipment::ReloadAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ReloadSound) == 0x000A78, "Member 'AMordhauEquipment::ReloadSound' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ReloadAnimation1P) == 0x000A80, "Member 'AMordhauEquipment::ReloadAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ReloadSound1P) == 0x000A88, "Member 'AMordhauEquipment::ReloadSound1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ReloadEquipmentAnimation) == 0x000A90, "Member 'AMordhauEquipment::ReloadEquipmentAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ReloadEquipmentAnimation1P) == 0x000A98, "Member 'AMordhauEquipment::ReloadEquipmentAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, QuickthrowAnimation1P) == 0x000AA0, "Member 'AMordhauEquipment::QuickthrowAnimation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, QuickthrowAnimation) == 0x000AA8, "Member 'AMordhauEquipment::QuickthrowAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bDisableSpineArmsCompensation1P) == 0x000AB0, "Member 'AMordhauEquipment::bDisableSpineArmsCompensation1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bDisableHandSpringAnimation) == 0x000AB1, "Member 'AMordhauEquipment::bDisableHandSpringAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RightHandIKPositionOffset) == 0x000AB4, "Member 'AMordhauEquipment::RightHandIKPositionOffset' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RightShoulderOffset1P) == 0x000AC0, "Member 'AMordhauEquipment::RightShoulderOffset1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, LeftShoulderOffset1P) == 0x000ACC, "Member 'AMordhauEquipment::LeftShoulderOffset1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, LeftShoulderIdleOffset1P) == 0x000AD8, "Member 'AMordhauEquipment::LeftShoulderIdleOffset1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bUsesOffhandIK) == 0x000AE4, "Member 'AMordhauEquipment::bUsesOffhandIK' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bInvertOffhandUp) == 0x000AE5, "Member 'AMordhauEquipment::bInvertOffhandUp' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bSecondInvertOffhandUp) == 0x000AE6, "Member 'AMordhauEquipment::bSecondInvertOffhandUp' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondUpperBlendSpace1P) == 0x000AE8, "Member 'AMordhauEquipment::SecondUpperBlendSpace1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondUpperAdditive1P) == 0x000AF0, "Member 'AMordhauEquipment::SecondUpperAdditive1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondUpperBlendSpaceUnloaded1P) == 0x000AF8, "Member 'AMordhauEquipment::SecondUpperBlendSpaceUnloaded1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondUpperAdditiveUnloaded1P) == 0x000B00, "Member 'AMordhauEquipment::SecondUpperAdditiveUnloaded1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondUpperBlendSpace) == 0x000B08, "Member 'AMordhauEquipment::SecondUpperBlendSpace' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondUpperAdditive) == 0x000B10, "Member 'AMordhauEquipment::SecondUpperAdditive' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondUpperBlendSpaceUnloaded) == 0x000B18, "Member 'AMordhauEquipment::SecondUpperBlendSpaceUnloaded' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondUpperAdditiveUnloaded) == 0x000B20, "Member 'AMordhauEquipment::SecondUpperAdditiveUnloaded' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondLowerAnimation) == 0x000B28, "Member 'AMordhauEquipment::SecondLowerAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondModeSwitchAnimation) == 0x000B30, "Member 'AMordhauEquipment::SecondModeSwitchAnimation' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bSecondUsesOffhandIK) == 0x000B38, "Member 'AMordhauEquipment::bSecondUsesOffhandIK' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, OffhandIKUpOffset) == 0x000B3C, "Member 'AMordhauEquipment::OffhandIKUpOffset' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, OffhandIKUpOffset1P) == 0x000B40, "Member 'AMordhauEquipment::OffhandIKUpOffset1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondOffhandIKUpOffset) == 0x000B44, "Member 'AMordhauEquipment::SecondOffhandIKUpOffset' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondOffhandIKUpOffset1P) == 0x000B48, "Member 'AMordhauEquipment::SecondOffhandIKUpOffset1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RightHandEquipOffset) == 0x000B4C, "Member 'AMordhauEquipment::RightHandEquipOffset' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RightWeaponBoneCosmeticTransform) == 0x000B60, "Member 'AMordhauEquipment::RightWeaponBoneCosmeticTransform' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RightWeaponBoneCosmeticTransform1P) == 0x000B90, "Member 'AMordhauEquipment::RightWeaponBoneCosmeticTransform1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondRightWeaponBoneCosmeticTransform) == 0x000BC0, "Member 'AMordhauEquipment::SecondRightWeaponBoneCosmeticTransform' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondRightWeaponBoneCosmeticTransform1P) == 0x000BF0, "Member 'AMordhauEquipment::SecondRightWeaponBoneCosmeticTransform1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RotationOffset) == 0x000C20, "Member 'AMordhauEquipment::RotationOffset' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondRotationOffset) == 0x000C2C, "Member 'AMordhauEquipment::SecondRotationOffset' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, GripLocationLocal) == 0x000C38, "Member 'AMordhauEquipment::GripLocationLocal' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, SecondGripLocationLocal) == 0x000C44, "Member 'AMordhauEquipment::SecondGripLocationLocal' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HolsterInfo) == 0x000C60, "Member 'AMordhauEquipment::HolsterInfo' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bCanHolster) == 0x000C70, "Member 'AMordhauEquipment::bCanHolster' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bCanEquipOnHorse) == 0x000C71, "Member 'AMordhauEquipment::bCanEquipOnHorse' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bCanEquipOnLadder) == 0x000C72, "Member 'AMordhauEquipment::bCanEquipOnLadder' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bSecondCanEquipOnHorse) == 0x000C73, "Member 'AMordhauEquipment::bSecondCanEquipOnHorse' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bSecondCanEquipOnLadder) == 0x000C74, "Member 'AMordhauEquipment::bSecondCanEquipOnLadder' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AmmoRefillSound) == 0x000C78, "Member 'AMordhauEquipment::AmmoRefillSound' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, EquipSound) == 0x000C80, "Member 'AMordhauEquipment::EquipSound' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, HolsterSound) == 0x000C88, "Member 'AMordhauEquipment::HolsterSound' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, DrawSound) == 0x000C90, "Member 'AMordhauEquipment::DrawSound' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, DrawSoundPlayAtNormalizedTime) == 0x000C98, "Member 'AMordhauEquipment::DrawSoundPlayAtNormalizedTime' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, DrawSoundPlayAtNormalizedTime1P) == 0x000C9C, "Member 'AMordhauEquipment::DrawSoundPlayAtNormalizedTime1P' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedCancelSound) == 0x000CA0, "Member 'AMordhauEquipment::RangedCancelSound' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, FireSound) == 0x000CA8, "Member 'AMordhauEquipment::FireSound' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bAlwaysDestroyOnDeath) == 0x000CB0, "Member 'AMordhauEquipment::bAlwaysDestroyOnDeath' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bDeferDestroyUntilRagdoll) == 0x000CB1, "Member 'AMordhauEquipment::bDeferDestroyUntilRagdoll' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RagdollStayTime) == 0x000CB4, "Member 'AMordhauEquipment::RagdollStayTime' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bAllowDrop) == 0x000CB8, "Member 'AMordhauEquipment::bAllowDrop' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bCanAttack) == 0x000CB9, "Member 'AMordhauEquipment::bCanAttack' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bCanAttackOnFoot) == 0x000CBA, "Member 'AMordhauEquipment::bCanAttackOnFoot' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bCanAttackOnHorseback) == 0x000CBB, "Member 'AMordhauEquipment::bCanAttackOnHorseback' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bAllowFire) == 0x000CBC, "Member 'AMordhauEquipment::bAllowFire' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bFireThrowsEquipment) == 0x000CBD, "Member 'AMordhauEquipment::bFireThrowsEquipment' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ExtraSwitchTime) == 0x000CC0, "Member 'AMordhauEquipment::ExtraSwitchTime' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bRangedReleasePlaysAttackYell) == 0x000CC4, "Member 'AMordhauEquipment::bRangedReleasePlaysAttackYell' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bUsesRangedCamera) == 0x000CC5, "Member 'AMordhauEquipment::bUsesRangedCamera' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bAllowHoldDraw) == 0x000CC6, "Member 'AMordhauEquipment::bAllowHoldDraw' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bAllowCancelDraw) == 0x000CC7, "Member 'AMordhauEquipment::bAllowCancelDraw' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, MaxHoldDrawTime) == 0x000CC8, "Member 'AMordhauEquipment::MaxHoldDrawTime' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ReloadMovementRestriction) == 0x000CCC, "Member 'AMordhauEquipment::ReloadMovementRestriction' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawMovementRestriction) == 0x000CCD, "Member 'AMordhauEquipment::RangedDrawMovementRestriction' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawSpeedFactor) == 0x000CD0, "Member 'AMordhauEquipment::RangedDrawSpeedFactor' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawSpeedFactorWithRangerPerk) == 0x000CD4, "Member 'AMordhauEquipment::RangedDrawSpeedFactorWithRangerPerk' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawTurnCaps) == 0x000CD8, "Member 'AMordhauEquipment::RangedDrawTurnCaps' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedReleaseMovementRestriction) == 0x000CE0, "Member 'AMordhauEquipment::RangedReleaseMovementRestriction' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bDoNotFireAfterMaxHoldDrawTime) == 0x000CE1, "Member 'AMordhauEquipment::bDoNotFireAfterMaxHoldDrawTime' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bQuickthrowOnly) == 0x000CE2, "Member 'AMordhauEquipment::bQuickthrowOnly' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, ForceAppliedOnDrop) == 0x000CE4, "Member 'AMordhauEquipment::ForceAppliedOnDrop' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bAllowCleanup) == 0x000CE8, "Member 'AMordhauEquipment::bAllowCleanup' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedDrawTime) == 0x000CEC, "Member 'AMordhauEquipment::RangedDrawTime' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedCancelTime) == 0x000CF0, "Member 'AMordhauEquipment::RangedCancelTime' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedReleaseTime) == 0x000CF4, "Member 'AMordhauEquipment::RangedReleaseTime' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedReleaseCameraShake) == 0x000CF8, "Member 'AMordhauEquipment::RangedReleaseCameraShake' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedReloadTime) == 0x000D00, "Member 'AMordhauEquipment::RangedReloadTime' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedReloadTurnCaps) == 0x000D04, "Member 'AMordhauEquipment::RangedReloadTurnCaps' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedReloadGrabAmmoNormTime) == 0x000D0C, "Member 'AMordhauEquipment::RangedReloadGrabAmmoNormTime' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, RangedReloadFinishReloadNormTime) == 0x000D10, "Member 'AMordhauEquipment::RangedReloadFinishReloadNormTime' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AutoReloadTime) == 0x000D14, "Member 'AMordhauEquipment::AutoReloadTime' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, AutoReloadTimeSpent) == 0x000D18, "Member 'AMordhauEquipment::AutoReloadTimeSpent' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bCanReload) == 0x000D1C, "Member 'AMordhauEquipment::bCanReload' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bUnloadOnUnequip) == 0x000D1D, "Member 'AMordhauEquipment::bUnloadOnUnequip' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bLoadOnUnequip) == 0x000D1E, "Member 'AMordhauEquipment::bLoadOnUnequip' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bIsLoaded) == 0x000D1F, "Member 'AMordhauEquipment::bIsLoaded' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bHiddenWhenUnloaded) == 0x000D20, "Member 'AMordhauEquipment::bHiddenWhenUnloaded' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bIsUsingAlternateMode) == 0x000D22, "Member 'AMordhauEquipment::bIsUsingAlternateMode' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bHasAlternateMode) == 0x000D23, "Member 'AMordhauEquipment::bHasAlternateMode' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bRevertModeOnUnequip) == 0x000D24, "Member 'AMordhauEquipment::bRevertModeOnUnequip' has a wrong offset!");
static_assert(offsetof(AMordhauEquipment, bRevertModeOnDrop) == 0x000D25, "Member 'AMordhauEquipment::bRevertModeOnDrop' has a wrong offset!");

// Class Mordhau.MordhauWeapon
// 0x0F60 (0x1C90 - 0x0D30)
class AMordhauWeapon : public AMordhauEquipment
{
public:
	TArray<struct FHitResult>                     SingleTraceHitsCache;                              // 0x0D28(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAudioComponent>         LastWoosh;                                         // 0x0D38(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAreCurrentTracersValid;                           // 0x0D40(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArePreviousTracersValid;                          // 0x0D41(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAreCurrentTracersInvalidated;                     // 0x0D42(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAdditionalTracers;                             // 0x0D43(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondHasAdditionalTracers;                       // 0x0D44(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D45[0x3];                                      // 0x0D45(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentTraceStart;                                 // 0x0D48(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentTraceEnd;                                   // 0x0D54(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousTraceStart;                                // 0x0D60(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousTraceEnd;                                  // 0x0D6C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentAdditionalTraceStart;                       // 0x0D78(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentAdditionalTraceEnd;                         // 0x0D84(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousAdditionalTraceStart;                      // 0x0D90(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousAdditionalTraceEnd;                        // 0x0D9C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackMove                                   LastObservedMove;                                  // 0x0DA8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA9[0x7];                                      // 0x0DA9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        LastTraceStarts;                                   // 0x0DB0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FActorSetAndArray                      CosmeticIgnoreActors;                              // 0x0DC0(0x0060)(NativeAccessSpecifierPublic)
	struct FActorTraceData                        CosmeticActorTraceData;                            // 0x0E20(0x0068)(NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorIgnoreCache;                                  // 0x0E88(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<class AActor*>                           ActorSetCache;                                     // 0x0E98(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     HitResultCache;                                    // 0x0EE8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bCanBlock;                                         // 0x0EF8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBlockOnFoot;                                   // 0x0EF9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBlockOnHorseback;                              // 0x0EFA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCouchOnHorseback;                              // 0x0EFB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EFC[0x4];                                      // 0x0EFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CouchWindUpAnim;                                   // 0x0F00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CouchWindUpAnim1P;                                 // 0x0F08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CouchLoopAnim;                                     // 0x0F10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CouchReleaseAnim;                                  // 0x0F18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CouchReleaseAnim1P;                                // 0x0F20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDismembermentType                            StrikeDismembermentType;                           // 0x0F28(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDismembermentType                            SecondStrikeDismembermentType;                     // 0x0F29(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDismembermentType                            StabDismembermentType;                             // 0x0F2A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDismembermentType                            SecondStabDismembermentType;                       // 0x0F2B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideRadius;                                       // 0x0F2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackSupersprintDuration;                         // 0x0F30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondAttackSupersprintDuration;                   // 0x0F34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StabReleaseModifier;                               // 0x0F38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F3C[0x4];                                      // 0x0F3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttackInfo                            StabAttack;                                        // 0x0F40(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAttackInfo                            SecondStabAttack;                                  // 0x1068(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAttackInfo                            CouchAttack;                                       // 0x1190(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAttackInfo                            SecondCouchAttack;                                 // 0x12B8(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAttackInfo                            StrikeAttack;                                      // 0x13E0(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAttackInfo                            SecondStrikeAttack;                                // 0x1508(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAttackInfo                            KickAttack;                                        // 0x1630(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAttackInfo                            SecondKickAttack;                                  // 0x1758(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAttackInfo                            BashAttack;                                        // 0x1880(0x0128)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         AttackMask;                                        // 0x19A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ParryMask;                                         // 0x19AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParryWindowOffset;                                 // 0x19B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19B4[0xC];                                     // 0x19B4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ParryBoxTransform;                                 // 0x19C0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              ParryTurnCap;                                      // 0x19F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ShieldWallTurnCap;                                 // 0x19F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ParrySuccessTurnCap;                               // 0x1A00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParryBackpedalSpeedFactor;                         // 0x1A08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsParryHeld;                                      // 0x1A0C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0D[0x3];                                     // 0x1A0D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ParryHeldStaminaDrain;                             // 0x1A10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostCosmeticTracersBy;                            // 0x1A14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesExtraEnvironmentTracers;                      // 0x1A18(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitKnockbackOnTeammates;                          // 0x1A19(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1A[0x2];                                     // 0x1A1A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ClashNormal;                                       // 0x1A1C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondClashNormal;                                 // 0x1A28(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementRestriction                          BlockMovementRestriction;                          // 0x1A34(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A35[0x3];                                     // 0x1A35(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlockStaminaNegation;                              // 0x1A38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BlockStaminaClamp;                                 // 0x1A3C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondBlockStaminaNegation;                        // 0x1A44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SecondBlockStaminaClamp;                           // 0x1A48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    ClashCollider;                                     // 0x1A50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    BlockCollider;                                     // 0x1A58(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMeleeWeaponAnimationProfile> WeaponAnimationProfileClass;                       // 0x1A60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMeleeWeaponAnimationProfile> SecondWeaponAnimationProfileClass;                 // 0x1A68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMeleeWeaponAnimationProfile> HorseWeaponAnimationProfileClass;                  // 0x1A70(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMeleeWeaponAnimationProfile> LadderWeaponAnimationProfileClass;                 // 0x1A78(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeleeWeaponAnimationProfile*           HorseWeaponAnimationProfile;                       // 0x1A80(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeleeWeaponAnimationProfile*           LadderWeaponAnimationProfile;                      // 0x1A88(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeleeWeaponAnimationProfile*           WeaponAnimationProfile;                            // 0x1A90(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeleeWeaponAnimationProfile*           SecondWeaponAnimationProfile;                      // 0x1A98(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              BlockedSound;                                      // 0x1AA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              BlockedViewTargetSweetener;                        // 0x1AA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              HitCancelSound;                                    // 0x1AB0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              WasBlockedSound;                                   // 0x1AB8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EnvironmentPitchScaleByDamageIn;                   // 0x1AC0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EnvironmentPitchScaleByDamageOut;                  // 0x1AC8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EnvironmentVolumeScaleByDamageIn;                  // 0x1AD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              EnvironmentVolumeScaleByDamageOut;                 // 0x1AD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WooshVolumeMultiplierViewTarget;                   // 0x1AE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AE4[0x4];                                     // 0x1AE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              StrikeHitSound;                                    // 0x1AE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              StabHitSound;                                      // 0x1AF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              EnvironmentHitSound;                               // 0x1AF8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SecondStrikeHitSound;                              // 0x1B00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SecondStabHitSound;                                // 0x1B08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SecondEnvironmentHitSound;                         // 0x1B10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              StrikeWooshSound;                                  // 0x1B18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              StabWooshSound;                                    // 0x1B20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SlideStartSound;                                   // 0x1B28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SlideEndSound;                                     // 0x1B30(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeriveHandGripFromTracers;                        // 0x1B38(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondDeriveHandGripFromTracers;                  // 0x1B39(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasWoodenHandle;                                  // 0x1B3A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B3B[0x1];                                     // 0x1B3B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TrailLifeTimeFactor;                               // 0x1B3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrailExtraTime;                                    // 0x1B40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloodTrailMaxDuration;                             // 0x1B44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwingTrailFadeOutDuration;                         // 0x1B48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4C[0x4];                                     // 0x1B4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        SwingTrailParticles;                               // 0x1B50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        BloodTrailParticles;                               // 0x1B58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        BlockParticles;                                    // 0x1B60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        HitCancelParticles;                                // 0x1B68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystem*>                ImpactParticlesBySurface;                          // 0x1B70(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UParticleSystem*                        SlideParticles;                                    // 0x1B80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   HeadHitForceFeedback;                              // 0x1B88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   EnvironmentHitForceFeedback;                       // 0x1B90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauWeapon>          SlidingWith;                                       // 0x1B98(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              EndCurrentSlideWithSound;                          // 0x1BA0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingStartTime;                                  // 0x1BA8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         CurrentSlideStartSound;                            // 0x1BAC(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         LastHitSoundA;                                     // 0x1BB4(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         LastHitSoundB;                                     // 0x1BBC(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UParticleSystemComponent> CurrentSlideParticles;                             // 0x1BC4(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UParticleSystemComponent> CurrentSwingTrailParticles;                        // 0x1BCC(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UParticleSystemComponent> CurrentBloodTrailParticles;                        // 0x1BD4(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrailTimeBeforeStop;                               // 0x1BDC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwingTrailOriginalLifeTime;                        // 0x1BE0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwingTrailEndTime;                                 // 0x1BE4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloodTrailEndTime;                                 // 0x1BE8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x1BEC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondLength;                                      // 0x1BF0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloodLevel1;                                       // 0x1BF4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloodLevel2;                                       // 0x1BF8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayedHitEffect;                                  // 0x1BFC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BFD[0x3];                                     // 0x1BFD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TrailUp;                                           // 0x1C00(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondTrailUp;                                     // 0x1C0C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TrailRight;                                        // 0x1C18(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecondTrailRight;                                  // 0x1C24(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultTrailFactor;                                // 0x1C30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondDefaultTrailFactor;                          // 0x1C34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegularAttacksUseBlood2;                          // 0x1C38(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSecondRegularAttacksUseBlood2;                    // 0x1C39(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C3A[0x2];                                     // 0x1C3A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TrailFactor;                                       // 0x1C3C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondTrailFactor;                                 // 0x1C40(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrailWeight;                                       // 0x1C44(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C48[0x8];                                     // 0x1C48(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LastTrailTransform;                                // 0x1C50(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LastObservedTraceDirection;                        // 0x1C80(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C8C[0x4];                                     // 0x1C8C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTraceEntryData(class AActor* Actor, class FName bone);
	void GetAdditionalTrace(struct FVector* TraceStart, struct FVector* TraceEnd);
	const struct FAttackInfo GetBaseAttackInfo(EAttackMove Move);
	void GetTrace(struct FVector* TraceStart, struct FVector* TraceEnd);
	void IncreaseBloodLevel(float Amount);
	bool IsAllowedToAddForce();
	void OnAttackStarted(EAttackMove Move, float Angle);
	void OnAttackStopped();
	void OnBlocked(const struct FBlockResult& Result, EAttackMove Move);
	void OnBlockStarted(EBlockType Type);
	void OnCosmeticHit(EAttackMove Move, const struct FHitResult& Hit);
	void OnHit(class AActor* Actor, EAttackMove Move, class FName bone, const struct FVector& WorldLocation, uint8 Tier, uint8 SurfaceType);
	void OnWasBlocked(const struct FBlockResult& Result, EAttackMove Move);
	bool RequestBlock(EBlockType BlockType, bool bAllowFTP);
	void SetIsAllowedToAddForce(bool bIsAllowed);
	void UpdateTrail(float Weight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauWeapon">();
	}
	static class AMordhauWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauWeapon>();
	}
};
static_assert(alignof(AMordhauWeapon) == 0x000010, "Wrong alignment on AMordhauWeapon");
static_assert(sizeof(AMordhauWeapon) == 0x001C90, "Wrong size on AMordhauWeapon");
static_assert(offsetof(AMordhauWeapon, SingleTraceHitsCache) == 0x000D28, "Member 'AMordhauWeapon::SingleTraceHitsCache' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, LastWoosh) == 0x000D38, "Member 'AMordhauWeapon::LastWoosh' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bAreCurrentTracersValid) == 0x000D40, "Member 'AMordhauWeapon::bAreCurrentTracersValid' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bArePreviousTracersValid) == 0x000D41, "Member 'AMordhauWeapon::bArePreviousTracersValid' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bAreCurrentTracersInvalidated) == 0x000D42, "Member 'AMordhauWeapon::bAreCurrentTracersInvalidated' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bHasAdditionalTracers) == 0x000D43, "Member 'AMordhauWeapon::bHasAdditionalTracers' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bSecondHasAdditionalTracers) == 0x000D44, "Member 'AMordhauWeapon::bSecondHasAdditionalTracers' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CurrentTraceStart) == 0x000D48, "Member 'AMordhauWeapon::CurrentTraceStart' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CurrentTraceEnd) == 0x000D54, "Member 'AMordhauWeapon::CurrentTraceEnd' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, PreviousTraceStart) == 0x000D60, "Member 'AMordhauWeapon::PreviousTraceStart' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, PreviousTraceEnd) == 0x000D6C, "Member 'AMordhauWeapon::PreviousTraceEnd' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CurrentAdditionalTraceStart) == 0x000D78, "Member 'AMordhauWeapon::CurrentAdditionalTraceStart' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CurrentAdditionalTraceEnd) == 0x000D84, "Member 'AMordhauWeapon::CurrentAdditionalTraceEnd' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, PreviousAdditionalTraceStart) == 0x000D90, "Member 'AMordhauWeapon::PreviousAdditionalTraceStart' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, PreviousAdditionalTraceEnd) == 0x000D9C, "Member 'AMordhauWeapon::PreviousAdditionalTraceEnd' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, LastObservedMove) == 0x000DA8, "Member 'AMordhauWeapon::LastObservedMove' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, LastTraceStarts) == 0x000DB0, "Member 'AMordhauWeapon::LastTraceStarts' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CosmeticIgnoreActors) == 0x000DC0, "Member 'AMordhauWeapon::CosmeticIgnoreActors' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CosmeticActorTraceData) == 0x000E20, "Member 'AMordhauWeapon::CosmeticActorTraceData' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, ActorIgnoreCache) == 0x000E88, "Member 'AMordhauWeapon::ActorIgnoreCache' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, ActorSetCache) == 0x000E98, "Member 'AMordhauWeapon::ActorSetCache' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, HitResultCache) == 0x000EE8, "Member 'AMordhauWeapon::HitResultCache' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bCanBlock) == 0x000EF8, "Member 'AMordhauWeapon::bCanBlock' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bCanBlockOnFoot) == 0x000EF9, "Member 'AMordhauWeapon::bCanBlockOnFoot' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bCanBlockOnHorseback) == 0x000EFA, "Member 'AMordhauWeapon::bCanBlockOnHorseback' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bCanCouchOnHorseback) == 0x000EFB, "Member 'AMordhauWeapon::bCanCouchOnHorseback' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CouchWindUpAnim) == 0x000F00, "Member 'AMordhauWeapon::CouchWindUpAnim' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CouchWindUpAnim1P) == 0x000F08, "Member 'AMordhauWeapon::CouchWindUpAnim1P' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CouchLoopAnim) == 0x000F10, "Member 'AMordhauWeapon::CouchLoopAnim' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CouchReleaseAnim) == 0x000F18, "Member 'AMordhauWeapon::CouchReleaseAnim' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CouchReleaseAnim1P) == 0x000F20, "Member 'AMordhauWeapon::CouchReleaseAnim1P' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, StrikeDismembermentType) == 0x000F28, "Member 'AMordhauWeapon::StrikeDismembermentType' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondStrikeDismembermentType) == 0x000F29, "Member 'AMordhauWeapon::SecondStrikeDismembermentType' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, StabDismembermentType) == 0x000F2A, "Member 'AMordhauWeapon::StabDismembermentType' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondStabDismembermentType) == 0x000F2B, "Member 'AMordhauWeapon::SecondStabDismembermentType' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SlideRadius) == 0x000F2C, "Member 'AMordhauWeapon::SlideRadius' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, AttackSupersprintDuration) == 0x000F30, "Member 'AMordhauWeapon::AttackSupersprintDuration' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondAttackSupersprintDuration) == 0x000F34, "Member 'AMordhauWeapon::SecondAttackSupersprintDuration' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, StabReleaseModifier) == 0x000F38, "Member 'AMordhauWeapon::StabReleaseModifier' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, StabAttack) == 0x000F40, "Member 'AMordhauWeapon::StabAttack' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondStabAttack) == 0x001068, "Member 'AMordhauWeapon::SecondStabAttack' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CouchAttack) == 0x001190, "Member 'AMordhauWeapon::CouchAttack' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondCouchAttack) == 0x0012B8, "Member 'AMordhauWeapon::SecondCouchAttack' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, StrikeAttack) == 0x0013E0, "Member 'AMordhauWeapon::StrikeAttack' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondStrikeAttack) == 0x001508, "Member 'AMordhauWeapon::SecondStrikeAttack' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, KickAttack) == 0x001630, "Member 'AMordhauWeapon::KickAttack' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondKickAttack) == 0x001758, "Member 'AMordhauWeapon::SecondKickAttack' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BashAttack) == 0x001880, "Member 'AMordhauWeapon::BashAttack' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, AttackMask) == 0x0019A8, "Member 'AMordhauWeapon::AttackMask' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, ParryMask) == 0x0019AC, "Member 'AMordhauWeapon::ParryMask' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, ParryWindowOffset) == 0x0019B0, "Member 'AMordhauWeapon::ParryWindowOffset' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, ParryBoxTransform) == 0x0019C0, "Member 'AMordhauWeapon::ParryBoxTransform' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, ParryTurnCap) == 0x0019F0, "Member 'AMordhauWeapon::ParryTurnCap' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, ShieldWallTurnCap) == 0x0019F8, "Member 'AMordhauWeapon::ShieldWallTurnCap' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, ParrySuccessTurnCap) == 0x001A00, "Member 'AMordhauWeapon::ParrySuccessTurnCap' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, ParryBackpedalSpeedFactor) == 0x001A08, "Member 'AMordhauWeapon::ParryBackpedalSpeedFactor' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bIsParryHeld) == 0x001A0C, "Member 'AMordhauWeapon::bIsParryHeld' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, ParryHeldStaminaDrain) == 0x001A10, "Member 'AMordhauWeapon::ParryHeldStaminaDrain' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BoostCosmeticTracersBy) == 0x001A14, "Member 'AMordhauWeapon::BoostCosmeticTracersBy' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bUsesExtraEnvironmentTracers) == 0x001A18, "Member 'AMordhauWeapon::bUsesExtraEnvironmentTracers' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bHitKnockbackOnTeammates) == 0x001A19, "Member 'AMordhauWeapon::bHitKnockbackOnTeammates' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, ClashNormal) == 0x001A1C, "Member 'AMordhauWeapon::ClashNormal' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondClashNormal) == 0x001A28, "Member 'AMordhauWeapon::SecondClashNormal' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BlockMovementRestriction) == 0x001A34, "Member 'AMordhauWeapon::BlockMovementRestriction' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BlockStaminaNegation) == 0x001A38, "Member 'AMordhauWeapon::BlockStaminaNegation' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BlockStaminaClamp) == 0x001A3C, "Member 'AMordhauWeapon::BlockStaminaClamp' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondBlockStaminaNegation) == 0x001A44, "Member 'AMordhauWeapon::SecondBlockStaminaNegation' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondBlockStaminaClamp) == 0x001A48, "Member 'AMordhauWeapon::SecondBlockStaminaClamp' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, ClashCollider) == 0x001A50, "Member 'AMordhauWeapon::ClashCollider' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BlockCollider) == 0x001A58, "Member 'AMordhauWeapon::BlockCollider' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, WeaponAnimationProfileClass) == 0x001A60, "Member 'AMordhauWeapon::WeaponAnimationProfileClass' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondWeaponAnimationProfileClass) == 0x001A68, "Member 'AMordhauWeapon::SecondWeaponAnimationProfileClass' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, HorseWeaponAnimationProfileClass) == 0x001A70, "Member 'AMordhauWeapon::HorseWeaponAnimationProfileClass' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, LadderWeaponAnimationProfileClass) == 0x001A78, "Member 'AMordhauWeapon::LadderWeaponAnimationProfileClass' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, HorseWeaponAnimationProfile) == 0x001A80, "Member 'AMordhauWeapon::HorseWeaponAnimationProfile' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, LadderWeaponAnimationProfile) == 0x001A88, "Member 'AMordhauWeapon::LadderWeaponAnimationProfile' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, WeaponAnimationProfile) == 0x001A90, "Member 'AMordhauWeapon::WeaponAnimationProfile' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondWeaponAnimationProfile) == 0x001A98, "Member 'AMordhauWeapon::SecondWeaponAnimationProfile' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BlockedSound) == 0x001AA0, "Member 'AMordhauWeapon::BlockedSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BlockedViewTargetSweetener) == 0x001AA8, "Member 'AMordhauWeapon::BlockedViewTargetSweetener' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, HitCancelSound) == 0x001AB0, "Member 'AMordhauWeapon::HitCancelSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, WasBlockedSound) == 0x001AB8, "Member 'AMordhauWeapon::WasBlockedSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, EnvironmentPitchScaleByDamageIn) == 0x001AC0, "Member 'AMordhauWeapon::EnvironmentPitchScaleByDamageIn' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, EnvironmentPitchScaleByDamageOut) == 0x001AC8, "Member 'AMordhauWeapon::EnvironmentPitchScaleByDamageOut' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, EnvironmentVolumeScaleByDamageIn) == 0x001AD0, "Member 'AMordhauWeapon::EnvironmentVolumeScaleByDamageIn' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, EnvironmentVolumeScaleByDamageOut) == 0x001AD8, "Member 'AMordhauWeapon::EnvironmentVolumeScaleByDamageOut' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, WooshVolumeMultiplierViewTarget) == 0x001AE0, "Member 'AMordhauWeapon::WooshVolumeMultiplierViewTarget' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, StrikeHitSound) == 0x001AE8, "Member 'AMordhauWeapon::StrikeHitSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, StabHitSound) == 0x001AF0, "Member 'AMordhauWeapon::StabHitSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, EnvironmentHitSound) == 0x001AF8, "Member 'AMordhauWeapon::EnvironmentHitSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondStrikeHitSound) == 0x001B00, "Member 'AMordhauWeapon::SecondStrikeHitSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondStabHitSound) == 0x001B08, "Member 'AMordhauWeapon::SecondStabHitSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondEnvironmentHitSound) == 0x001B10, "Member 'AMordhauWeapon::SecondEnvironmentHitSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, StrikeWooshSound) == 0x001B18, "Member 'AMordhauWeapon::StrikeWooshSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, StabWooshSound) == 0x001B20, "Member 'AMordhauWeapon::StabWooshSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SlideStartSound) == 0x001B28, "Member 'AMordhauWeapon::SlideStartSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SlideEndSound) == 0x001B30, "Member 'AMordhauWeapon::SlideEndSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bDeriveHandGripFromTracers) == 0x001B38, "Member 'AMordhauWeapon::bDeriveHandGripFromTracers' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bSecondDeriveHandGripFromTracers) == 0x001B39, "Member 'AMordhauWeapon::bSecondDeriveHandGripFromTracers' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bHasWoodenHandle) == 0x001B3A, "Member 'AMordhauWeapon::bHasWoodenHandle' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, TrailLifeTimeFactor) == 0x001B3C, "Member 'AMordhauWeapon::TrailLifeTimeFactor' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, TrailExtraTime) == 0x001B40, "Member 'AMordhauWeapon::TrailExtraTime' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BloodTrailMaxDuration) == 0x001B44, "Member 'AMordhauWeapon::BloodTrailMaxDuration' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SwingTrailFadeOutDuration) == 0x001B48, "Member 'AMordhauWeapon::SwingTrailFadeOutDuration' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SwingTrailParticles) == 0x001B50, "Member 'AMordhauWeapon::SwingTrailParticles' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BloodTrailParticles) == 0x001B58, "Member 'AMordhauWeapon::BloodTrailParticles' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BlockParticles) == 0x001B60, "Member 'AMordhauWeapon::BlockParticles' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, HitCancelParticles) == 0x001B68, "Member 'AMordhauWeapon::HitCancelParticles' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, ImpactParticlesBySurface) == 0x001B70, "Member 'AMordhauWeapon::ImpactParticlesBySurface' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SlideParticles) == 0x001B80, "Member 'AMordhauWeapon::SlideParticles' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, HeadHitForceFeedback) == 0x001B88, "Member 'AMordhauWeapon::HeadHitForceFeedback' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, EnvironmentHitForceFeedback) == 0x001B90, "Member 'AMordhauWeapon::EnvironmentHitForceFeedback' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SlidingWith) == 0x001B98, "Member 'AMordhauWeapon::SlidingWith' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, EndCurrentSlideWithSound) == 0x001BA0, "Member 'AMordhauWeapon::EndCurrentSlideWithSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SlidingStartTime) == 0x001BA8, "Member 'AMordhauWeapon::SlidingStartTime' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CurrentSlideStartSound) == 0x001BAC, "Member 'AMordhauWeapon::CurrentSlideStartSound' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, LastHitSoundA) == 0x001BB4, "Member 'AMordhauWeapon::LastHitSoundA' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, LastHitSoundB) == 0x001BBC, "Member 'AMordhauWeapon::LastHitSoundB' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CurrentSlideParticles) == 0x001BC4, "Member 'AMordhauWeapon::CurrentSlideParticles' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CurrentSwingTrailParticles) == 0x001BCC, "Member 'AMordhauWeapon::CurrentSwingTrailParticles' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, CurrentBloodTrailParticles) == 0x001BD4, "Member 'AMordhauWeapon::CurrentBloodTrailParticles' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, TrailTimeBeforeStop) == 0x001BDC, "Member 'AMordhauWeapon::TrailTimeBeforeStop' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SwingTrailOriginalLifeTime) == 0x001BE0, "Member 'AMordhauWeapon::SwingTrailOriginalLifeTime' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SwingTrailEndTime) == 0x001BE4, "Member 'AMordhauWeapon::SwingTrailEndTime' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BloodTrailEndTime) == 0x001BE8, "Member 'AMordhauWeapon::BloodTrailEndTime' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, Length) == 0x001BEC, "Member 'AMordhauWeapon::Length' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondLength) == 0x001BF0, "Member 'AMordhauWeapon::SecondLength' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BloodLevel1) == 0x001BF4, "Member 'AMordhauWeapon::BloodLevel1' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, BloodLevel2) == 0x001BF8, "Member 'AMordhauWeapon::BloodLevel2' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bPlayedHitEffect) == 0x001BFC, "Member 'AMordhauWeapon::bPlayedHitEffect' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, TrailUp) == 0x001C00, "Member 'AMordhauWeapon::TrailUp' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondTrailUp) == 0x001C0C, "Member 'AMordhauWeapon::SecondTrailUp' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, TrailRight) == 0x001C18, "Member 'AMordhauWeapon::TrailRight' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondTrailRight) == 0x001C24, "Member 'AMordhauWeapon::SecondTrailRight' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, DefaultTrailFactor) == 0x001C30, "Member 'AMordhauWeapon::DefaultTrailFactor' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondDefaultTrailFactor) == 0x001C34, "Member 'AMordhauWeapon::SecondDefaultTrailFactor' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bRegularAttacksUseBlood2) == 0x001C38, "Member 'AMordhauWeapon::bRegularAttacksUseBlood2' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, bSecondRegularAttacksUseBlood2) == 0x001C39, "Member 'AMordhauWeapon::bSecondRegularAttacksUseBlood2' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, TrailFactor) == 0x001C3C, "Member 'AMordhauWeapon::TrailFactor' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, SecondTrailFactor) == 0x001C40, "Member 'AMordhauWeapon::SecondTrailFactor' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, TrailWeight) == 0x001C44, "Member 'AMordhauWeapon::TrailWeight' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, LastTrailTransform) == 0x001C50, "Member 'AMordhauWeapon::LastTrailTransform' has a wrong offset!");
static_assert(offsetof(AMordhauWeapon, LastObservedTraceDirection) == 0x001C80, "Member 'AMordhauWeapon::LastObservedTraceDirection' has a wrong offset!");

// Class Mordhau.VirtualWeapon
// 0x0000 (0x1C90 - 0x1C90)
class AVirtualWeapon : public AMordhauWeapon
{
public:
	void InitializeVirtualWeapon(class AMordhauCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VirtualWeapon">();
	}
	static class AVirtualWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVirtualWeapon>();
	}
};
static_assert(alignof(AVirtualWeapon) == 0x000010, "Wrong alignment on AVirtualWeapon");
static_assert(sizeof(AVirtualWeapon) == 0x001C90, "Wrong size on AVirtualWeapon");

// Class Mordhau.KickWeapon
// 0x0000 (0x1C90 - 0x1C90)
class AKickWeapon : public AVirtualWeapon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KickWeapon">();
	}
	static class AKickWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKickWeapon>();
	}
};
static_assert(alignof(AKickWeapon) == 0x000010, "Wrong alignment on AKickWeapon");
static_assert(sizeof(AKickWeapon) == 0x001C90, "Wrong size on AKickWeapon");

// Class Mordhau.ArmsWearable
// 0x0018 (0x0240 - 0x0228)
class UArmsWearable : public UMordhauWearable
{
public:
	uint8                                         DefaultHands;                                      // 0x0228(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           HandsWearables;                                    // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void AddHandsWearable(TSoftClassPtr<class UClass> Wearable);
	TSubclassOf<class UMordhauWearable> GetHandsWearable(int32 Index_0);

	int32 GetHandsWearablesNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmsWearable">();
	}
	static class UArmsWearable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmsWearable>();
	}
};
static_assert(alignof(UArmsWearable) == 0x000008, "Wrong alignment on UArmsWearable");
static_assert(sizeof(UArmsWearable) == 0x000240, "Wrong size on UArmsWearable");
static_assert(offsetof(UArmsWearable, DefaultHands) == 0x000228, "Member 'UArmsWearable::DefaultHands' has a wrong offset!");
static_assert(offsetof(UArmsWearable, HandsWearables) == 0x000230, "Member 'UArmsWearable::HandsWearables' has a wrong offset!");

// Class Mordhau.GetMod
// 0x0028 (0x0058 - 0x0030)
class UGetMod final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 ResponseCode, struct FModInfo& Mod)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 ResponseCode, struct FModInfo& Mod)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGetMod* GetMod(int32 ModId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetMod">();
	}
	static class UGetMod* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetMod>();
	}
};
static_assert(alignof(UGetMod) == 0x000008, "Wrong alignment on UGetMod");
static_assert(sizeof(UGetMod) == 0x000058, "Wrong size on UGetMod");
static_assert(offsetof(UGetMod, onSuccess) == 0x000030, "Member 'UGetMod::onSuccess' has a wrong offset!");
static_assert(offsetof(UGetMod, onFailure) == 0x000040, "Member 'UGetMod::onFailure' has a wrong offset!");

// Class Mordhau.SubField
// 0x0018 (0x0238 - 0x0220)
class ASubField : public AActor
{
public:
	class UPrimitiveComponent*                    Area;                                              // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSubFieldDeactivated;                            // 0x0228(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSubFieldHidden;                                 // 0x0229(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A[0x2];                                      // 0x022A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AMasterField>            Master;                                            // 0x022C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginSubFieldDeactivation();
	void DeactivateSubField();
	class AMasterField* GetMaster();
	void SetSubFieldHidden(bool bValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubField">();
	}
	static class ASubField* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASubField>();
	}
};
static_assert(alignof(ASubField) == 0x000008, "Wrong alignment on ASubField");
static_assert(sizeof(ASubField) == 0x000238, "Wrong size on ASubField");
static_assert(offsetof(ASubField, Area) == 0x000220, "Member 'ASubField::Area' has a wrong offset!");
static_assert(offsetof(ASubField, bIsSubFieldDeactivated) == 0x000228, "Member 'ASubField::bIsSubFieldDeactivated' has a wrong offset!");
static_assert(offsetof(ASubField, bIsSubFieldHidden) == 0x000229, "Member 'ASubField::bIsSubFieldHidden' has a wrong offset!");
static_assert(offsetof(ASubField, Master) == 0x00022C, "Member 'ASubField::Master' has a wrong offset!");

// Class Mordhau.Badge
// 0x0008 (0x0068 - 0x0060)
class UBadge : public UMordhauInventoryItem
{
public:
	class UTexture2D*                             Texture;                                           // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Badge">();
	}
	static class UBadge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBadge>();
	}
};
static_assert(alignof(UBadge) == 0x000008, "Wrong alignment on UBadge");
static_assert(sizeof(UBadge) == 0x000068, "Wrong size on UBadge");
static_assert(offsetof(UBadge, Texture) == 0x000060, "Member 'UBadge::Texture' has a wrong offset!");

// Class Mordhau.BanListCommand
// 0x0000 (0x0080 - 0x0080)
class UBanListCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BanListCommand">();
	}
	static class UBanListCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBanListCommand>();
	}
};
static_assert(alignof(UBanListCommand) == 0x000008, "Wrong alignment on UBanListCommand");
static_assert(sizeof(UBanListCommand) == 0x000080, "Wrong size on UBanListCommand");

// Class Mordhau.BaseAttackMotion
// 0x05B8 (0x0658 - 0x00A0)
class UBaseAttackMotion final : public UMordhauMotion
{
public:
	bool                                          bBlendInMultiplicative;                            // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerspectiveFloat                      BlendIn;                                           // 0x00A4(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPerspectiveCurveFloat                 BlendInCurve;                                      // 0x00B0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      SlowBlendIn;                                       // 0x00C0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      ParrySlowBlendIn;                                  // 0x00C8(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      RiposteBlendInWithShield;                          // 0x00D0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class UAnimSequence*, struct FPerspectiveAnimSequenceBaseArray> AnimationMap;                                      // 0x00D8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRotator                               CueAmount;                                         // 0x0128(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CueCurve;                                          // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHighMidLowSpineSpaceAdditive          AngleAdditive;                                     // 0x0140(0x018C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveHighMidLowSpineSpaceAdditive AngleAdditiveWindUp;                               // 0x02CC(0x0318)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ReleaseCurve;                                      // 0x05E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      FeintAnimRate;                                     // 0x05F0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      FeintAnimDurationOffset;                           // 0x05F8(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveFloat                      MinimumFeintAnimDuration;                          // 0x0600(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveCurveFloat                 WorldBounceCurve;                                  // 0x0608(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveCurveFloat                 WorldBounceScaleCurve;                             // 0x0618(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveCurveFloat                 ParryBounceCurve;                                  // 0x0628(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveCurveFloat                 ParryLateBounceCurve;                              // 0x0638(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveCurveFloat                 ParryBounceScaleCurve;                             // 0x0648(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseAttackMotion">();
	}
	static class UBaseAttackMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseAttackMotion>();
	}
};
static_assert(alignof(UBaseAttackMotion) == 0x000008, "Wrong alignment on UBaseAttackMotion");
static_assert(sizeof(UBaseAttackMotion) == 0x000658, "Wrong size on UBaseAttackMotion");
static_assert(offsetof(UBaseAttackMotion, bBlendInMultiplicative) == 0x0000A0, "Member 'UBaseAttackMotion::bBlendInMultiplicative' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, BlendIn) == 0x0000A4, "Member 'UBaseAttackMotion::BlendIn' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, BlendInCurve) == 0x0000B0, "Member 'UBaseAttackMotion::BlendInCurve' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, SlowBlendIn) == 0x0000C0, "Member 'UBaseAttackMotion::SlowBlendIn' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, ParrySlowBlendIn) == 0x0000C8, "Member 'UBaseAttackMotion::ParrySlowBlendIn' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, RiposteBlendInWithShield) == 0x0000D0, "Member 'UBaseAttackMotion::RiposteBlendInWithShield' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, AnimationMap) == 0x0000D8, "Member 'UBaseAttackMotion::AnimationMap' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, CueAmount) == 0x000128, "Member 'UBaseAttackMotion::CueAmount' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, CueCurve) == 0x000138, "Member 'UBaseAttackMotion::CueCurve' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, AngleAdditive) == 0x000140, "Member 'UBaseAttackMotion::AngleAdditive' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, AngleAdditiveWindUp) == 0x0002CC, "Member 'UBaseAttackMotion::AngleAdditiveWindUp' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, ReleaseCurve) == 0x0005E8, "Member 'UBaseAttackMotion::ReleaseCurve' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, FeintAnimRate) == 0x0005F0, "Member 'UBaseAttackMotion::FeintAnimRate' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, FeintAnimDurationOffset) == 0x0005F8, "Member 'UBaseAttackMotion::FeintAnimDurationOffset' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, MinimumFeintAnimDuration) == 0x000600, "Member 'UBaseAttackMotion::MinimumFeintAnimDuration' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, WorldBounceCurve) == 0x000608, "Member 'UBaseAttackMotion::WorldBounceCurve' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, WorldBounceScaleCurve) == 0x000618, "Member 'UBaseAttackMotion::WorldBounceScaleCurve' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, ParryBounceCurve) == 0x000628, "Member 'UBaseAttackMotion::ParryBounceCurve' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, ParryLateBounceCurve) == 0x000638, "Member 'UBaseAttackMotion::ParryLateBounceCurve' has a wrong offset!");
static_assert(offsetof(UBaseAttackMotion, ParryBounceScaleCurve) == 0x000648, "Member 'UBaseAttackMotion::ParryBounceScaleCurve' has a wrong offset!");

// Class Mordhau.BlockedMotion
// 0x01A0 (0x0240 - 0x00A0)
class UBlockedMotion : public UMordhauMotion
{
public:
	EAttackMove                                   FromMove;                                          // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasQueuedMove;                                    // 0x00A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QueuedAngle;                                       // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackMove                                   QueuedMove;                                        // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlockResult                           BlockResult;                                       // 0x00A9(0x0009)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasFadedOutProcedural;                            // 0x00B2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoReleaseBounceProcedural;                        // 0x00B3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           FromAttackMontage;                                 // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QueueWindow;                                       // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QueueWindowHit;                                    // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementRestriction                          MovementRestrictionHit;                            // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementRestriction                          MovementRestrictionWorld;                          // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementRestriction                          OriginalMovementRestriction;                       // 0x00CA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x1];                                       // 0x00CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClashFadeOutTime;                                  // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClashFadeOutTime3P;                                // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StabWorldFadeOutTime;                              // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StabWorldFadeOutTime3P;                            // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StabParryMinMaxRange;                              // 0x00DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StabParryFadeOutTime;                              // 0x00E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StabParryMinMaxRange3P;                            // 0x00EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StabParryFadeOutTime3P;                            // 0x00F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StabChamberedMinMaxRange;                          // 0x00FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StabChamberedFadeOutTime;                          // 0x0104(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StabChamberedMinMaxRange3P;                        // 0x010C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StabChamberedFadeOutTime3P;                        // 0x0114(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParriedRecoveryTimeOffset;                         // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ParriedRecoveryTimeLimits;                         // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChamberedRecoveryTimeOffset;                       // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ChamberedRecoveryTimeLimits;                       // 0x012C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ProceduralHitStopBounceCurve;                      // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProceduralHitStopBounceScaleCurve;                 // 0x0140(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProceduralHitStopReleaseScaleCurve;                // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProceduralHitStopBounceCurve3P;                    // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProceduralHitStopBounceScaleCurve3P;               // 0x0158(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ProceduralHitStopReleaseScaleCurve3P;              // 0x0160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralHitStopTimeUntilFade;                    // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralHitStopBounceDuration;                   // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralHitStopFadeOutTime;                      // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralHitStopTimeUntilFade3P;                  // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralHitStopBounceDuration3P;                 // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralHitStopFadeOutTime3P;                    // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StabHitStopFadeOutTime;                            // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StabHitStopFadeOutTime3P;                          // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickHitStopBlendOutTime;                           // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickHitStopAnimRate;                               // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldRecoveryTime;                                 // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldMissStaminaFactor;                            // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ReleaseScaleCurve;                                 // 0x0198(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ReleaseScaleCurve3P;                               // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralParryMinMaxRange;                        // 0x01A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralParryTimeUntilFade;                      // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralParryBounceDuration;                     // 0x01B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralParryFadeOutTime;                        // 0x01C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralChamberMinMaxRange;                      // 0x01C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralChamberTimeUntilFade;                    // 0x01D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralChamberBounceDuration;                   // 0x01D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralChamberFadeOutTime;                      // 0x01E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralWorldTimeUntilFade;                      // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralWorldBounceDuration;                     // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralWorldFadeOutTime;                        // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralParryMinMaxRange3P;                      // 0x01F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralParryTimeUntilFade3P;                    // 0x01FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralParryBounceDuration3P;                   // 0x0204(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralParryFadeOutTime3P;                      // 0x020C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralChamberMinMaxRange3P;                    // 0x0214(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralChamberTimeUntilFade3P;                  // 0x021C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralChamberBounceDuration3P;                 // 0x0224(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ProceduralChamberFadeOutTime3P;                    // 0x022C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralWorldTimeUntilFade3P;                    // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralWorldBounceDuration3P;                   // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralWorldFadeOutTime3P;                      // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockedMotion">();
	}
	static class UBlockedMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockedMotion>();
	}
};
static_assert(alignof(UBlockedMotion) == 0x000008, "Wrong alignment on UBlockedMotion");
static_assert(sizeof(UBlockedMotion) == 0x000240, "Wrong size on UBlockedMotion");
static_assert(offsetof(UBlockedMotion, FromMove) == 0x0000A0, "Member 'UBlockedMotion::FromMove' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, bHasQueuedMove) == 0x0000A1, "Member 'UBlockedMotion::bHasQueuedMove' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, QueuedAngle) == 0x0000A4, "Member 'UBlockedMotion::QueuedAngle' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, QueuedMove) == 0x0000A8, "Member 'UBlockedMotion::QueuedMove' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, BlockResult) == 0x0000A9, "Member 'UBlockedMotion::BlockResult' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, bHasFadedOutProcedural) == 0x0000B2, "Member 'UBlockedMotion::bHasFadedOutProcedural' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, bDoReleaseBounceProcedural) == 0x0000B3, "Member 'UBlockedMotion::bDoReleaseBounceProcedural' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, FromAttackMontage) == 0x0000B8, "Member 'UBlockedMotion::FromAttackMontage' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, QueueWindow) == 0x0000C0, "Member 'UBlockedMotion::QueueWindow' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, QueueWindowHit) == 0x0000C4, "Member 'UBlockedMotion::QueueWindowHit' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, MovementRestrictionHit) == 0x0000C8, "Member 'UBlockedMotion::MovementRestrictionHit' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, MovementRestrictionWorld) == 0x0000C9, "Member 'UBlockedMotion::MovementRestrictionWorld' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, OriginalMovementRestriction) == 0x0000CA, "Member 'UBlockedMotion::OriginalMovementRestriction' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ClashFadeOutTime) == 0x0000CC, "Member 'UBlockedMotion::ClashFadeOutTime' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ClashFadeOutTime3P) == 0x0000D0, "Member 'UBlockedMotion::ClashFadeOutTime3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, StabWorldFadeOutTime) == 0x0000D4, "Member 'UBlockedMotion::StabWorldFadeOutTime' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, StabWorldFadeOutTime3P) == 0x0000D8, "Member 'UBlockedMotion::StabWorldFadeOutTime3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, StabParryMinMaxRange) == 0x0000DC, "Member 'UBlockedMotion::StabParryMinMaxRange' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, StabParryFadeOutTime) == 0x0000E4, "Member 'UBlockedMotion::StabParryFadeOutTime' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, StabParryMinMaxRange3P) == 0x0000EC, "Member 'UBlockedMotion::StabParryMinMaxRange3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, StabParryFadeOutTime3P) == 0x0000F4, "Member 'UBlockedMotion::StabParryFadeOutTime3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, StabChamberedMinMaxRange) == 0x0000FC, "Member 'UBlockedMotion::StabChamberedMinMaxRange' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, StabChamberedFadeOutTime) == 0x000104, "Member 'UBlockedMotion::StabChamberedFadeOutTime' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, StabChamberedMinMaxRange3P) == 0x00010C, "Member 'UBlockedMotion::StabChamberedMinMaxRange3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, StabChamberedFadeOutTime3P) == 0x000114, "Member 'UBlockedMotion::StabChamberedFadeOutTime3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ParriedRecoveryTimeOffset) == 0x00011C, "Member 'UBlockedMotion::ParriedRecoveryTimeOffset' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ParriedRecoveryTimeLimits) == 0x000120, "Member 'UBlockedMotion::ParriedRecoveryTimeLimits' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ChamberedRecoveryTimeOffset) == 0x000128, "Member 'UBlockedMotion::ChamberedRecoveryTimeOffset' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ChamberedRecoveryTimeLimits) == 0x00012C, "Member 'UBlockedMotion::ChamberedRecoveryTimeLimits' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralHitStopBounceCurve) == 0x000138, "Member 'UBlockedMotion::ProceduralHitStopBounceCurve' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralHitStopBounceScaleCurve) == 0x000140, "Member 'UBlockedMotion::ProceduralHitStopBounceScaleCurve' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralHitStopReleaseScaleCurve) == 0x000148, "Member 'UBlockedMotion::ProceduralHitStopReleaseScaleCurve' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralHitStopBounceCurve3P) == 0x000150, "Member 'UBlockedMotion::ProceduralHitStopBounceCurve3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralHitStopBounceScaleCurve3P) == 0x000158, "Member 'UBlockedMotion::ProceduralHitStopBounceScaleCurve3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralHitStopReleaseScaleCurve3P) == 0x000160, "Member 'UBlockedMotion::ProceduralHitStopReleaseScaleCurve3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralHitStopTimeUntilFade) == 0x000168, "Member 'UBlockedMotion::ProceduralHitStopTimeUntilFade' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralHitStopBounceDuration) == 0x00016C, "Member 'UBlockedMotion::ProceduralHitStopBounceDuration' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralHitStopFadeOutTime) == 0x000170, "Member 'UBlockedMotion::ProceduralHitStopFadeOutTime' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralHitStopTimeUntilFade3P) == 0x000174, "Member 'UBlockedMotion::ProceduralHitStopTimeUntilFade3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralHitStopBounceDuration3P) == 0x000178, "Member 'UBlockedMotion::ProceduralHitStopBounceDuration3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralHitStopFadeOutTime3P) == 0x00017C, "Member 'UBlockedMotion::ProceduralHitStopFadeOutTime3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, StabHitStopFadeOutTime) == 0x000180, "Member 'UBlockedMotion::StabHitStopFadeOutTime' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, StabHitStopFadeOutTime3P) == 0x000184, "Member 'UBlockedMotion::StabHitStopFadeOutTime3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, KickHitStopBlendOutTime) == 0x000188, "Member 'UBlockedMotion::KickHitStopBlendOutTime' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, KickHitStopAnimRate) == 0x00018C, "Member 'UBlockedMotion::KickHitStopAnimRate' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, WorldRecoveryTime) == 0x000190, "Member 'UBlockedMotion::WorldRecoveryTime' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, WorldMissStaminaFactor) == 0x000194, "Member 'UBlockedMotion::WorldMissStaminaFactor' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ReleaseScaleCurve) == 0x000198, "Member 'UBlockedMotion::ReleaseScaleCurve' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ReleaseScaleCurve3P) == 0x0001A0, "Member 'UBlockedMotion::ReleaseScaleCurve3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralParryMinMaxRange) == 0x0001A8, "Member 'UBlockedMotion::ProceduralParryMinMaxRange' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralParryTimeUntilFade) == 0x0001B0, "Member 'UBlockedMotion::ProceduralParryTimeUntilFade' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralParryBounceDuration) == 0x0001B8, "Member 'UBlockedMotion::ProceduralParryBounceDuration' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralParryFadeOutTime) == 0x0001C0, "Member 'UBlockedMotion::ProceduralParryFadeOutTime' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralChamberMinMaxRange) == 0x0001C8, "Member 'UBlockedMotion::ProceduralChamberMinMaxRange' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralChamberTimeUntilFade) == 0x0001D0, "Member 'UBlockedMotion::ProceduralChamberTimeUntilFade' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralChamberBounceDuration) == 0x0001D8, "Member 'UBlockedMotion::ProceduralChamberBounceDuration' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralChamberFadeOutTime) == 0x0001E0, "Member 'UBlockedMotion::ProceduralChamberFadeOutTime' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralWorldTimeUntilFade) == 0x0001E8, "Member 'UBlockedMotion::ProceduralWorldTimeUntilFade' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralWorldBounceDuration) == 0x0001EC, "Member 'UBlockedMotion::ProceduralWorldBounceDuration' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralWorldFadeOutTime) == 0x0001F0, "Member 'UBlockedMotion::ProceduralWorldFadeOutTime' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralParryMinMaxRange3P) == 0x0001F4, "Member 'UBlockedMotion::ProceduralParryMinMaxRange3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralParryTimeUntilFade3P) == 0x0001FC, "Member 'UBlockedMotion::ProceduralParryTimeUntilFade3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralParryBounceDuration3P) == 0x000204, "Member 'UBlockedMotion::ProceduralParryBounceDuration3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralParryFadeOutTime3P) == 0x00020C, "Member 'UBlockedMotion::ProceduralParryFadeOutTime3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralChamberMinMaxRange3P) == 0x000214, "Member 'UBlockedMotion::ProceduralChamberMinMaxRange3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralChamberTimeUntilFade3P) == 0x00021C, "Member 'UBlockedMotion::ProceduralChamberTimeUntilFade3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralChamberBounceDuration3P) == 0x000224, "Member 'UBlockedMotion::ProceduralChamberBounceDuration3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralChamberFadeOutTime3P) == 0x00022C, "Member 'UBlockedMotion::ProceduralChamberFadeOutTime3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralWorldTimeUntilFade3P) == 0x000234, "Member 'UBlockedMotion::ProceduralWorldTimeUntilFade3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralWorldBounceDuration3P) == 0x000238, "Member 'UBlockedMotion::ProceduralWorldBounceDuration3P' has a wrong offset!");
static_assert(offsetof(UBlockedMotion, ProceduralWorldFadeOutTime3P) == 0x00023C, "Member 'UBlockedMotion::ProceduralWorldFadeOutTime3P' has a wrong offset!");

// Class Mordhau.BotBehaviorProfile
// 0x00D0 (0x00F8 - 0x0028)
class UBotBehaviorProfile : public UObject
{
public:
	int32                                         DefaultTeam;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FriendlyFireVoiceChance;                           // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HurtHelpVoiceChance;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WasDisarmedHelpVoiceChance;                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisarmedLaughVoiceChance;                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThanksOnAssistVoiceChance;                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespectOnKillVoiceChance;                          // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IgnoreEnemiesWithAllyCount;                        // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangedEngageDistanceFactor;                        // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RangedAccuracyDegreesMinMax;                       // 0x004C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RangedAccuracyDistanceMinMax;                      // 0x0054(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrefersAltMode;                                   // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              BackOffFactorDuringDefenseMinMax;                  // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseAttackHesitanceTime;                           // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackHesitanceVariance;                           // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootworkInsteadOfParryProbability;                 // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootworkWithCrouchProbability;                     // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ParryTimingVariance;                               // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectParryProbability;                           // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FeintTimingVariance;                               // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallForFeintProbability;                           // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfRangeFeintProbability;                        // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ComboProbability;                                  // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragProbability;                                   // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelProbability;                                  // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChamberProbability;                                // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MorphProbability;                                  // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GambleProbability;                                 // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FeintProbability;                                  // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RiposteProbability;                                // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrawlProbability;                                  // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTurnRate;                                       // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLookUpRate;                                     // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Random2DUnitVector;                                // 0x00BC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillBrawl;                                        // 0x00C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillRegularAttack;                                // 0x00C5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillRiposte;                                      // 0x00C6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C7[0x1];                                       // 0x00C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BackOffFactorDuringDefense;                        // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillFeint;                                        // 0x00CC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillOutOfRangeFeint;                              // 0x00CD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillGamble;                                       // 0x00CE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillMorph;                                        // 0x00CF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillChamber;                                      // 0x00D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillAccel;                                        // 0x00D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillDrag;                                         // 0x00D2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillCombo;                                        // 0x00D3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillFallForFeint;                                 // 0x00D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FeintTimingRandom;                                 // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillPerfectParry;                                 // 0x00DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ParryTimingRandom;                                 // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillFootwork;                                     // 0x00E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillFootworkWithCrouch;                           // 0x00E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E6[0x2];                                       // 0x00E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UMordhauMotion>          LastFootworkingEnemyMotion;                        // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackHesitanceRandom;                             // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotBehaviorProfile">();
	}
	static class UBotBehaviorProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotBehaviorProfile>();
	}
};
static_assert(alignof(UBotBehaviorProfile) == 0x000008, "Wrong alignment on UBotBehaviorProfile");
static_assert(sizeof(UBotBehaviorProfile) == 0x0000F8, "Wrong size on UBotBehaviorProfile");
static_assert(offsetof(UBotBehaviorProfile, DefaultTeam) == 0x000028, "Member 'UBotBehaviorProfile::DefaultTeam' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, FriendlyFireVoiceChance) == 0x00002C, "Member 'UBotBehaviorProfile::FriendlyFireVoiceChance' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, HurtHelpVoiceChance) == 0x000030, "Member 'UBotBehaviorProfile::HurtHelpVoiceChance' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, WasDisarmedHelpVoiceChance) == 0x000034, "Member 'UBotBehaviorProfile::WasDisarmedHelpVoiceChance' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, DisarmedLaughVoiceChance) == 0x000038, "Member 'UBotBehaviorProfile::DisarmedLaughVoiceChance' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, ThanksOnAssistVoiceChance) == 0x00003C, "Member 'UBotBehaviorProfile::ThanksOnAssistVoiceChance' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, RespectOnKillVoiceChance) == 0x000040, "Member 'UBotBehaviorProfile::RespectOnKillVoiceChance' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, IgnoreEnemiesWithAllyCount) == 0x000044, "Member 'UBotBehaviorProfile::IgnoreEnemiesWithAllyCount' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, RangedEngageDistanceFactor) == 0x000048, "Member 'UBotBehaviorProfile::RangedEngageDistanceFactor' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, RangedAccuracyDegreesMinMax) == 0x00004C, "Member 'UBotBehaviorProfile::RangedAccuracyDegreesMinMax' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, RangedAccuracyDistanceMinMax) == 0x000054, "Member 'UBotBehaviorProfile::RangedAccuracyDistanceMinMax' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bPrefersAltMode) == 0x00005C, "Member 'UBotBehaviorProfile::bPrefersAltMode' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, BackOffFactorDuringDefenseMinMax) == 0x000060, "Member 'UBotBehaviorProfile::BackOffFactorDuringDefenseMinMax' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, BaseAttackHesitanceTime) == 0x000068, "Member 'UBotBehaviorProfile::BaseAttackHesitanceTime' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, AttackHesitanceVariance) == 0x00006C, "Member 'UBotBehaviorProfile::AttackHesitanceVariance' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, FootworkInsteadOfParryProbability) == 0x000070, "Member 'UBotBehaviorProfile::FootworkInsteadOfParryProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, FootworkWithCrouchProbability) == 0x000074, "Member 'UBotBehaviorProfile::FootworkWithCrouchProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, ParryTimingVariance) == 0x000078, "Member 'UBotBehaviorProfile::ParryTimingVariance' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, PerfectParryProbability) == 0x000080, "Member 'UBotBehaviorProfile::PerfectParryProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, FeintTimingVariance) == 0x000084, "Member 'UBotBehaviorProfile::FeintTimingVariance' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, FallForFeintProbability) == 0x000088, "Member 'UBotBehaviorProfile::FallForFeintProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, OutOfRangeFeintProbability) == 0x00008C, "Member 'UBotBehaviorProfile::OutOfRangeFeintProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, ComboProbability) == 0x000090, "Member 'UBotBehaviorProfile::ComboProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, DragProbability) == 0x000094, "Member 'UBotBehaviorProfile::DragProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, AccelProbability) == 0x000098, "Member 'UBotBehaviorProfile::AccelProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, ChamberProbability) == 0x00009C, "Member 'UBotBehaviorProfile::ChamberProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, MorphProbability) == 0x0000A0, "Member 'UBotBehaviorProfile::MorphProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, GambleProbability) == 0x0000A4, "Member 'UBotBehaviorProfile::GambleProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, FeintProbability) == 0x0000A8, "Member 'UBotBehaviorProfile::FeintProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, RiposteProbability) == 0x0000AC, "Member 'UBotBehaviorProfile::RiposteProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, BrawlProbability) == 0x0000B0, "Member 'UBotBehaviorProfile::BrawlProbability' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, MaxTurnRate) == 0x0000B4, "Member 'UBotBehaviorProfile::MaxTurnRate' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, MaxLookUpRate) == 0x0000B8, "Member 'UBotBehaviorProfile::MaxLookUpRate' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, Random2DUnitVector) == 0x0000BC, "Member 'UBotBehaviorProfile::Random2DUnitVector' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillBrawl) == 0x0000C4, "Member 'UBotBehaviorProfile::bWillBrawl' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillRegularAttack) == 0x0000C5, "Member 'UBotBehaviorProfile::bWillRegularAttack' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillRiposte) == 0x0000C6, "Member 'UBotBehaviorProfile::bWillRiposte' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, BackOffFactorDuringDefense) == 0x0000C8, "Member 'UBotBehaviorProfile::BackOffFactorDuringDefense' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillFeint) == 0x0000CC, "Member 'UBotBehaviorProfile::bWillFeint' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillOutOfRangeFeint) == 0x0000CD, "Member 'UBotBehaviorProfile::bWillOutOfRangeFeint' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillGamble) == 0x0000CE, "Member 'UBotBehaviorProfile::bWillGamble' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillMorph) == 0x0000CF, "Member 'UBotBehaviorProfile::bWillMorph' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillChamber) == 0x0000D0, "Member 'UBotBehaviorProfile::bWillChamber' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillAccel) == 0x0000D1, "Member 'UBotBehaviorProfile::bWillAccel' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillDrag) == 0x0000D2, "Member 'UBotBehaviorProfile::bWillDrag' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillCombo) == 0x0000D3, "Member 'UBotBehaviorProfile::bWillCombo' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillFallForFeint) == 0x0000D4, "Member 'UBotBehaviorProfile::bWillFallForFeint' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, FeintTimingRandom) == 0x0000D8, "Member 'UBotBehaviorProfile::FeintTimingRandom' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillPerfectParry) == 0x0000DC, "Member 'UBotBehaviorProfile::bWillPerfectParry' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, ParryTimingRandom) == 0x0000E0, "Member 'UBotBehaviorProfile::ParryTimingRandom' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillFootwork) == 0x0000E4, "Member 'UBotBehaviorProfile::bWillFootwork' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, bWillFootworkWithCrouch) == 0x0000E5, "Member 'UBotBehaviorProfile::bWillFootworkWithCrouch' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, LastFootworkingEnemyMotion) == 0x0000E8, "Member 'UBotBehaviorProfile::LastFootworkingEnemyMotion' has a wrong offset!");
static_assert(offsetof(UBotBehaviorProfile, AttackHesitanceRandom) == 0x0000F0, "Member 'UBotBehaviorProfile::AttackHesitanceRandom' has a wrong offset!");

// Class Mordhau.LogCommand
// 0x0050 (0x00D0 - 0x0080)
class ULogCommand final : public URconCommand
{
public:
	uint8                                         Pad_80[0x50];                                      // 0x0080(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogCommand">();
	}
	static class ULogCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogCommand>();
	}
};
static_assert(alignof(ULogCommand) == 0x000008, "Wrong alignment on ULogCommand");
static_assert(sizeof(ULogCommand) == 0x0000D0, "Wrong size on ULogCommand");

// Class Mordhau.BotCommands
// 0x0000 (0x0080 - 0x0080)
class UBotCommands final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotCommands">();
	}
	static class UBotCommands* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotCommands>();
	}
};
static_assert(alignof(UBotCommands) == 0x000008, "Wrong alignment on UBotCommands");
static_assert(sizeof(UBotCommands) == 0x000080, "Wrong size on UBotCommands");

// Class Mordhau.BotProfile
// 0x00E0 (0x0108 - 0x0028)
class UBotProfile : public UObject
{
public:
	class FString                                 BotName;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseBotLoadoutProfileID;                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomBotLoadoutProfileID;                     // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterProfile                      CharacterProfile;                                  // 0x0040(0x00B8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UBotBehaviorProfile>        BehaviorProfile;                                   // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeBehavior;                                // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeName;                                    // 0x0101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeAppearance;                              // 0x0102(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeFace;                                    // 0x0103(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeVoice;                                   // 0x0104(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeSkills;                                  // 0x0105(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeEquipment;                               // 0x0106(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomizeWearables;                               // 0x0107(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AssignToController(class AMordhauAIController* Controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BotProfile">();
	}
	static class UBotProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBotProfile>();
	}
};
static_assert(alignof(UBotProfile) == 0x000008, "Wrong alignment on UBotProfile");
static_assert(sizeof(UBotProfile) == 0x000108, "Wrong size on UBotProfile");
static_assert(offsetof(UBotProfile, BotName) == 0x000028, "Member 'UBotProfile::BotName' has a wrong offset!");
static_assert(offsetof(UBotProfile, UseBotLoadoutProfileID) == 0x000038, "Member 'UBotProfile::UseBotLoadoutProfileID' has a wrong offset!");
static_assert(offsetof(UBotProfile, bUseRandomBotLoadoutProfileID) == 0x00003C, "Member 'UBotProfile::bUseRandomBotLoadoutProfileID' has a wrong offset!");
static_assert(offsetof(UBotProfile, CharacterProfile) == 0x000040, "Member 'UBotProfile::CharacterProfile' has a wrong offset!");
static_assert(offsetof(UBotProfile, BehaviorProfile) == 0x0000F8, "Member 'UBotProfile::BehaviorProfile' has a wrong offset!");
static_assert(offsetof(UBotProfile, bRandomizeBehavior) == 0x000100, "Member 'UBotProfile::bRandomizeBehavior' has a wrong offset!");
static_assert(offsetof(UBotProfile, bRandomizeName) == 0x000101, "Member 'UBotProfile::bRandomizeName' has a wrong offset!");
static_assert(offsetof(UBotProfile, bRandomizeAppearance) == 0x000102, "Member 'UBotProfile::bRandomizeAppearance' has a wrong offset!");
static_assert(offsetof(UBotProfile, bRandomizeFace) == 0x000103, "Member 'UBotProfile::bRandomizeFace' has a wrong offset!");
static_assert(offsetof(UBotProfile, bRandomizeVoice) == 0x000104, "Member 'UBotProfile::bRandomizeVoice' has a wrong offset!");
static_assert(offsetof(UBotProfile, bRandomizeSkills) == 0x000105, "Member 'UBotProfile::bRandomizeSkills' has a wrong offset!");
static_assert(offsetof(UBotProfile, bRandomizeEquipment) == 0x000106, "Member 'UBotProfile::bRandomizeEquipment' has a wrong offset!");
static_assert(offsetof(UBotProfile, bRandomizeWearables) == 0x000107, "Member 'UBotProfile::bRandomizeWearables' has a wrong offset!");

// Class Mordhau.MordhauAnimMetaData
// 0x0030 (0x0058 - 0x0028)
class UMordhauAnimMetaData final : public UAnimMetaData
{
public:
	float                                         OverrideIdleChangeBlendTime;                       // 0x0028(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablesSpineBending;                             // 0x002C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablesAtmospherics;                             // 0x002D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceCinematicCameraWeight;                        // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablesOffhandIK;                                // 0x0034(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForcesOffhandIK;                                  // 0x0035(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverridesOffhandIKChangeSpeed;                    // 0x0036(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffhandIKChangeSpeedOverride;                      // 0x0038(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOffhandIKDistance;                              // 0x003C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinOffhandIKDistance;                              // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablesSpineArmsCompensation;                    // 0x0044(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ParamA;                                            // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamB;                                            // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamC;                                            // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamD;                                            // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauAnimMetaData">();
	}
	static class UMordhauAnimMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauAnimMetaData>();
	}
};
static_assert(alignof(UMordhauAnimMetaData) == 0x000008, "Wrong alignment on UMordhauAnimMetaData");
static_assert(sizeof(UMordhauAnimMetaData) == 0x000058, "Wrong size on UMordhauAnimMetaData");
static_assert(offsetof(UMordhauAnimMetaData, OverrideIdleChangeBlendTime) == 0x000028, "Member 'UMordhauAnimMetaData::OverrideIdleChangeBlendTime' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, bDisablesSpineBending) == 0x00002C, "Member 'UMordhauAnimMetaData::bDisablesSpineBending' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, bDisablesAtmospherics) == 0x00002D, "Member 'UMordhauAnimMetaData::bDisablesAtmospherics' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, ForceCinematicCameraWeight) == 0x000030, "Member 'UMordhauAnimMetaData::ForceCinematicCameraWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, bDisablesOffhandIK) == 0x000034, "Member 'UMordhauAnimMetaData::bDisablesOffhandIK' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, bForcesOffhandIK) == 0x000035, "Member 'UMordhauAnimMetaData::bForcesOffhandIK' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, bOverridesOffhandIKChangeSpeed) == 0x000036, "Member 'UMordhauAnimMetaData::bOverridesOffhandIKChangeSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, OffhandIKChangeSpeedOverride) == 0x000038, "Member 'UMordhauAnimMetaData::OffhandIKChangeSpeedOverride' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, MaxOffhandIKDistance) == 0x00003C, "Member 'UMordhauAnimMetaData::MaxOffhandIKDistance' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, MinOffhandIKDistance) == 0x000040, "Member 'UMordhauAnimMetaData::MinOffhandIKDistance' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, bDisablesSpineArmsCompensation) == 0x000044, "Member 'UMordhauAnimMetaData::bDisablesSpineArmsCompensation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, ParamA) == 0x000048, "Member 'UMordhauAnimMetaData::ParamA' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, ParamB) == 0x00004C, "Member 'UMordhauAnimMetaData::ParamB' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, ParamC) == 0x000050, "Member 'UMordhauAnimMetaData::ParamC' has a wrong offset!");
static_assert(offsetof(UMordhauAnimMetaData, ParamD) == 0x000054, "Member 'UMordhauAnimMetaData::ParamD' has a wrong offset!");

// Class Mordhau.Bounds
// 0x0000 (0x0028 - 0x0028)
class IBounds final : public IInterface
{
public:
	void EnteredOutOfBoundsArea(const class UObject* WCO);
	void LeftOutOfBoundsArea();
	void OnExceededTimeOutOfBounds();

	float GetOutOfBoundsTimeUntilDeath() const;
	bool IsAllowedOutOfBounds() const;
	bool IsOutOfBounds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Bounds">();
	}
	static class IBounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBounds>();
	}
};
static_assert(alignof(IBounds) == 0x000008, "Wrong alignment on IBounds");
static_assert(sizeof(IBounds) == 0x000028, "Wrong size on IBounds");

// Class Mordhau.BTTask_Experimental
// 0x0008 (0x0078 - 0x0070)
class UBTTask_Experimental final : public UBTTaskNode
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_Experimental">();
	}
	static class UBTTask_Experimental* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_Experimental>();
	}
};
static_assert(alignof(UBTTask_Experimental) == 0x000008, "Wrong alignment on UBTTask_Experimental");
static_assert(sizeof(UBTTask_Experimental) == 0x000078, "Wrong size on UBTTask_Experimental");

// Class Mordhau.BTTask_FallForFeint
// 0x0000 (0x0070 - 0x0070)
class UBTTask_FallForFeint final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FallForFeint">();
	}
	static class UBTTask_FallForFeint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FallForFeint>();
	}
};
static_assert(alignof(UBTTask_FallForFeint) == 0x000008, "Wrong alignment on UBTTask_FallForFeint");
static_assert(sizeof(UBTTask_FallForFeint) == 0x000070, "Wrong size on UBTTask_FallForFeint");

// Class Mordhau.MapMetadataBase
// 0x0070 (0x0098 - 0x0028)
class UMapMetadataBase : public UObject
{
public:
	class FText                                   Name_0;                                            // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                Maps;                                              // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        Thumbnail;                                         // 0x0050(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                BackgroundImages;                                  // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                ForegroundImages;                                  // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           Tips;                                              // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMetadataBase">();
	}
	static class UMapMetadataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMetadataBase>();
	}
};
static_assert(alignof(UMapMetadataBase) == 0x000008, "Wrong alignment on UMapMetadataBase");
static_assert(sizeof(UMapMetadataBase) == 0x000098, "Wrong size on UMapMetadataBase");
static_assert(offsetof(UMapMetadataBase, Name_0) == 0x000028, "Member 'UMapMetadataBase::Name_0' has a wrong offset!");
static_assert(offsetof(UMapMetadataBase, Maps) == 0x000040, "Member 'UMapMetadataBase::Maps' has a wrong offset!");
static_assert(offsetof(UMapMetadataBase, Thumbnail) == 0x000050, "Member 'UMapMetadataBase::Thumbnail' has a wrong offset!");
static_assert(offsetof(UMapMetadataBase, BackgroundImages) == 0x000068, "Member 'UMapMetadataBase::BackgroundImages' has a wrong offset!");
static_assert(offsetof(UMapMetadataBase, ForegroundImages) == 0x000078, "Member 'UMapMetadataBase::ForegroundImages' has a wrong offset!");
static_assert(offsetof(UMapMetadataBase, Tips) == 0x000088, "Member 'UMapMetadataBase::Tips' has a wrong offset!");

// Class Mordhau.MapMetadata
// 0x0010 (0x00A8 - 0x0098)
class UMapMetadata : public UMapMetadataBase
{
public:
	TArray<TSubclassOf<class UMapMetadataOverride>> Overrides;                                         // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMetadata">();
	}
	static class UMapMetadata* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMetadata>();
	}
};
static_assert(alignof(UMapMetadata) == 0x000008, "Wrong alignment on UMapMetadata");
static_assert(sizeof(UMapMetadata) == 0x0000A8, "Wrong size on UMapMetadata");
static_assert(offsetof(UMapMetadata, Overrides) == 0x000098, "Member 'UMapMetadata::Overrides' has a wrong offset!");

// Class Mordhau.BTTask_MeleeAttack
// 0x0000 (0x0070 - 0x0070)
class UBTTask_MeleeAttack final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MeleeAttack">();
	}
	static class UBTTask_MeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MeleeAttack>();
	}
};
static_assert(alignof(UBTTask_MeleeAttack) == 0x000008, "Wrong alignment on UBTTask_MeleeAttack");
static_assert(sizeof(UBTTask_MeleeAttack) == 0x000070, "Wrong size on UBTTask_MeleeAttack");

// Class Mordhau.BTTask_MeleeDefend
// 0x0000 (0x0070 - 0x0070)
class UBTTask_MeleeDefend final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MeleeDefend">();
	}
	static class UBTTask_MeleeDefend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MeleeDefend>();
	}
};
static_assert(alignof(UBTTask_MeleeDefend) == 0x000008, "Wrong alignment on UBTTask_MeleeDefend");
static_assert(sizeof(UBTTask_MeleeDefend) == 0x000070, "Wrong size on UBTTask_MeleeDefend");

// Class Mordhau.LODSkeletalMeshComponent
// 0x00C0 (0x0F90 - 0x0ED0)
class ULODSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
	uint8                                         Pad_ED0[0x88];                                     // 0x0ED0(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LODDeltaTime;                                      // 0x0F58(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastLODDeltaTime;                                  // 0x0F5C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSkippedThisFrame;                              // 0x0F60(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F61[0x3];                                      // 0x0F61(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FramesSinceLastLODTick;                            // 0x0F64(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FramesUntilNextLODTick;                            // 0x0F68(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBoneRadiusBounds;                              // 0x0F6C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F6D[0x3];                                      // 0x0F6D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneRadiusBoundsBoneName;                          // 0x0F70(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoneRadiusBoundsRadius;                            // 0x0F78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLODDeltaTime;                                   // 0x0F7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothClothLODTransition;                         // 0x0F80(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F81[0x3];                                      // 0x0F81(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClothLODTransitionSpeed;                           // 0x0F84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipTransformUpdate;                              // 0x0F88(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventTicking;                                   // 0x0F89(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateLODIfPreventTicking;                        // 0x0F8A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceNextTick;                                    // 0x0F8B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8C[0x4];                                      // 0x0F8C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LODSkeletalMeshComponent">();
	}
	static class ULODSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULODSkeletalMeshComponent>();
	}
};
static_assert(alignof(ULODSkeletalMeshComponent) == 0x000010, "Wrong alignment on ULODSkeletalMeshComponent");
static_assert(sizeof(ULODSkeletalMeshComponent) == 0x000F90, "Wrong size on ULODSkeletalMeshComponent");
static_assert(offsetof(ULODSkeletalMeshComponent, LODDeltaTime) == 0x000F58, "Member 'ULODSkeletalMeshComponent::LODDeltaTime' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, LastLODDeltaTime) == 0x000F5C, "Member 'ULODSkeletalMeshComponent::LastLODDeltaTime' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, bHasSkippedThisFrame) == 0x000F60, "Member 'ULODSkeletalMeshComponent::bHasSkippedThisFrame' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, FramesSinceLastLODTick) == 0x000F64, "Member 'ULODSkeletalMeshComponent::FramesSinceLastLODTick' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, FramesUntilNextLODTick) == 0x000F68, "Member 'ULODSkeletalMeshComponent::FramesUntilNextLODTick' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, bUseBoneRadiusBounds) == 0x000F6C, "Member 'ULODSkeletalMeshComponent::bUseBoneRadiusBounds' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, BoneRadiusBoundsBoneName) == 0x000F70, "Member 'ULODSkeletalMeshComponent::BoneRadiusBoundsBoneName' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, BoneRadiusBoundsRadius) == 0x000F78, "Member 'ULODSkeletalMeshComponent::BoneRadiusBoundsRadius' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, MaxLODDeltaTime) == 0x000F7C, "Member 'ULODSkeletalMeshComponent::MaxLODDeltaTime' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, bSmoothClothLODTransition) == 0x000F80, "Member 'ULODSkeletalMeshComponent::bSmoothClothLODTransition' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, ClothLODTransitionSpeed) == 0x000F84, "Member 'ULODSkeletalMeshComponent::ClothLODTransitionSpeed' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, bSkipTransformUpdate) == 0x000F88, "Member 'ULODSkeletalMeshComponent::bSkipTransformUpdate' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, bPreventTicking) == 0x000F89, "Member 'ULODSkeletalMeshComponent::bPreventTicking' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, bUpdateLODIfPreventTicking) == 0x000F8A, "Member 'ULODSkeletalMeshComponent::bUpdateLODIfPreventTicking' has a wrong offset!");
static_assert(offsetof(ULODSkeletalMeshComponent, bForceNextTick) == 0x000F8B, "Member 'ULODSkeletalMeshComponent::bForceNextTick' has a wrong offset!");

// Class Mordhau.CharacterMeshComponent
// 0x00C0 (0x1050 - 0x0F90)
class UCharacterMeshComponent : public ULODSkeletalMeshComponent
{
public:
	uint8                                         Pad_F90[0x20];                                     // 0x0F90(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         MaxWounds;                                         // 0x0FB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB1[0x7];                                      // 0x0FB1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USkeletalMeshComponent*>         BloodReceivingSkeletalMeshes;                      // 0x0FB8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   BloodIntensityParamName;                           // 0x0FC8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD0[0x28];                                     // 0x0FD0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          RagdollFallingFromPhysicsAsset;                    // 0x0FF8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RagdollFallingProfileName;                         // 0x1000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          RagdollFallingPhysicsAsset;                        // 0x1008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollFallingBlendOutSpeed;                       // 0x1010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RagdollFallingApplyForce;                          // 0x1014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RagdollFallingApplyForceAir;                       // 0x1020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RagdollFallingApplyForceBoneName;                  // 0x102C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1034[0xC];                                     // 0x1034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UMaterialInstanceDynamic>> DissolveMaterialInstances;                         // 0x1040(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void OnCharacterDied(class AAdvancedCharacter* Character);
	void OnCharacterLODTick(float DeltaTime);
	void OnCharacterStartedRagdollFalling();
	void OnCharacterStoppedRagdollFalling();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterMeshComponent">();
	}
	static class UCharacterMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterMeshComponent>();
	}
};
static_assert(alignof(UCharacterMeshComponent) == 0x000010, "Wrong alignment on UCharacterMeshComponent");
static_assert(sizeof(UCharacterMeshComponent) == 0x001050, "Wrong size on UCharacterMeshComponent");
static_assert(offsetof(UCharacterMeshComponent, MaxWounds) == 0x000FB0, "Member 'UCharacterMeshComponent::MaxWounds' has a wrong offset!");
static_assert(offsetof(UCharacterMeshComponent, BloodReceivingSkeletalMeshes) == 0x000FB8, "Member 'UCharacterMeshComponent::BloodReceivingSkeletalMeshes' has a wrong offset!");
static_assert(offsetof(UCharacterMeshComponent, BloodIntensityParamName) == 0x000FC8, "Member 'UCharacterMeshComponent::BloodIntensityParamName' has a wrong offset!");
static_assert(offsetof(UCharacterMeshComponent, RagdollFallingFromPhysicsAsset) == 0x000FF8, "Member 'UCharacterMeshComponent::RagdollFallingFromPhysicsAsset' has a wrong offset!");
static_assert(offsetof(UCharacterMeshComponent, RagdollFallingProfileName) == 0x001000, "Member 'UCharacterMeshComponent::RagdollFallingProfileName' has a wrong offset!");
static_assert(offsetof(UCharacterMeshComponent, RagdollFallingPhysicsAsset) == 0x001008, "Member 'UCharacterMeshComponent::RagdollFallingPhysicsAsset' has a wrong offset!");
static_assert(offsetof(UCharacterMeshComponent, RagdollFallingBlendOutSpeed) == 0x001010, "Member 'UCharacterMeshComponent::RagdollFallingBlendOutSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterMeshComponent, RagdollFallingApplyForce) == 0x001014, "Member 'UCharacterMeshComponent::RagdollFallingApplyForce' has a wrong offset!");
static_assert(offsetof(UCharacterMeshComponent, RagdollFallingApplyForceAir) == 0x001020, "Member 'UCharacterMeshComponent::RagdollFallingApplyForceAir' has a wrong offset!");
static_assert(offsetof(UCharacterMeshComponent, RagdollFallingApplyForceBoneName) == 0x00102C, "Member 'UCharacterMeshComponent::RagdollFallingApplyForceBoneName' has a wrong offset!");
static_assert(offsetof(UCharacterMeshComponent, DissolveMaterialInstances) == 0x001040, "Member 'UCharacterMeshComponent::DissolveMaterialInstances' has a wrong offset!");

// Class Mordhau.HumanMeshComponent
// 0x0510 (0x1560 - 0x1050)
class UHumanMeshComponent final : public UCharacterMeshComponent
{
public:
	uint8                                         Pad_1050[0x11];                                    // 0x1050(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDoNotCacheMeshes;                                 // 0x1061(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1062[0x6];                                     // 0x1062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FSoftObjectPath>                  QueuedLoadingMeshes;                               // 0x1068(0x0050)(NativeAccessSpecifierPublic)
	TSet<class USkeletalMesh*>                    QueuedLoadedMeshes;                                // 0x10B8(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_1108[0x8];                                     // 0x1108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          FPMesh;                                            // 0x1110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          FPDeadMesh;                                        // 0x1118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          UnifiedMesh;                                       // 0x1120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     EyesMat;                                           // 0x1128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TorsoMat;                                          // 0x1130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Arm1PMat;                                          // 0x1138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     HairMat;                                           // 0x1140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     FacialHairMat;                                     // 0x1148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULODSkeletalMeshComponent*>      SlaveSkeletalMeshComponents;                       // 0x1150(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1160[0x4];                                     // 0x1160(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClothBlendWeightInterpSpeed;                       // 0x1164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FOVLODDistanceScaleIn;                             // 0x1168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FOVLODDistanceScaleOut;                            // 0x1170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInstantMeshUpdate;                           // 0x1178(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1179[0x3];                                     // 0x1179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnifiedMeshDistance;                               // 0x117C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeparatedMeshDistance;                             // 0x1180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1184[0x4];                                     // 0x1184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 LODIncreaseDistance;                               // 0x1188(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 LODDecreaseDistance;                               // 0x1198(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CurrentForcedLOD;                                  // 0x11A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMeshesAreInitialized;                             // 0x11AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaterialsAreInitialized;                          // 0x11AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInvisibleBody;                                 // 0x11AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceTorsoMasked;                                 // 0x11AF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class USkeletalMesh>>   OverrideMeshConstructionParts;                     // 0x11B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	EWearableSlot                                 SingleSlotMode;                                    // 0x11C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C1[0x7];                                     // 0x11C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMordhauWearable>           SingleSlotModeWearableToUse;                       // 0x11C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMordhauWearable>           AuxiliaryWearableToUse;                            // 0x11D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeleton*                              BodySkeleton;                                      // 0x11D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          ShadowPhysicsAsset;                                // 0x11E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasScaryBody;                                     // 0x11E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E9[0x3];                                     // 0x11E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HelmetAOOffset;                                    // 0x11EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HelmetAOPower;                                     // 0x11F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HelmetAOIntensity;                                 // 0x11F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HelmetAOEyeIntensity;                              // 0x11F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11FC[0x4];                                     // 0x11FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     LODMasterMaterial;                                 // 0x1200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     UberMergeHighMaterial;                             // 0x1208(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     UberMergeLowMaterial;                              // 0x1210(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     HelmetCoifMaterial;                                // 0x1218(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ChestShouldersMaterial;                            // 0x1220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ArmsGlovesMaterial;                                // 0x1228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LowerChestMaterial;                                // 0x1230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LegsBootsMaterial;                                 // 0x1238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     HelmetCoifChestMaterial;                           // 0x1240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LegsBootsChestLowMaterial;                         // 0x1248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ArmsGlovesShouldersMaterial;                       // 0x1250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TorsoMaterial;                                     // 0x1258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     EyelashDefaultMaterial;                            // 0x1260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   UnarmedPreviewPoses;                               // 0x1268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        UnarmedUpperBlendSpace1P;                          // 0x1278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnarmedUpperAdditive1P;                            // 0x1280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        UnarmedUpperBlendSpace;                            // 0x1288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnarmedUpperAdditive;                              // 0x1290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnarmedLowerAnimation;                             // 0x1298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnarmedJumpAnimation;                              // 0x12A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnarmedLandAnimation;                              // 0x12A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnarmedFallingAnimation;                           // 0x12B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnarmedJumpAnimation1P;                            // 0x12B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnarmedLandAnimation1P;                            // 0x12C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnarmedFallingAnimation1P;                         // 0x12C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        HorseUnarmedUpperBlendSpace1P;                     // 0x12D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUnarmedUpperAdditive1P;                       // 0x12D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        HorseUnarmedUpperBlendSpace;                       // 0x12E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUnarmedUpperAdditive;                         // 0x12E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUnarmedRearing;                               // 0x12F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUnarmedRearing1P;                             // 0x12F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUnarmedJump;                                  // 0x1300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUnarmedJump1P;                                // 0x1308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           InteractWithAnimation;                             // 0x1310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           InteractWith1PAnimation;                           // 0x1318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreAngularVelocityAnimation;                   // 0x1320(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1321[0x7];                                     // 0x1321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RiposteBlendInCurve;                               // 0x1328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCharacterHair>             OverrideHair;                                      // 0x1330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCharacterHair>             OverrideFacialHair;                                // 0x1338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCharacterFace>             OverrideFace;                                      // 0x1340(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     OverrideEyes;                                      // 0x1348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     OverrideEyelashes;                                 // 0x1350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceHairColor;                                    // 0x1358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1359[0x3];                                     // 0x1359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           OverrideHairColor;                                 // 0x135C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceWearableColor;                                // 0x136C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_136D[0x3];                                     // 0x136D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           OverrideWearableColor1;                            // 0x1370(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OverrideWearableColor2;                            // 0x1380(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OverrideWearableColor3;                            // 0x1390(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           OverrideLeftArm;                                   // 0x13A0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           OverrideRightArm;                                  // 0x13C8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           OverrideLeftHand;                                  // 0x13F0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           OverrideRightHand;                                 // 0x1418(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           OverrideLeftLeg;                                   // 0x1440(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           OverrideRightLeg;                                  // 0x1468(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           OverrideLeftFoot;                                  // 0x1490(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           OverrideRightFoot;                                 // 0x14B8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           OverrideTorso;                                     // 0x14E0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UMaterialInterface*, struct FWearableMaterials> WearableMaterials;                                 // 0x1508(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_1558[0x8];                                     // 0x1558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CreateFPDeadMeshIfNone();
	bool CreateFPMeshIfNone();
	bool CreateUnifiedMeshIfNone();
	void ModifyBodyColors(const struct FLinearColor& InSkinColor, const struct FLinearColor& InHairColor, const struct FLinearColor& InEyeColor, struct FLinearColor* OutSkinColor, struct FLinearColor* OutHairColor, struct FLinearColor* OutEyeColor);
	void OnCharacterBuilt(class AMordhauCharacter* Character);
	void OnCharacterCameraStyleChanged(class AMordhauCharacter* Character);
	void OnCharacterChangedTeam(class AAdvancedCharacter* Character);
	void OnCharacterTornOff(class AAdvancedCharacter* Character);
	void OnMeshesAsyncLoaded();
	void SetMaterialParamsForLODMasterSlot(const class FString& Slot, class UMordhauWearable* Wearable, class UMaterialInstanceDynamic* Mid);
	void SetMaterialParamsForMergedSlot(const class FString& Prefix, class UMordhauWearable* Wearable, class UMaterialInstanceDynamic* Mid, bool LowQuality);
	void UpdateAllSkeletalMeshComponentMaterials();
	void UpdateSkeletalMeshComponentMaterials(class USkeletalMeshComponent* USMC, bool bUpdateBlood, bool bUpdateIconGenerate);
	void UpdateSkeletalMeshComponentMaterialsIconGeneration();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanMeshComponent">();
	}
	static class UHumanMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanMeshComponent>();
	}
};
static_assert(alignof(UHumanMeshComponent) == 0x000010, "Wrong alignment on UHumanMeshComponent");
static_assert(sizeof(UHumanMeshComponent) == 0x001560, "Wrong size on UHumanMeshComponent");
static_assert(offsetof(UHumanMeshComponent, bDoNotCacheMeshes) == 0x001061, "Member 'UHumanMeshComponent::bDoNotCacheMeshes' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, QueuedLoadingMeshes) == 0x001068, "Member 'UHumanMeshComponent::QueuedLoadingMeshes' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, QueuedLoadedMeshes) == 0x0010B8, "Member 'UHumanMeshComponent::QueuedLoadedMeshes' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, FPMesh) == 0x001110, "Member 'UHumanMeshComponent::FPMesh' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, FPDeadMesh) == 0x001118, "Member 'UHumanMeshComponent::FPDeadMesh' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnifiedMesh) == 0x001120, "Member 'UHumanMeshComponent::UnifiedMesh' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, EyesMat) == 0x001128, "Member 'UHumanMeshComponent::EyesMat' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, TorsoMat) == 0x001130, "Member 'UHumanMeshComponent::TorsoMat' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, Arm1PMat) == 0x001138, "Member 'UHumanMeshComponent::Arm1PMat' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HairMat) == 0x001140, "Member 'UHumanMeshComponent::HairMat' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, FacialHairMat) == 0x001148, "Member 'UHumanMeshComponent::FacialHairMat' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, SlaveSkeletalMeshComponents) == 0x001150, "Member 'UHumanMeshComponent::SlaveSkeletalMeshComponents' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, ClothBlendWeightInterpSpeed) == 0x001164, "Member 'UHumanMeshComponent::ClothBlendWeightInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, FOVLODDistanceScaleIn) == 0x001168, "Member 'UHumanMeshComponent::FOVLODDistanceScaleIn' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, FOVLODDistanceScaleOut) == 0x001170, "Member 'UHumanMeshComponent::FOVLODDistanceScaleOut' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, bForceInstantMeshUpdate) == 0x001178, "Member 'UHumanMeshComponent::bForceInstantMeshUpdate' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnifiedMeshDistance) == 0x00117C, "Member 'UHumanMeshComponent::UnifiedMeshDistance' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, SeparatedMeshDistance) == 0x001180, "Member 'UHumanMeshComponent::SeparatedMeshDistance' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, LODIncreaseDistance) == 0x001188, "Member 'UHumanMeshComponent::LODIncreaseDistance' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, LODDecreaseDistance) == 0x001198, "Member 'UHumanMeshComponent::LODDecreaseDistance' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, CurrentForcedLOD) == 0x0011A8, "Member 'UHumanMeshComponent::CurrentForcedLOD' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, bMeshesAreInitialized) == 0x0011AC, "Member 'UHumanMeshComponent::bMeshesAreInitialized' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, bMaterialsAreInitialized) == 0x0011AD, "Member 'UHumanMeshComponent::bMaterialsAreInitialized' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, bHasInvisibleBody) == 0x0011AE, "Member 'UHumanMeshComponent::bHasInvisibleBody' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, bForceTorsoMasked) == 0x0011AF, "Member 'UHumanMeshComponent::bForceTorsoMasked' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideMeshConstructionParts) == 0x0011B0, "Member 'UHumanMeshComponent::OverrideMeshConstructionParts' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, SingleSlotMode) == 0x0011C0, "Member 'UHumanMeshComponent::SingleSlotMode' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, SingleSlotModeWearableToUse) == 0x0011C8, "Member 'UHumanMeshComponent::SingleSlotModeWearableToUse' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, AuxiliaryWearableToUse) == 0x0011D0, "Member 'UHumanMeshComponent::AuxiliaryWearableToUse' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, BodySkeleton) == 0x0011D8, "Member 'UHumanMeshComponent::BodySkeleton' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, ShadowPhysicsAsset) == 0x0011E0, "Member 'UHumanMeshComponent::ShadowPhysicsAsset' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, bHasScaryBody) == 0x0011E8, "Member 'UHumanMeshComponent::bHasScaryBody' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HelmetAOOffset) == 0x0011EC, "Member 'UHumanMeshComponent::HelmetAOOffset' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HelmetAOPower) == 0x0011F0, "Member 'UHumanMeshComponent::HelmetAOPower' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HelmetAOIntensity) == 0x0011F4, "Member 'UHumanMeshComponent::HelmetAOIntensity' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HelmetAOEyeIntensity) == 0x0011F8, "Member 'UHumanMeshComponent::HelmetAOEyeIntensity' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, LODMasterMaterial) == 0x001200, "Member 'UHumanMeshComponent::LODMasterMaterial' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UberMergeHighMaterial) == 0x001208, "Member 'UHumanMeshComponent::UberMergeHighMaterial' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UberMergeLowMaterial) == 0x001210, "Member 'UHumanMeshComponent::UberMergeLowMaterial' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HelmetCoifMaterial) == 0x001218, "Member 'UHumanMeshComponent::HelmetCoifMaterial' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, ChestShouldersMaterial) == 0x001220, "Member 'UHumanMeshComponent::ChestShouldersMaterial' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, ArmsGlovesMaterial) == 0x001228, "Member 'UHumanMeshComponent::ArmsGlovesMaterial' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, LowerChestMaterial) == 0x001230, "Member 'UHumanMeshComponent::LowerChestMaterial' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, LegsBootsMaterial) == 0x001238, "Member 'UHumanMeshComponent::LegsBootsMaterial' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HelmetCoifChestMaterial) == 0x001240, "Member 'UHumanMeshComponent::HelmetCoifChestMaterial' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, LegsBootsChestLowMaterial) == 0x001248, "Member 'UHumanMeshComponent::LegsBootsChestLowMaterial' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, ArmsGlovesShouldersMaterial) == 0x001250, "Member 'UHumanMeshComponent::ArmsGlovesShouldersMaterial' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, TorsoMaterial) == 0x001258, "Member 'UHumanMeshComponent::TorsoMaterial' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, EyelashDefaultMaterial) == 0x001260, "Member 'UHumanMeshComponent::EyelashDefaultMaterial' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnarmedPreviewPoses) == 0x001268, "Member 'UHumanMeshComponent::UnarmedPreviewPoses' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnarmedUpperBlendSpace1P) == 0x001278, "Member 'UHumanMeshComponent::UnarmedUpperBlendSpace1P' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnarmedUpperAdditive1P) == 0x001280, "Member 'UHumanMeshComponent::UnarmedUpperAdditive1P' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnarmedUpperBlendSpace) == 0x001288, "Member 'UHumanMeshComponent::UnarmedUpperBlendSpace' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnarmedUpperAdditive) == 0x001290, "Member 'UHumanMeshComponent::UnarmedUpperAdditive' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnarmedLowerAnimation) == 0x001298, "Member 'UHumanMeshComponent::UnarmedLowerAnimation' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnarmedJumpAnimation) == 0x0012A0, "Member 'UHumanMeshComponent::UnarmedJumpAnimation' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnarmedLandAnimation) == 0x0012A8, "Member 'UHumanMeshComponent::UnarmedLandAnimation' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnarmedFallingAnimation) == 0x0012B0, "Member 'UHumanMeshComponent::UnarmedFallingAnimation' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnarmedJumpAnimation1P) == 0x0012B8, "Member 'UHumanMeshComponent::UnarmedJumpAnimation1P' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnarmedLandAnimation1P) == 0x0012C0, "Member 'UHumanMeshComponent::UnarmedLandAnimation1P' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, UnarmedFallingAnimation1P) == 0x0012C8, "Member 'UHumanMeshComponent::UnarmedFallingAnimation1P' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HorseUnarmedUpperBlendSpace1P) == 0x0012D0, "Member 'UHumanMeshComponent::HorseUnarmedUpperBlendSpace1P' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HorseUnarmedUpperAdditive1P) == 0x0012D8, "Member 'UHumanMeshComponent::HorseUnarmedUpperAdditive1P' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HorseUnarmedUpperBlendSpace) == 0x0012E0, "Member 'UHumanMeshComponent::HorseUnarmedUpperBlendSpace' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HorseUnarmedUpperAdditive) == 0x0012E8, "Member 'UHumanMeshComponent::HorseUnarmedUpperAdditive' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HorseUnarmedRearing) == 0x0012F0, "Member 'UHumanMeshComponent::HorseUnarmedRearing' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HorseUnarmedRearing1P) == 0x0012F8, "Member 'UHumanMeshComponent::HorseUnarmedRearing1P' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HorseUnarmedJump) == 0x001300, "Member 'UHumanMeshComponent::HorseUnarmedJump' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, HorseUnarmedJump1P) == 0x001308, "Member 'UHumanMeshComponent::HorseUnarmedJump1P' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, InteractWithAnimation) == 0x001310, "Member 'UHumanMeshComponent::InteractWithAnimation' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, InteractWith1PAnimation) == 0x001318, "Member 'UHumanMeshComponent::InteractWith1PAnimation' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, bIgnoreAngularVelocityAnimation) == 0x001320, "Member 'UHumanMeshComponent::bIgnoreAngularVelocityAnimation' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, RiposteBlendInCurve) == 0x001328, "Member 'UHumanMeshComponent::RiposteBlendInCurve' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideHair) == 0x001330, "Member 'UHumanMeshComponent::OverrideHair' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideFacialHair) == 0x001338, "Member 'UHumanMeshComponent::OverrideFacialHair' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideFace) == 0x001340, "Member 'UHumanMeshComponent::OverrideFace' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideEyes) == 0x001348, "Member 'UHumanMeshComponent::OverrideEyes' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideEyelashes) == 0x001350, "Member 'UHumanMeshComponent::OverrideEyelashes' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, ForceHairColor) == 0x001358, "Member 'UHumanMeshComponent::ForceHairColor' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideHairColor) == 0x00135C, "Member 'UHumanMeshComponent::OverrideHairColor' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, ForceWearableColor) == 0x00136C, "Member 'UHumanMeshComponent::ForceWearableColor' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideWearableColor1) == 0x001370, "Member 'UHumanMeshComponent::OverrideWearableColor1' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideWearableColor2) == 0x001380, "Member 'UHumanMeshComponent::OverrideWearableColor2' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideWearableColor3) == 0x001390, "Member 'UHumanMeshComponent::OverrideWearableColor3' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideLeftArm) == 0x0013A0, "Member 'UHumanMeshComponent::OverrideLeftArm' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideRightArm) == 0x0013C8, "Member 'UHumanMeshComponent::OverrideRightArm' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideLeftHand) == 0x0013F0, "Member 'UHumanMeshComponent::OverrideLeftHand' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideRightHand) == 0x001418, "Member 'UHumanMeshComponent::OverrideRightHand' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideLeftLeg) == 0x001440, "Member 'UHumanMeshComponent::OverrideLeftLeg' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideRightLeg) == 0x001468, "Member 'UHumanMeshComponent::OverrideRightLeg' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideLeftFoot) == 0x001490, "Member 'UHumanMeshComponent::OverrideLeftFoot' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideRightFoot) == 0x0014B8, "Member 'UHumanMeshComponent::OverrideRightFoot' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, OverrideTorso) == 0x0014E0, "Member 'UHumanMeshComponent::OverrideTorso' has a wrong offset!");
static_assert(offsetof(UHumanMeshComponent, WearableMaterials) == 0x001508, "Member 'UHumanMeshComponent::WearableMaterials' has a wrong offset!");

// Class Mordhau.BTTask_RangedAttack
// 0x0008 (0x0078 - 0x0070)
class UBTTask_RangedAttack final : public UBTTaskNode
{
public:
	float                                         MaxProjectileFlightTime;                           // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RangedAttack">();
	}
	static class UBTTask_RangedAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RangedAttack>();
	}
};
static_assert(alignof(UBTTask_RangedAttack) == 0x000008, "Wrong alignment on UBTTask_RangedAttack");
static_assert(sizeof(UBTTask_RangedAttack) == 0x000078, "Wrong size on UBTTask_RangedAttack");
static_assert(offsetof(UBTTask_RangedAttack, MaxProjectileFlightTime) == 0x000070, "Member 'UBTTask_RangedAttack::MaxProjectileFlightTime' has a wrong offset!");

// Class Mordhau.BTTask_SwitchEquipment
// 0x0028 (0x0098 - 0x0070)
class UBTTask_SwitchEquipment final : public UBTTaskNode
{
public:
	bool                                          bMelee;                                            // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AMordhauEquipment>>  AllowedSubclasses;                                 // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AMordhauEquipment>>  NotAllowedSubclasses;                              // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SwitchEquipment">();
	}
	static class UBTTask_SwitchEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SwitchEquipment>();
	}
};
static_assert(alignof(UBTTask_SwitchEquipment) == 0x000008, "Wrong alignment on UBTTask_SwitchEquipment");
static_assert(sizeof(UBTTask_SwitchEquipment) == 0x000098, "Wrong size on UBTTask_SwitchEquipment");
static_assert(offsetof(UBTTask_SwitchEquipment, bMelee) == 0x000070, "Member 'UBTTask_SwitchEquipment::bMelee' has a wrong offset!");
static_assert(offsetof(UBTTask_SwitchEquipment, AllowedSubclasses) == 0x000078, "Member 'UBTTask_SwitchEquipment::AllowedSubclasses' has a wrong offset!");
static_assert(offsetof(UBTTask_SwitchEquipment, NotAllowedSubclasses) == 0x000088, "Member 'UBTTask_SwitchEquipment::NotAllowedSubclasses' has a wrong offset!");

// Class Mordhau.UpdateMatchmakingMatch
// 0x0170 (0x01A0 - 0x0030)
class UUpdateMatchmakingMatch final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(struct FPlayFabMatchmakingMatch& Match)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FPlayFabMatchmakingMatch& Match)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayFabMatchmakingMatch               Match;                                             // 0x0060(0x00B8)(NativeAccessSpecifierPrivate)
	class FString                                 GroupID;                                           // 0x0118(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 GroupName;                                         // 0x0128(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayFabGroup                          Group;                                             // 0x0138(0x0068)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UUpdateMatchmakingMatch* UpdateMatchmakingMatch(class UObject* WorldContextObject, const struct FPlayFabMatchmakingMatch& Match_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateMatchmakingMatch">();
	}
	static class UUpdateMatchmakingMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateMatchmakingMatch>();
	}
};
static_assert(alignof(UUpdateMatchmakingMatch) == 0x000008, "Wrong alignment on UUpdateMatchmakingMatch");
static_assert(sizeof(UUpdateMatchmakingMatch) == 0x0001A0, "Wrong size on UUpdateMatchmakingMatch");
static_assert(offsetof(UUpdateMatchmakingMatch, onSuccess) == 0x000030, "Member 'UUpdateMatchmakingMatch::onSuccess' has a wrong offset!");
static_assert(offsetof(UUpdateMatchmakingMatch, onFailure) == 0x000040, "Member 'UUpdateMatchmakingMatch::onFailure' has a wrong offset!");
static_assert(offsetof(UUpdateMatchmakingMatch, World) == 0x000058, "Member 'UUpdateMatchmakingMatch::World' has a wrong offset!");
static_assert(offsetof(UUpdateMatchmakingMatch, Match) == 0x000060, "Member 'UUpdateMatchmakingMatch::Match' has a wrong offset!");
static_assert(offsetof(UUpdateMatchmakingMatch, GroupID) == 0x000118, "Member 'UUpdateMatchmakingMatch::GroupID' has a wrong offset!");
static_assert(offsetof(UUpdateMatchmakingMatch, GroupName) == 0x000128, "Member 'UUpdateMatchmakingMatch::GroupName' has a wrong offset!");
static_assert(offsetof(UUpdateMatchmakingMatch, Group) == 0x000138, "Member 'UUpdateMatchmakingMatch::Group' has a wrong offset!");

// Class Mordhau.BTTask_VoiceOrEmote
// 0x0030 (0x00A0 - 0x0070)
class UBTTask_VoiceOrEmote final : public UBTTaskNode
{
public:
	TArray<uint8>                                 VoiceCommandsList;                                 // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 EmotesList;                                        // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bForceEmote;                                       // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlobalCooldown;                                    // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chance;                                            // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_VoiceOrEmote">();
	}
	static class UBTTask_VoiceOrEmote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_VoiceOrEmote>();
	}
};
static_assert(alignof(UBTTask_VoiceOrEmote) == 0x000008, "Wrong alignment on UBTTask_VoiceOrEmote");
static_assert(sizeof(UBTTask_VoiceOrEmote) == 0x0000A0, "Wrong size on UBTTask_VoiceOrEmote");
static_assert(offsetof(UBTTask_VoiceOrEmote, VoiceCommandsList) == 0x000070, "Member 'UBTTask_VoiceOrEmote::VoiceCommandsList' has a wrong offset!");
static_assert(offsetof(UBTTask_VoiceOrEmote, EmotesList) == 0x000080, "Member 'UBTTask_VoiceOrEmote::EmotesList' has a wrong offset!");
static_assert(offsetof(UBTTask_VoiceOrEmote, bForceEmote) == 0x000090, "Member 'UBTTask_VoiceOrEmote::bForceEmote' has a wrong offset!");
static_assert(offsetof(UBTTask_VoiceOrEmote, GlobalCooldown) == 0x000094, "Member 'UBTTask_VoiceOrEmote::GlobalCooldown' has a wrong offset!");
static_assert(offsetof(UBTTask_VoiceOrEmote, Chance) == 0x000098, "Member 'UBTTask_VoiceOrEmote::Chance' has a wrong offset!");

// Class Mordhau.SpawnActorCommand
// 0x0000 (0x0080 - 0x0080)
class USpawnActorCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnActorCommand">();
	}
	static class USpawnActorCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnActorCommand>();
	}
};
static_assert(alignof(USpawnActorCommand) == 0x000008, "Wrong alignment on USpawnActorCommand");
static_assert(sizeof(USpawnActorCommand) == 0x000080, "Wrong size on USpawnActorCommand");

// Class Mordhau.BuildableTraceBase
// 0x0040 (0x0070 - 0x0030)
class UBuildableTraceBase : public UDataAsset
{
public:
	TArray<EObjectTypeQuery>                      TraceObjectTypes;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawType;                                          // 0x0042(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x1];                                       // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 DrawColor;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TraceTextForUI;                                    // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0060(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildableTraceBase">();
	}
	static class UBuildableTraceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildableTraceBase>();
	}
};
static_assert(alignof(UBuildableTraceBase) == 0x000008, "Wrong alignment on UBuildableTraceBase");
static_assert(sizeof(UBuildableTraceBase) == 0x000070, "Wrong size on UBuildableTraceBase");
static_assert(offsetof(UBuildableTraceBase, TraceObjectTypes) == 0x000030, "Member 'UBuildableTraceBase::TraceObjectTypes' has a wrong offset!");
static_assert(offsetof(UBuildableTraceBase, bTraceComplex) == 0x000040, "Member 'UBuildableTraceBase::bTraceComplex' has a wrong offset!");
static_assert(offsetof(UBuildableTraceBase, bIgnoreSelf) == 0x000041, "Member 'UBuildableTraceBase::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(UBuildableTraceBase, DrawType) == 0x000042, "Member 'UBuildableTraceBase::DrawType' has a wrong offset!");
static_assert(offsetof(UBuildableTraceBase, DrawColor) == 0x000044, "Member 'UBuildableTraceBase::DrawColor' has a wrong offset!");
static_assert(offsetof(UBuildableTraceBase, TraceTextForUI) == 0x000048, "Member 'UBuildableTraceBase::TraceTextForUI' has a wrong offset!");
static_assert(offsetof(UBuildableTraceBase, ActorsToIgnore) == 0x000060, "Member 'UBuildableTraceBase::ActorsToIgnore' has a wrong offset!");

// Class Mordhau.BuildableBoxTrace
// 0x0010 (0x0080 - 0x0070)
class UBuildableBoxTrace final : public UBuildableTraceBase
{
public:
	class FName                                   ProfileName;                                       // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTraceXAxisPercentage;                         // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildableBoxTrace">();
	}
	static class UBuildableBoxTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildableBoxTrace>();
	}
};
static_assert(alignof(UBuildableBoxTrace) == 0x000008, "Wrong alignment on UBuildableBoxTrace");
static_assert(sizeof(UBuildableBoxTrace) == 0x000080, "Wrong size on UBuildableBoxTrace");
static_assert(offsetof(UBuildableBoxTrace, ProfileName) == 0x000070, "Member 'UBuildableBoxTrace::ProfileName' has a wrong offset!");
static_assert(offsetof(UBuildableBoxTrace, StartTraceXAxisPercentage) == 0x000078, "Member 'UBuildableBoxTrace::StartTraceXAxisPercentage' has a wrong offset!");

// Class Mordhau.BuildableLineTrace
// 0x0018 (0x0088 - 0x0070)
class UBuildableLineTrace final : public UBuildableTraceBase
{
public:
	struct FVector                                TraceStartOffset;                                  // 0x0070(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEndOffset;                                    // 0x007C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildableLineTrace">();
	}
	static class UBuildableLineTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildableLineTrace>();
	}
};
static_assert(alignof(UBuildableLineTrace) == 0x000008, "Wrong alignment on UBuildableLineTrace");
static_assert(sizeof(UBuildableLineTrace) == 0x000088, "Wrong size on UBuildableLineTrace");
static_assert(offsetof(UBuildableLineTrace, TraceStartOffset) == 0x000070, "Member 'UBuildableLineTrace::TraceStartOffset' has a wrong offset!");
static_assert(offsetof(UBuildableLineTrace, TraceEndOffset) == 0x00007C, "Member 'UBuildableLineTrace::TraceEndOffset' has a wrong offset!");

// Class Mordhau.MordhauGameInstance
// 0x0CB8 (0x0E60 - 0x01A8)
class UMordhauGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_1A8[0x788];                                    // 0x01A8(0x0788)(Fixing Size After Last Property [ Dumper-7 ])
	struct FServerSearchResult                    ServerSession;                                     // 0x0930(0x0110)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBasicServerInfo                       ServerInfo;                                        // 0x0A40(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPlayFabServerDetails                  ServerDetails;                                     // 0x0A68(0x0038)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 ServerPassword;                                    // 0x0AA0(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerFull;                                       // 0x0AB0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB1[0x3];                                      // 0x0AB1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChangeLevelCounter;                                // 0x0AB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   NetworkErrorText;                                  // 0x0AB8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD0[0xA0];                                     // 0x0AD0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, TSubclassOf<class UGameModeMetadata>> GameModeMetadata;                                  // 0x0B70(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FString, TSubclassOf<class UMapMetadata>> MapMetadata;                                       // 0x0BC0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FText>                           Tips;                                              // 0x0C10(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           PCOnlyTips;                                        // 0x0C20(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ELoginError, struct FLoginErrorMessage>  MapUserErrorMsg;                                   // 0x0C30(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<struct FPlayFabPlayer>& PartyMembers)> OnPartyUpdated;                                    // 0x0C80(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnReceivedPartyInvite;                             // 0x0C90(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EServerRegion                                 CurrentMatchmakingRegion;                          // 0x0CA0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA1[0x7];                                      // 0x0CA1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         CurrentMatchmakingGameModes;                       // 0x0CA8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EServerRegion CasualMatchmakingRegion, EServerRegion RankedMatchmakingRegion)> OnMatchmakingRegionsDetermined;                    // 0x0CB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC8[0xD0];                                     // 0x0CC8(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartupMap;                                        // 0x0D98(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EServerRegion>                         CasualMatchmakingRegions;                          // 0x0DA8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EServerRegion>                         RankedMatchmakingRegions;                          // 0x0DB8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EServerRegion>                         ConsoleMatchmakingRegions;                         // 0x0DC8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FPlayFabPlayer& Player)> OnPlayerInformationReceived;                       // 0x0DD8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 ModStartupMap;                                     // 0x0DE8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         MountedPakPaths;                                   // 0x0DF8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bMountedCustomPaks;                                // 0x0E08(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpenedModStartupMap;                              // 0x0E09(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0A[0x6];                                      // 0x0E0A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMordhauTitleScreen*                    TitleScreen;                                       // 0x0E10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAsyncLoadingFlushDelegate;                       // 0x0E18(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E28[0x38];                                     // 0x0E28(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AcceptPartyInvite(const struct FPlayFabPlayer& Sender);
	bool ActivityStatusChange(bool Status, EActivityType Type);
	void AddPartyMatchmakingTicket(const class FString& QueueName, const class FString& TicketId);
	bool AreStatsAvailable();
	void AutoJoinPartyLeaderGameSessionOnPartyUpdate(const struct FPlayFabPlayer& Player);
	void BPPlayReplay(const class FString& InName, const TArray<class FString>& AdditionalOptions);
	void BPStartRecordingReplay(const class FString& InName, const class FString& FriendlyName, const TArray<class FString>& AdditionalOptions);
	void BPStopPlayingReplay();
	void BPStopRecordingReplay();
	bool CanInviteToParty();
	bool CanLeaveParty();
	bool CanOnlineCrossPlay();
	bool CanOnlineCrossPlayPlaystation();
	bool CanPlayOnline();
	bool CanPlayOnlineOnly();
	bool CheckControllerPresence();
	void CheckIfConsolePlayerIsOnOfficialServer();
	void ClearPartyGameServer();
	void ClearPartyMatch();
	void ClearPartyMatchmakingMembers();
	void ClearPartyMatchmakingTickets();
	void ClearPartyMemberProfile(const struct FPlayFabPlayer& Player);
	void ClearPartyMemberServerDetails();
	void ClearPartyServerDetails();
	bool ClientTravel(const class FString& MapName, const int32 PlayerCount);
	bool ClientTravelServerDetails(const struct FPlayFabServerDetails& InServerDetails, const class FString& Password);
	bool ClientTravelSession(const struct FServerSearchResult& SearchResult, const class FString& Password);
	bool DeclinePartyInvite(const struct FPlayFabPlayer& Sender);
	void DetermineServerLocationPings();
	EServerLocation FindBestServerLocation();
	EServerRegion FindBestServerRegion();
	class UGameModeMetadata* FindGameModeMetadata(const class FString& GameModePrefix);
	class UMapMetadata* FindMapMetadata(const class FString& GameModeMapName);
	void ForceAllUserFocus(EFocusCause FocusCause, class UUserWidget* UserWidget);
	void ForceCloseTitleScreen();
	TArray<class FString> GetBlacklistedServers();
	float GetConnectionTimeoutTimestamp();
	class FString GetFriendsGroupId();
	int32 GetGlobalServerBanDuration();
	int32 GetGlobalServerMuteDuration();
	EIngameEvent GetIngameEvent();
	double GetLastPlayerLeaveTime();
	struct FMapInfo GetMapInfo(const class FString& MapName);
	class FString GetMatchmakingGroupId();
	class FString GetMatchmakingMatchId();
	int32 GetNextMatchId();
	TArray<EServerRegion> GetNoviceServerRegions();
	int32 GetNoviceThreshold();
	int32 GetNumReservedSlots();
	int32 GetOfficialServerBanDuration();
	int32 GetOfficialServerMuteDuration();
	TArray<class FString> GetOtherPartyMembersEntityIDs();
	class FString GetPartyId();
	TArray<struct FPlayFabPlayer> GetPartyInvites();
	struct FPlayFabPlayer GetPartyLeader();
	void GetPartyMatch(class FString* QueueName, class FString* MatchId);
	TArray<class FString> GetPartyMatchmakingMembers();
	EMatchmakingState GetPartyMatchmakingState();
	TArray<struct FMatchmakingTicket> GetPartyMatchmakingTickets();
	TArray<struct FPlayFabPlayerEntity> GetPartyMemberEntities();
	bool GetPartyMemberProfile(const struct FPlayFabPlayer& Player, struct FPlayerProfile* Profile);
	TArray<struct FPlayFabPlayer> GetPartyMembers();
	void GetPartyMemberServerAddress(const struct FPlayFabPlayer& Player, struct FServerAddress* Address, bool* bWasSuccessful);
	void GetPartyMemberServerDetails(const struct FPlayFabPlayer& Player, struct FPlayFabServerDetails* OutServerDetails, bool* bWasSuccessful);
	class FString GetPartyMemberStatus(const struct FPlayFabPlayer& Player);
	int32 GetPartyMMR(const class FString& GameMode);
	void GetPartyServerDetails(struct FPlayFabServerDetails* OutServerDetails, bool* bWasSuccessful);
	int32 GetPartySize();
	EPlatform GetPlatform();
	TArray<class FString> GetProfaneWords();
	class FString GetQueueKey(const class FString& InQueueName);
	class FString GetQueueName(const class FString& InQueueKey);
	int32 GetServerLocationPing(EServerLocation Location);
	TMap<EServerLocation, int32> GetServerLocationPings();
	TArray<EServerLocation> GetServerLocationPreference(EServerRegion Region);
	TMap<EServerLocation, int32> GetServerRegionPings(EServerRegion Region);
	bool HasCompletedLogin();
	bool HasPartyMemberConsolePlayer();
	bool HasPartyMemberPCPlayer();
	void Init();
	void InviteToParty(const struct FPlayFabPlayer& Recipient);
	bool IsAdmin();
	bool IsFriendsListAvailable();
	bool IsGlobalServerBanned();
	bool IsGlobalServerMuted();
	bool IsInventoryAvailable();
	bool IsLoadingScreenActive();
	bool IsLoggedIn();
	bool IsLoggingIn();
	bool IsNovice();
	bool IsOfficialServerBanned();
	bool IsOfficialServerMuted();
	bool IsPartyLeader();
	bool IsPartyMember(const struct FPlayFabPlayer& Player);
	bool IsPartyReadyForMatchmaking();
	bool IsPSNLockEnabled();
	bool IsTitleDatAvailable();
	bool IsTitleScreenVisible();
	bool IsUserControllerPaired();
	void JoinPartyGameServer();
	void JoinSessionSearchResult(const struct FServerSearchResult& SearchResult);
	void KickPartyMember(const struct FPlayFabPlayer& Player);
	void LeaveParty();
	void LogAllUsersAndStates(int32 LocalUserNum);
	void LogMatchmakingState(const class FString& Message);
	int32 MountModsInCustomPaksFolder();
	void OnAcceptedInvitePrivilegeCheckFailure();
	void OnAdvancedNetworkDialogConfirmed();
	void OnDelayKickUserFromParty(const struct FPlayFabPlayer& Player);
	void OnDelayReturnToMainMenu();
	void OnFindMordhauServerSessionByAddressSuccess(const struct FServerSearchResult& SearchResult);
	void OnHideMainMenu();
	void OnInventoryBecameAvailable();
	void OnNetworkRecoveryStarted();
	void OnPrivilegeCheckConfirmed();
	void OnPrivilegeCheckDeclined();
	EPlayerReportResponse OnReportUser(EPlayerReportType ReportType, const struct FPlayFabPlayer& ReportedPlayer, int32* TimeUntillAllowed);
	void OnShowMainMenu();
	void OnStartupComplete();
	void OnStatsBecameAvailable();
	void OnUserControllerParingConfirmed();
	void OnUserControllerParingDeclined();
	void OpenDLCStorePage(const class FString& DlcId);
	void PerformPlatformLogin();
	void PerformPlayfabLogin();
	void QuitGame(const class UObject* WorldContextObject, class APlayerController* SpecificPlayer, EQuitGamePreference QuitPreference, bool bIgnorePlatformRestrictions);
	void RegisterMetadata(int32 ModId, const TArray<class FString>& AssetPaths);
	void RemovePartyMatchmakingTicket(const class FString& QueueName);
	void RequestActivityStart(EActivityType ActivityType);
	void RequestPlayerInformation(const struct FPlayFabPlayer& Player);
	void ResetLoginProcessVars();
	void RespondControllerConnectionChange(bool Status, int32 UserId, int32 ControllerId);
	void RespondOnUserLoginChanged(bool Status, int32 UserId, int32 UserIndex);
	void SaveConfig();
	bool ServerTravel(const class UObject* WorldContextObject, const class FString& MapName);
	void SetConnectionTimeoutTimestamp(float NewConnectionTimeoutTimestamp);
	void SetIngameEvent(EIngameEvent InIngameEvent);
	void SetLastPlayerLeaveTime(double InLastPlayerLeaveTime);
	void SetMatchmakingMatchId(const class FString& MatchId);
	void SetNetworkError(const class FText& ErrorText);
	void SetPartyGameServer(const struct FServerSearchResult& SearchResult);
	void SetPartyLeader(const struct FPlayFabPlayer& Player);
	void SetPartyMatch(const class FString& QueueName, const class FString& MatchId);
	void SetPartyMatchmakingMembers(const TArray<class FString>& Members);
	void SetPartyMatchmakingState(EMatchmakingState MatchmakingState);
	void SetPartyMemberProfile(const struct FPlayFabPlayer& Player, const struct FPlayerProfile& Profile);
	void SetPartyMemberServerDetails(const struct FPlayFabServerDetails& InServerDetails, const class FString& InRichPresenceStr);
	void SetPartyServerDetails(const struct FPlayFabServerDetails& InServerDetails);
	void SetUserControllerPairing(bool InIsUserControllerPaired);
	void ShowInviteDialog();
	void ShowJoiningDialog(const struct FServerSearchResult& SearchResult);
	void ShowLoginErrorDialogWithDescription(ELoginError FailureType, const class FString& ErrorString);
	void ShowNetworkErrorDialog();
	void ShowNetworkErrorDialogWithDescription(ENetworkFailure FailureType, const class FString& ErrorString);
	void ShowNoControllerDialog(bool bEnable);
	void ShowPasswordDialog(const struct FServerSearchResult& SearchResult);
	void ShowTitleScreenDialog();
	void ShowUserControllerParingDialog();
	void Shutdown();
	void StartNetworkRecovery();
	void StopLoadingScreen();
	void UnregisterMetadata(int32 ModId);
	void UpdateParty(bool bUpdateProfile, bool bNotifyPartyCreation);

	bool IsStartUpComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauGameInstance">();
	}
	static class UMordhauGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauGameInstance>();
	}
};
static_assert(alignof(UMordhauGameInstance) == 0x000008, "Wrong alignment on UMordhauGameInstance");
static_assert(sizeof(UMordhauGameInstance) == 0x000E60, "Wrong size on UMordhauGameInstance");
static_assert(offsetof(UMordhauGameInstance, ServerSession) == 0x000930, "Member 'UMordhauGameInstance::ServerSession' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, ServerInfo) == 0x000A40, "Member 'UMordhauGameInstance::ServerInfo' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, ServerDetails) == 0x000A68, "Member 'UMordhauGameInstance::ServerDetails' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, ServerPassword) == 0x000AA0, "Member 'UMordhauGameInstance::ServerPassword' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, bServerFull) == 0x000AB0, "Member 'UMordhauGameInstance::bServerFull' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, ChangeLevelCounter) == 0x000AB4, "Member 'UMordhauGameInstance::ChangeLevelCounter' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, NetworkErrorText) == 0x000AB8, "Member 'UMordhauGameInstance::NetworkErrorText' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, GameModeMetadata) == 0x000B70, "Member 'UMordhauGameInstance::GameModeMetadata' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, MapMetadata) == 0x000BC0, "Member 'UMordhauGameInstance::MapMetadata' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, Tips) == 0x000C10, "Member 'UMordhauGameInstance::Tips' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, PCOnlyTips) == 0x000C20, "Member 'UMordhauGameInstance::PCOnlyTips' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, MapUserErrorMsg) == 0x000C30, "Member 'UMordhauGameInstance::MapUserErrorMsg' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, OnPartyUpdated) == 0x000C80, "Member 'UMordhauGameInstance::OnPartyUpdated' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, OnReceivedPartyInvite) == 0x000C90, "Member 'UMordhauGameInstance::OnReceivedPartyInvite' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, CurrentMatchmakingRegion) == 0x000CA0, "Member 'UMordhauGameInstance::CurrentMatchmakingRegion' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, CurrentMatchmakingGameModes) == 0x000CA8, "Member 'UMordhauGameInstance::CurrentMatchmakingGameModes' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, OnMatchmakingRegionsDetermined) == 0x000CB8, "Member 'UMordhauGameInstance::OnMatchmakingRegionsDetermined' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, StartupMap) == 0x000D98, "Member 'UMordhauGameInstance::StartupMap' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, CasualMatchmakingRegions) == 0x000DA8, "Member 'UMordhauGameInstance::CasualMatchmakingRegions' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, RankedMatchmakingRegions) == 0x000DB8, "Member 'UMordhauGameInstance::RankedMatchmakingRegions' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, ConsoleMatchmakingRegions) == 0x000DC8, "Member 'UMordhauGameInstance::ConsoleMatchmakingRegions' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, OnPlayerInformationReceived) == 0x000DD8, "Member 'UMordhauGameInstance::OnPlayerInformationReceived' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, ModStartupMap) == 0x000DE8, "Member 'UMordhauGameInstance::ModStartupMap' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, MountedPakPaths) == 0x000DF8, "Member 'UMordhauGameInstance::MountedPakPaths' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, bMountedCustomPaks) == 0x000E08, "Member 'UMordhauGameInstance::bMountedCustomPaks' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, bOpenedModStartupMap) == 0x000E09, "Member 'UMordhauGameInstance::bOpenedModStartupMap' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, TitleScreen) == 0x000E10, "Member 'UMordhauGameInstance::TitleScreen' has a wrong offset!");
static_assert(offsetof(UMordhauGameInstance, OnAsyncLoadingFlushDelegate) == 0x000E18, "Member 'UMordhauGameInstance::OnAsyncLoadingFlushDelegate' has a wrong offset!");

// Class Mordhau.BuildablePlaneTrace
// 0x0070 (0x00E0 - 0x0070)
class UBuildablePlaneTrace final : public UBuildableTraceBase
{
public:
	TArray<class UClass*>                         CheckActorsOnPlaneTraceHit;                        // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSpawnablePlaneInfo                    PlaneInfo;                                         // 0x0080(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TraceAmount;                                       // 0x0098(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         ForbiddenHitActorsList;                            // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bInverseXYAngle;                                   // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAllowedPlacementAngle;                          // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InverseXAxisMod;                                   // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InverseYAxisMod;                                   // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlacementLocationOffset;                           // 0x00C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PlacementRotationOffset;                           // 0x00D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	void GetPlacementAngleAndRotation(struct FSpawnablePlaneTraceResult* OutTraceResult, const struct FSpawnableObjectInfo& ObjectInfo, float* OutAngle, struct FRotator* OutRotation);

	void DrawDebugPlane(class UObject* WorldContextObject, const struct FVector& Forward, const struct FVector& Back, const struct FVector& Right, const struct FVector& Left, const struct FVector& InTraceAmount, EDrawDebugTrace DrawDebugType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildablePlaneTrace">();
	}
	static class UBuildablePlaneTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildablePlaneTrace>();
	}
};
static_assert(alignof(UBuildablePlaneTrace) == 0x000008, "Wrong alignment on UBuildablePlaneTrace");
static_assert(sizeof(UBuildablePlaneTrace) == 0x0000E0, "Wrong size on UBuildablePlaneTrace");
static_assert(offsetof(UBuildablePlaneTrace, CheckActorsOnPlaneTraceHit) == 0x000070, "Member 'UBuildablePlaneTrace::CheckActorsOnPlaneTraceHit' has a wrong offset!");
static_assert(offsetof(UBuildablePlaneTrace, PlaneInfo) == 0x000080, "Member 'UBuildablePlaneTrace::PlaneInfo' has a wrong offset!");
static_assert(offsetof(UBuildablePlaneTrace, TraceAmount) == 0x000098, "Member 'UBuildablePlaneTrace::TraceAmount' has a wrong offset!");
static_assert(offsetof(UBuildablePlaneTrace, ForbiddenHitActorsList) == 0x0000A8, "Member 'UBuildablePlaneTrace::ForbiddenHitActorsList' has a wrong offset!");
static_assert(offsetof(UBuildablePlaneTrace, bInverseXYAngle) == 0x0000B8, "Member 'UBuildablePlaneTrace::bInverseXYAngle' has a wrong offset!");
static_assert(offsetof(UBuildablePlaneTrace, MaxAllowedPlacementAngle) == 0x0000BC, "Member 'UBuildablePlaneTrace::MaxAllowedPlacementAngle' has a wrong offset!");
static_assert(offsetof(UBuildablePlaneTrace, InverseXAxisMod) == 0x0000C0, "Member 'UBuildablePlaneTrace::InverseXAxisMod' has a wrong offset!");
static_assert(offsetof(UBuildablePlaneTrace, InverseYAxisMod) == 0x0000C4, "Member 'UBuildablePlaneTrace::InverseYAxisMod' has a wrong offset!");
static_assert(offsetof(UBuildablePlaneTrace, PlacementLocationOffset) == 0x0000C8, "Member 'UBuildablePlaneTrace::PlacementLocationOffset' has a wrong offset!");
static_assert(offsetof(UBuildablePlaneTrace, PlacementRotationOffset) == 0x0000D4, "Member 'UBuildablePlaneTrace::PlacementRotationOffset' has a wrong offset!");

// Class Mordhau.BuildableSphereOverlap
// 0x0018 (0x0088 - 0x0070)
class UBuildableSphereOverlap final : public UBuildableTraceBase
{
public:
	float                                         SphereRadius;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTraceXAxisPercentage;                         // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckOnlyLoadedEquipement;                        // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ActorClassFilter;                                  // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildableSphereOverlap">();
	}
	static class UBuildableSphereOverlap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildableSphereOverlap>();
	}
};
static_assert(alignof(UBuildableSphereOverlap) == 0x000008, "Wrong alignment on UBuildableSphereOverlap");
static_assert(sizeof(UBuildableSphereOverlap) == 0x000088, "Wrong size on UBuildableSphereOverlap");
static_assert(offsetof(UBuildableSphereOverlap, SphereRadius) == 0x000070, "Member 'UBuildableSphereOverlap::SphereRadius' has a wrong offset!");
static_assert(offsetof(UBuildableSphereOverlap, StartTraceXAxisPercentage) == 0x000074, "Member 'UBuildableSphereOverlap::StartTraceXAxisPercentage' has a wrong offset!");
static_assert(offsetof(UBuildableSphereOverlap, bCheckOnlyLoadedEquipement) == 0x000078, "Member 'UBuildableSphereOverlap::bCheckOnlyLoadedEquipement' has a wrong offset!");
static_assert(offsetof(UBuildableSphereOverlap, ActorClassFilter) == 0x000080, "Member 'UBuildableSphereOverlap::ActorClassFilter' has a wrong offset!");

// Class Mordhau.ItemPattern
// 0x0010 (0x0070 - 0x0060)
class UItemPattern final : public UMordhauInventoryItem
{
public:
	class UTexture2D*                             Texture;                                           // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasColor1;                                        // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasColor2;                                        // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasColor3;                                        // 0x006A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPattern">();
	}
	static class UItemPattern* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemPattern>();
	}
};
static_assert(alignof(UItemPattern) == 0x000008, "Wrong alignment on UItemPattern");
static_assert(sizeof(UItemPattern) == 0x000070, "Wrong size on UItemPattern");
static_assert(offsetof(UItemPattern, Texture) == 0x000060, "Member 'UItemPattern::Texture' has a wrong offset!");
static_assert(offsetof(UItemPattern, bHasColor1) == 0x000068, "Member 'UItemPattern::bHasColor1' has a wrong offset!");
static_assert(offsetof(UItemPattern, bHasColor2) == 0x000069, "Member 'UItemPattern::bHasColor2' has a wrong offset!");
static_assert(offsetof(UItemPattern, bHasColor3) == 0x00006A, "Member 'UItemPattern::bHasColor3' has a wrong offset!");

// Class Mordhau.BuildableSphereTrace
// 0x0020 (0x0090 - 0x0070)
class UBuildableSphereTrace final : public UBuildableTraceBase
{
public:
	struct FVector                                TraceStartOffset;                                  // 0x0070(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEndOffset;                                    // 0x007C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildableSphereTrace">();
	}
	static class UBuildableSphereTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildableSphereTrace>();
	}
};
static_assert(alignof(UBuildableSphereTrace) == 0x000008, "Wrong alignment on UBuildableSphereTrace");
static_assert(sizeof(UBuildableSphereTrace) == 0x000090, "Wrong size on UBuildableSphereTrace");
static_assert(offsetof(UBuildableSphereTrace, TraceStartOffset) == 0x000070, "Member 'UBuildableSphereTrace::TraceStartOffset' has a wrong offset!");
static_assert(offsetof(UBuildableSphereTrace, TraceEndOffset) == 0x00007C, "Member 'UBuildableSphereTrace::TraceEndOffset' has a wrong offset!");
static_assert(offsetof(UBuildableSphereTrace, Radius) == 0x000088, "Member 'UBuildableSphereTrace::Radius' has a wrong offset!");

// Class Mordhau.BuildingSystemComponent
// 0x0068 (0x0118 - 0x00B0)
class UBuildingSystemComponent final : public UActorComponent
{
public:
	TArray<struct FSpawnableObjectInfo>           SpawnableObjects;                                  // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UBuildableTraceBase*>            TraceList;                                         // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UMeshComponent*                         PreviewMeshComponent;                              // 0x00D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              PreviewMaterial;                                   // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPreview;                                      // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMordhauHUDWidgetComponent*             MordhauHUDWidgetComponent;                         // 0x00E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMeshPreviewCreated;                              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMeshPreviewDestroyed;                            // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSkeletalMeshPreviewIfNone(class USkeletalMesh* SkeletalMesh);
	void AddStaticMeshPreviewIfNone(class UStaticMesh* StaticMesh);
	void DestroyMeshPreview();
	void DisplayPreview(bool bDrawObjectPreview, bool bIsValid, const struct FSpawnableObjectInfo& ObjectInfo, const struct FTransform& ObjectTransform, int32 SpawnableObjectIndex);
	int32 GetEquipmentAmmoCost(int32 SpawnableObjectIndex);
	class FName GetEquipmentDisplayName(int32 SpawnableObjectIndex);
	struct FSpawnableObjectInfo GetEquipmentInfo(int32 SpawnableObjectIndex);
	class FName GetEquipmentPlaceableLimitName(int32 SpawnableObjectIndex);
	int32 GetEquipmentPlaceableMaxLimit(int32 SpawnableObjectIndex);
	bool ValidateSpot(const struct FVector& Offset, struct FVector* OutLocation, struct FRotator* OutRotation, class USceneComponent** AttachToComponent, class UBuildableTraceBase** BuildableTraceHit, int32 SpawnableObjectIndex, bool bDrawObjectPreview, bool bForceFail);

	void SetupMeshPreview() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingSystemComponent">();
	}
	static class UBuildingSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingSystemComponent>();
	}
};
static_assert(alignof(UBuildingSystemComponent) == 0x000008, "Wrong alignment on UBuildingSystemComponent");
static_assert(sizeof(UBuildingSystemComponent) == 0x000118, "Wrong size on UBuildingSystemComponent");
static_assert(offsetof(UBuildingSystemComponent, SpawnableObjects) == 0x0000B0, "Member 'UBuildingSystemComponent::SpawnableObjects' has a wrong offset!");
static_assert(offsetof(UBuildingSystemComponent, TraceList) == 0x0000C0, "Member 'UBuildingSystemComponent::TraceList' has a wrong offset!");
static_assert(offsetof(UBuildingSystemComponent, PreviewMeshComponent) == 0x0000D0, "Member 'UBuildingSystemComponent::PreviewMeshComponent' has a wrong offset!");
static_assert(offsetof(UBuildingSystemComponent, PreviewMaterial) == 0x0000D8, "Member 'UBuildingSystemComponent::PreviewMaterial' has a wrong offset!");
static_assert(offsetof(UBuildingSystemComponent, bShowPreview) == 0x0000E0, "Member 'UBuildingSystemComponent::bShowPreview' has a wrong offset!");
static_assert(offsetof(UBuildingSystemComponent, MordhauHUDWidgetComponent) == 0x0000E8, "Member 'UBuildingSystemComponent::MordhauHUDWidgetComponent' has a wrong offset!");
static_assert(offsetof(UBuildingSystemComponent, OnMeshPreviewCreated) == 0x0000F0, "Member 'UBuildingSystemComponent::OnMeshPreviewCreated' has a wrong offset!");
static_assert(offsetof(UBuildingSystemComponent, OnMeshPreviewDestroyed) == 0x000100, "Member 'UBuildingSystemComponent::OnMeshPreviewDestroyed' has a wrong offset!");

// Class Mordhau.MessageCommand
// 0x0000 (0x0080 - 0x0080)
class UMessageCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessageCommand">();
	}
	static class UMessageCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessageCommand>();
	}
};
static_assert(alignof(UMessageCommand) == 0x000008, "Wrong alignment on UMessageCommand");
static_assert(sizeof(UMessageCommand) == 0x000080, "Wrong size on UMessageCommand");

// Class Mordhau.BurnableComponent
// 0x0088 (0x0138 - 0x00B0)
class UBurnableComponent : public UActorComponent
{
public:
	bool                                          bIsBurning;                                        // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IsBurningSmoothInterpSpeed;                        // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireDistanceMaxValue;                              // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireDistanceSmoothInterpSpeed;                     // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsBurningSmoothed;                                 // 0x00C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMasterField>            CurrentFireField;                                  // 0x00C4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AController>             FireInstigator;                                    // 0x00CC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  FireAgent;                                         // 0x00D4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireDamage;                                        // 0x00DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireDamageTick;                                    // 0x00E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireEnd;                                           // 0x00E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastFireDamageTime;                                // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceIntoFireField;                             // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceIntoFireFieldSmoothed;                     // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        BurningParticles;                                  // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UParticleSystemComponent> CurrentBurningParticles;                           // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         CurrentBurningSound;                               // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BurningAttachSocket;                               // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              BurningSound;                                      // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DouseFire();
	void OnLODTick(float DeltaTime);
	void SetOnFire(class AMasterField* FireField);
	void StartBurning(float Duration, float Damage, float Tick, class AActor* DamageAgent, class AController* InstigatorController);
	void StartBurningCosmetic();
	void StopBurningCosmetic();

	bool GetIsBurning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BurnableComponent">();
	}
	static class UBurnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBurnableComponent>();
	}
};
static_assert(alignof(UBurnableComponent) == 0x000008, "Wrong alignment on UBurnableComponent");
static_assert(sizeof(UBurnableComponent) == 0x000138, "Wrong size on UBurnableComponent");
static_assert(offsetof(UBurnableComponent, bIsBurning) == 0x0000B0, "Member 'UBurnableComponent::bIsBurning' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, IsBurningSmoothInterpSpeed) == 0x0000B4, "Member 'UBurnableComponent::IsBurningSmoothInterpSpeed' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, FireDistanceMaxValue) == 0x0000B8, "Member 'UBurnableComponent::FireDistanceMaxValue' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, FireDistanceSmoothInterpSpeed) == 0x0000BC, "Member 'UBurnableComponent::FireDistanceSmoothInterpSpeed' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, IsBurningSmoothed) == 0x0000C0, "Member 'UBurnableComponent::IsBurningSmoothed' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, CurrentFireField) == 0x0000C4, "Member 'UBurnableComponent::CurrentFireField' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, FireInstigator) == 0x0000CC, "Member 'UBurnableComponent::FireInstigator' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, FireAgent) == 0x0000D4, "Member 'UBurnableComponent::FireAgent' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, FireDamage) == 0x0000DC, "Member 'UBurnableComponent::FireDamage' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, FireDamageTick) == 0x0000E0, "Member 'UBurnableComponent::FireDamageTick' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, FireEnd) == 0x0000E4, "Member 'UBurnableComponent::FireEnd' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, LastFireDamageTime) == 0x0000E8, "Member 'UBurnableComponent::LastFireDamageTime' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, DistanceIntoFireField) == 0x0000EC, "Member 'UBurnableComponent::DistanceIntoFireField' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, DistanceIntoFireFieldSmoothed) == 0x0000F0, "Member 'UBurnableComponent::DistanceIntoFireFieldSmoothed' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, BurningParticles) == 0x0000F8, "Member 'UBurnableComponent::BurningParticles' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, CurrentBurningParticles) == 0x000100, "Member 'UBurnableComponent::CurrentBurningParticles' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, CurrentBurningSound) == 0x000108, "Member 'UBurnableComponent::CurrentBurningSound' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, BurningAttachSocket) == 0x000110, "Member 'UBurnableComponent::BurningAttachSocket' has a wrong offset!");
static_assert(offsetof(UBurnableComponent, BurningSound) == 0x000118, "Member 'UBurnableComponent::BurningSound' has a wrong offset!");

// Class Mordhau.StrikeMotion
// 0x0070 (0x1170 - 0x1100)
class UStrikeMotion : public UAttackMotion
{
public:
	uint8                                         Pad_1100[0x18];                                    // 0x1100(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AnimAngleCueAmount;                                // 0x1118(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1124[0x4];                                     // 0x1124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AnimAngleCurve;                                    // 0x1128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraEarlyReleaseForLookUpOverheads;               // 0x1130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraEarlyReleaseForLookUpNonUndercuts;            // 0x1134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CounterCompensateOverheadFixupTerm;                // 0x1138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CounterCompensateOverheadFixupTiltTerm;            // 0x113C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CounterCompensateWeight;                           // 0x1140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTurnCompensation;                               // 0x1144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CounterCompensateLookTime;                         // 0x1148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AngleToReleasePortionGlanceIn;                     // 0x114C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AngleToReleasePortionGlanceOut;                    // 0x1154(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlanceMinimumTurnAmount;                           // 0x115C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlanceOppositeMinimumTurnAmount;                   // 0x1160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlanceBlockedMinimumTurnAmount;                    // 0x1164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlanceBlockedOppositeMinimumTurnAmount;            // 0x1168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_116C[0x4];                                     // 0x116C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StrikeMotion">();
	}
	static class UStrikeMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStrikeMotion>();
	}
};
static_assert(alignof(UStrikeMotion) == 0x000008, "Wrong alignment on UStrikeMotion");
static_assert(sizeof(UStrikeMotion) == 0x001170, "Wrong size on UStrikeMotion");
static_assert(offsetof(UStrikeMotion, AnimAngleCueAmount) == 0x001118, "Member 'UStrikeMotion::AnimAngleCueAmount' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, AnimAngleCurve) == 0x001128, "Member 'UStrikeMotion::AnimAngleCurve' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, ExtraEarlyReleaseForLookUpOverheads) == 0x001130, "Member 'UStrikeMotion::ExtraEarlyReleaseForLookUpOverheads' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, ExtraEarlyReleaseForLookUpNonUndercuts) == 0x001134, "Member 'UStrikeMotion::ExtraEarlyReleaseForLookUpNonUndercuts' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, CounterCompensateOverheadFixupTerm) == 0x001138, "Member 'UStrikeMotion::CounterCompensateOverheadFixupTerm' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, CounterCompensateOverheadFixupTiltTerm) == 0x00113C, "Member 'UStrikeMotion::CounterCompensateOverheadFixupTiltTerm' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, CounterCompensateWeight) == 0x001140, "Member 'UStrikeMotion::CounterCompensateWeight' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, MaxTurnCompensation) == 0x001144, "Member 'UStrikeMotion::MaxTurnCompensation' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, CounterCompensateLookTime) == 0x001148, "Member 'UStrikeMotion::CounterCompensateLookTime' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, AngleToReleasePortionGlanceIn) == 0x00114C, "Member 'UStrikeMotion::AngleToReleasePortionGlanceIn' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, AngleToReleasePortionGlanceOut) == 0x001154, "Member 'UStrikeMotion::AngleToReleasePortionGlanceOut' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, GlanceMinimumTurnAmount) == 0x00115C, "Member 'UStrikeMotion::GlanceMinimumTurnAmount' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, GlanceOppositeMinimumTurnAmount) == 0x001160, "Member 'UStrikeMotion::GlanceOppositeMinimumTurnAmount' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, GlanceBlockedMinimumTurnAmount) == 0x001164, "Member 'UStrikeMotion::GlanceBlockedMinimumTurnAmount' has a wrong offset!");
static_assert(offsetof(UStrikeMotion, GlanceBlockedOppositeMinimumTurnAmount) == 0x001168, "Member 'UStrikeMotion::GlanceBlockedOppositeMinimumTurnAmount' has a wrong offset!");

// Class Mordhau.VehicleBase
// 0x0230 (0x04C0 - 0x0290)
#pragma pack(push, 0x1)
class alignas(0x10) AVehicleBase : public AWheeledVehicle
{
public:
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   VehicleName;                                       // 0x02A8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x20];                                     // 0x02C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UMordhauVehicleComponent*               VehicleComponent;                                  // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageableComponent*                   DamageableComponent;                               // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHealthStatComponent*                   HealthStatComponent;                               // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBurnableComponent*                     BurnableComponent;                                 // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          RagdollPhysicsAsset;                               // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDead;                                           // 0x0308(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHighlighted;                                    // 0x0309(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPerformCustomDepthHighlight;                      // 0x030A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30B[0x5];                                      // 0x030B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UMordhauWidgetComponent*                InteractionWidgetComponent;                        // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMordhauWidgetComponent>    InteractionWidgetComponentClass;                   // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMordhauUserWidget>         InteractionWidgetClass;                            // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InteractionWidgetRelativeTransform;                // 0x0330(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAutoDetermineWidgetTransform;                     // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x3];                                      // 0x0361(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutOfBoundsKillTime;                               // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceCorrectionForLeaveSpot;                 // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ReplicatedVehicleFlags;                            // 0x036C(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NetworkSimulatedSmoothRotationTime;                // 0x0370(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookUpLimit;                                       // 0x0374(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookDownLimit;                                     // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedLookUpValue;                             // 0x037C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37D[0x3];                                      // 0x037D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AccumulatedLookLag;                                // 0x0380(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnRateCap;                                       // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnRateCapTarget;                                 // 0x0390(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpValueSmoothingTarget;                        // 0x0394(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpValueSmoothingFrom;                          // 0x0398(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpValueSmoothingStartTime;                     // 0x039C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpValueSmoothingEndTime;                       // 0x03A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookSmoothingSlowAlpha;                            // 0x03A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpRateCap;                                     // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpRateCapTarget;                               // 0x03AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnCapRemaining;                                  // 0x03B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpCapRemaining;                                // 0x03B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpValue;                                       // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseSmoothedLookUpValue;                          // 0x03BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseSmoothingLookUpVelocity;                      // 0x03C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FText>              ActionToDescriptionMap;                            // 0x03C8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x40];                                     // 0x0418(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNetState                              LatestState;                                       // 0x0458(0x0028)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         NetTimeBehind;                                     // 0x0480(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NetSendRate;                                       // 0x0484(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_488[0x30];                                     // 0x0488(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LookUp(float Value, bool bIsAbsolute);
	void LookUpAtRate(float Value);
	void LookUpNotAbsolute(float Value);
	void NetStateSend();
	void OnDeath();
	void OnDied(float Angle, EMordhauDamageType Type, uint8 SubType, class FName bone, const struct FVector& Point, class AActor* Source, class AActor* Agent);
	void OnRep_LatestState();
	void OnRep_ReplicatedLookUpValue();
	void OnRep_ReplicatedVehicleFlags();
	void OnTookDamage(bool bWillKill, EMordhauDamageType Type, uint8 SubType, const class FName& bone, const struct FVector& Point, class AActor* Source, class AActor* Agent);
	class UAudioComponent* PlaySound(class USoundBase* Sound, class FName bone, const struct FVector& InLocation, EAttachLocation AttachLocation, bool bAttach, class USoundAttenuation* Override, float VolumeMultiplier, float PitchMultiplier);
	void PostInteractionWidgetCreated();
	void Server_Reliable_RequestUse();
	void Server_SetForward(float InForward);
	void Server_SetRight(float InRight);
	void Server_Unreliable_LookUp(float NewLookUp);
	class UParticleSystemComponent* SpawnParticlesAttached(class UParticleSystem* Particle, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation AttachType, class FName Socket);

	class AMordhauCharacter* GetDriver() const;
	float GetLookUpValue() const;
	float GetRawLookUpValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleBase">();
	}
	static class AVehicleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVehicleBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AVehicleBase) == 0x000010, "Wrong alignment on AVehicleBase");
static_assert(sizeof(AVehicleBase) == 0x0004C0, "Wrong size on AVehicleBase");
static_assert(offsetof(AVehicleBase, VehicleName) == 0x0002A8, "Member 'AVehicleBase::VehicleName' has a wrong offset!");
static_assert(offsetof(AVehicleBase, VehicleComponent) == 0x0002E0, "Member 'AVehicleBase::VehicleComponent' has a wrong offset!");
static_assert(offsetof(AVehicleBase, DamageableComponent) == 0x0002E8, "Member 'AVehicleBase::DamageableComponent' has a wrong offset!");
static_assert(offsetof(AVehicleBase, HealthStatComponent) == 0x0002F0, "Member 'AVehicleBase::HealthStatComponent' has a wrong offset!");
static_assert(offsetof(AVehicleBase, BurnableComponent) == 0x0002F8, "Member 'AVehicleBase::BurnableComponent' has a wrong offset!");
static_assert(offsetof(AVehicleBase, RagdollPhysicsAsset) == 0x000300, "Member 'AVehicleBase::RagdollPhysicsAsset' has a wrong offset!");
static_assert(offsetof(AVehicleBase, bIsDead) == 0x000308, "Member 'AVehicleBase::bIsDead' has a wrong offset!");
static_assert(offsetof(AVehicleBase, bIsHighlighted) == 0x000309, "Member 'AVehicleBase::bIsHighlighted' has a wrong offset!");
static_assert(offsetof(AVehicleBase, bPerformCustomDepthHighlight) == 0x00030A, "Member 'AVehicleBase::bPerformCustomDepthHighlight' has a wrong offset!");
static_assert(offsetof(AVehicleBase, InteractionWidgetComponent) == 0x000310, "Member 'AVehicleBase::InteractionWidgetComponent' has a wrong offset!");
static_assert(offsetof(AVehicleBase, InteractionWidgetComponentClass) == 0x000318, "Member 'AVehicleBase::InteractionWidgetComponentClass' has a wrong offset!");
static_assert(offsetof(AVehicleBase, InteractionWidgetClass) == 0x000320, "Member 'AVehicleBase::InteractionWidgetClass' has a wrong offset!");
static_assert(offsetof(AVehicleBase, InteractionWidgetRelativeTransform) == 0x000330, "Member 'AVehicleBase::InteractionWidgetRelativeTransform' has a wrong offset!");
static_assert(offsetof(AVehicleBase, bAutoDetermineWidgetTransform) == 0x000360, "Member 'AVehicleBase::bAutoDetermineWidgetTransform' has a wrong offset!");
static_assert(offsetof(AVehicleBase, OutOfBoundsKillTime) == 0x000364, "Member 'AVehicleBase::OutOfBoundsKillTime' has a wrong offset!");
static_assert(offsetof(AVehicleBase, MaxDistanceCorrectionForLeaveSpot) == 0x000368, "Member 'AVehicleBase::MaxDistanceCorrectionForLeaveSpot' has a wrong offset!");
static_assert(offsetof(AVehicleBase, ReplicatedVehicleFlags) == 0x00036C, "Member 'AVehicleBase::ReplicatedVehicleFlags' has a wrong offset!");
static_assert(offsetof(AVehicleBase, NetworkSimulatedSmoothRotationTime) == 0x000370, "Member 'AVehicleBase::NetworkSimulatedSmoothRotationTime' has a wrong offset!");
static_assert(offsetof(AVehicleBase, LookUpLimit) == 0x000374, "Member 'AVehicleBase::LookUpLimit' has a wrong offset!");
static_assert(offsetof(AVehicleBase, LookDownLimit) == 0x000378, "Member 'AVehicleBase::LookDownLimit' has a wrong offset!");
static_assert(offsetof(AVehicleBase, ReplicatedLookUpValue) == 0x00037C, "Member 'AVehicleBase::ReplicatedLookUpValue' has a wrong offset!");
static_assert(offsetof(AVehicleBase, AccumulatedLookLag) == 0x000380, "Member 'AVehicleBase::AccumulatedLookLag' has a wrong offset!");
static_assert(offsetof(AVehicleBase, TurnRateCap) == 0x00038C, "Member 'AVehicleBase::TurnRateCap' has a wrong offset!");
static_assert(offsetof(AVehicleBase, TurnRateCapTarget) == 0x000390, "Member 'AVehicleBase::TurnRateCapTarget' has a wrong offset!");
static_assert(offsetof(AVehicleBase, LookUpValueSmoothingTarget) == 0x000394, "Member 'AVehicleBase::LookUpValueSmoothingTarget' has a wrong offset!");
static_assert(offsetof(AVehicleBase, LookUpValueSmoothingFrom) == 0x000398, "Member 'AVehicleBase::LookUpValueSmoothingFrom' has a wrong offset!");
static_assert(offsetof(AVehicleBase, LookUpValueSmoothingStartTime) == 0x00039C, "Member 'AVehicleBase::LookUpValueSmoothingStartTime' has a wrong offset!");
static_assert(offsetof(AVehicleBase, LookUpValueSmoothingEndTime) == 0x0003A0, "Member 'AVehicleBase::LookUpValueSmoothingEndTime' has a wrong offset!");
static_assert(offsetof(AVehicleBase, LookSmoothingSlowAlpha) == 0x0003A4, "Member 'AVehicleBase::LookSmoothingSlowAlpha' has a wrong offset!");
static_assert(offsetof(AVehicleBase, LookUpRateCap) == 0x0003A8, "Member 'AVehicleBase::LookUpRateCap' has a wrong offset!");
static_assert(offsetof(AVehicleBase, LookUpRateCapTarget) == 0x0003AC, "Member 'AVehicleBase::LookUpRateCapTarget' has a wrong offset!");
static_assert(offsetof(AVehicleBase, TurnCapRemaining) == 0x0003B0, "Member 'AVehicleBase::TurnCapRemaining' has a wrong offset!");
static_assert(offsetof(AVehicleBase, LookUpCapRemaining) == 0x0003B4, "Member 'AVehicleBase::LookUpCapRemaining' has a wrong offset!");
static_assert(offsetof(AVehicleBase, LookUpValue) == 0x0003B8, "Member 'AVehicleBase::LookUpValue' has a wrong offset!");
static_assert(offsetof(AVehicleBase, MouseSmoothedLookUpValue) == 0x0003BC, "Member 'AVehicleBase::MouseSmoothedLookUpValue' has a wrong offset!");
static_assert(offsetof(AVehicleBase, MouseSmoothingLookUpVelocity) == 0x0003C0, "Member 'AVehicleBase::MouseSmoothingLookUpVelocity' has a wrong offset!");
static_assert(offsetof(AVehicleBase, ActionToDescriptionMap) == 0x0003C8, "Member 'AVehicleBase::ActionToDescriptionMap' has a wrong offset!");
static_assert(offsetof(AVehicleBase, LatestState) == 0x000458, "Member 'AVehicleBase::LatestState' has a wrong offset!");
static_assert(offsetof(AVehicleBase, NetTimeBehind) == 0x000480, "Member 'AVehicleBase::NetTimeBehind' has a wrong offset!");
static_assert(offsetof(AVehicleBase, NetSendRate) == 0x000484, "Member 'AVehicleBase::NetSendRate' has a wrong offset!");

// Class Mordhau.JoinMatchmakingMatch
// 0x00E0 (0x0110 - 0x0030)
class UJoinMatchmakingMatch final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(struct FPlayFabMatchmakingMatch& Match)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FPlayFabMatchmakingMatch& Match)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayFabMatchmakingMatch               Match;                                             // 0x0058(0x00B8)(NativeAccessSpecifierPrivate)

public:
	static class UJoinMatchmakingMatch* JoinMatchmakingMatch(const struct FPlayFabMatchmakingMatch& Match_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JoinMatchmakingMatch">();
	}
	static class UJoinMatchmakingMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJoinMatchmakingMatch>();
	}
};
static_assert(alignof(UJoinMatchmakingMatch) == 0x000008, "Wrong alignment on UJoinMatchmakingMatch");
static_assert(sizeof(UJoinMatchmakingMatch) == 0x000110, "Wrong size on UJoinMatchmakingMatch");
static_assert(offsetof(UJoinMatchmakingMatch, onSuccess) == 0x000030, "Member 'UJoinMatchmakingMatch::onSuccess' has a wrong offset!");
static_assert(offsetof(UJoinMatchmakingMatch, onFailure) == 0x000040, "Member 'UJoinMatchmakingMatch::onFailure' has a wrong offset!");
static_assert(offsetof(UJoinMatchmakingMatch, Match) == 0x000058, "Member 'UJoinMatchmakingMatch::Match' has a wrong offset!");

// Class Mordhau.Cannon
// 0x0020 (0x04E0 - 0x04C0)
class ACannon final : public AVehicleBase
{
public:
	float                                         LoadReductionRatio;                                // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HoleSocketName;                                    // 0x04BC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinXYDistanceToLoad;                               // 0x04C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MinZDistanceToLoad;                                // 0x04C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProjectileTurretShooterComponent*      ShooterComponent;                                  // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cannon">();
	}
	static class ACannon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACannon>();
	}
};
static_assert(alignof(ACannon) == 0x000010, "Wrong alignment on ACannon");
static_assert(sizeof(ACannon) == 0x0004E0, "Wrong size on ACannon");
static_assert(offsetof(ACannon, LoadReductionRatio) == 0x0004B8, "Member 'ACannon::LoadReductionRatio' has a wrong offset!");
static_assert(offsetof(ACannon, HoleSocketName) == 0x0004BC, "Member 'ACannon::HoleSocketName' has a wrong offset!");
static_assert(offsetof(ACannon, MinXYDistanceToLoad) == 0x0004C4, "Member 'ACannon::MinXYDistanceToLoad' has a wrong offset!");
static_assert(offsetof(ACannon, MinZDistanceToLoad) == 0x0004C8, "Member 'ACannon::MinZDistanceToLoad' has a wrong offset!");
static_assert(offsetof(ACannon, ShooterComponent) == 0x0004D0, "Member 'ACannon::ShooterComponent' has a wrong offset!");

// Class Mordhau.CannonMovementComponent
// 0x0020 (0x02B0 - 0x0290)
class UCannonMovementComponent final : public USimpleWheeledVehicleMovementComponent
{
public:
	float                                         DriveTorque;                                       // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DriveWheelAngle;                                   // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotateTorque;                                      // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotateWheelAngle;                                  // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakeStrength;                                     // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Bias;                                              // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CannonMovementComponent">();
	}
	static class UCannonMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCannonMovementComponent>();
	}
};
static_assert(alignof(UCannonMovementComponent) == 0x000008, "Wrong alignment on UCannonMovementComponent");
static_assert(sizeof(UCannonMovementComponent) == 0x0002B0, "Wrong size on UCannonMovementComponent");
static_assert(offsetof(UCannonMovementComponent, DriveTorque) == 0x000290, "Member 'UCannonMovementComponent::DriveTorque' has a wrong offset!");
static_assert(offsetof(UCannonMovementComponent, DriveWheelAngle) == 0x000294, "Member 'UCannonMovementComponent::DriveWheelAngle' has a wrong offset!");
static_assert(offsetof(UCannonMovementComponent, RotateTorque) == 0x000298, "Member 'UCannonMovementComponent::RotateTorque' has a wrong offset!");
static_assert(offsetof(UCannonMovementComponent, RotateWheelAngle) == 0x00029C, "Member 'UCannonMovementComponent::RotateWheelAngle' has a wrong offset!");
static_assert(offsetof(UCannonMovementComponent, BrakeStrength) == 0x0002A0, "Member 'UCannonMovementComponent::BrakeStrength' has a wrong offset!");
static_assert(offsetof(UCannonMovementComponent, Bias) == 0x0002A4, "Member 'UCannonMovementComponent::Bias' has a wrong offset!");

// Class Mordhau.PlayCharacterSound
// 0x0030 (0x0068 - 0x0038)
class UPlayCharacterSound final : public UAnimNotify
{
public:
	class USoundBase*                             Sound;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   bone;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0048(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               AttachLocation;                                    // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttach;                                           // 0x0055(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      Override;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayCharacterSound">();
	}
	static class UPlayCharacterSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayCharacterSound>();
	}
};
static_assert(alignof(UPlayCharacterSound) == 0x000008, "Wrong alignment on UPlayCharacterSound");
static_assert(sizeof(UPlayCharacterSound) == 0x000068, "Wrong size on UPlayCharacterSound");
static_assert(offsetof(UPlayCharacterSound, Sound) == 0x000038, "Member 'UPlayCharacterSound::Sound' has a wrong offset!");
static_assert(offsetof(UPlayCharacterSound, bone) == 0x000040, "Member 'UPlayCharacterSound::bone' has a wrong offset!");
static_assert(offsetof(UPlayCharacterSound, Location) == 0x000048, "Member 'UPlayCharacterSound::Location' has a wrong offset!");
static_assert(offsetof(UPlayCharacterSound, AttachLocation) == 0x000054, "Member 'UPlayCharacterSound::AttachLocation' has a wrong offset!");
static_assert(offsetof(UPlayCharacterSound, bAttach) == 0x000055, "Member 'UPlayCharacterSound::bAttach' has a wrong offset!");
static_assert(offsetof(UPlayCharacterSound, Override) == 0x000058, "Member 'UPlayCharacterSound::Override' has a wrong offset!");
static_assert(offsetof(UPlayCharacterSound, VolumeMultiplier) == 0x000060, "Member 'UPlayCharacterSound::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UPlayCharacterSound, PitchMultiplier) == 0x000064, "Member 'UPlayCharacterSound::PitchMultiplier' has a wrong offset!");

// Class Mordhau.CapturePointBanner
// 0x0028 (0x0248 - 0x0220)
class ACapturePointBanner : public AActor
{
public:
	class AControlPoint*                          ControlPoint;                                      // 0x0220(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureProgress;                                   // 0x0228(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RopeMaterialIndex;                                 // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlagMaterialIndex;                                 // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RopeSpeed;                                         // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               RopeMaterialInstance;                              // 0x0238(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               FlagMaterialInstance;                              // 0x0240(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void InitializeBanner(class AControlPoint* OwningPoint);
	void UpdateVisuals();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CapturePointBanner">();
	}
	static class ACapturePointBanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACapturePointBanner>();
	}
};
static_assert(alignof(ACapturePointBanner) == 0x000008, "Wrong alignment on ACapturePointBanner");
static_assert(sizeof(ACapturePointBanner) == 0x000248, "Wrong size on ACapturePointBanner");
static_assert(offsetof(ACapturePointBanner, ControlPoint) == 0x000220, "Member 'ACapturePointBanner::ControlPoint' has a wrong offset!");
static_assert(offsetof(ACapturePointBanner, CaptureProgress) == 0x000228, "Member 'ACapturePointBanner::CaptureProgress' has a wrong offset!");
static_assert(offsetof(ACapturePointBanner, RopeMaterialIndex) == 0x00022C, "Member 'ACapturePointBanner::RopeMaterialIndex' has a wrong offset!");
static_assert(offsetof(ACapturePointBanner, FlagMaterialIndex) == 0x000230, "Member 'ACapturePointBanner::FlagMaterialIndex' has a wrong offset!");
static_assert(offsetof(ACapturePointBanner, RopeSpeed) == 0x000234, "Member 'ACapturePointBanner::RopeSpeed' has a wrong offset!");
static_assert(offsetof(ACapturePointBanner, RopeMaterialInstance) == 0x000238, "Member 'ACapturePointBanner::RopeMaterialInstance' has a wrong offset!");
static_assert(offsetof(ACapturePointBanner, FlagMaterialInstance) == 0x000240, "Member 'ACapturePointBanner::FlagMaterialInstance' has a wrong offset!");

// Class Mordhau.Catapult
// 0x0000 (0x04C0 - 0x04C0)
class ACatapult : public AVehicleBase
{
public:
	class UProjectileArmShooterComponent*         ProjectileArmShooter;                              // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Catapult">();
	}
	static class ACatapult* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACatapult>();
	}
};
static_assert(alignof(ACatapult) == 0x000010, "Wrong alignment on ACatapult");
static_assert(sizeof(ACatapult) == 0x0004C0, "Wrong size on ACatapult");
static_assert(offsetof(ACatapult, ProjectileArmShooter) == 0x0004B8, "Member 'ACatapult::ProjectileArmShooter' has a wrong offset!");

// Class Mordhau.MordhauEngineMessage
// 0x0000 (0x0028 - 0x0028)
class UMordhauEngineMessage final : public ULocalMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauEngineMessage">();
	}
	static class UMordhauEngineMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauEngineMessage>();
	}
};
static_assert(alignof(UMordhauEngineMessage) == 0x000008, "Wrong alignment on UMordhauEngineMessage");
static_assert(sizeof(UMordhauEngineMessage) == 0x000028, "Wrong size on UMordhauEngineMessage");

// Class Mordhau.CatapultMovementComponent
// 0x0038 (0x02C8 - 0x0290)
class UCatapultMovementComponent final : public USimpleWheeledVehicleMovementComponent
{
public:
	float                                         DriveTorque;                                       // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DriveWheelAngle;                                   // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotateFrontTorque;                                 // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotateRearTorque;                                  // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotateFrontWheelAngle;                             // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotateRearWheelAngle;                              // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakeStrength;                                     // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Bias;                                              // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StuckVelocity;                                     // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x14];                                     // 0x02B4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CatapultMovementComponent">();
	}
	static class UCatapultMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCatapultMovementComponent>();
	}
};
static_assert(alignof(UCatapultMovementComponent) == 0x000008, "Wrong alignment on UCatapultMovementComponent");
static_assert(sizeof(UCatapultMovementComponent) == 0x0002C8, "Wrong size on UCatapultMovementComponent");
static_assert(offsetof(UCatapultMovementComponent, DriveTorque) == 0x000290, "Member 'UCatapultMovementComponent::DriveTorque' has a wrong offset!");
static_assert(offsetof(UCatapultMovementComponent, DriveWheelAngle) == 0x000294, "Member 'UCatapultMovementComponent::DriveWheelAngle' has a wrong offset!");
static_assert(offsetof(UCatapultMovementComponent, RotateFrontTorque) == 0x000298, "Member 'UCatapultMovementComponent::RotateFrontTorque' has a wrong offset!");
static_assert(offsetof(UCatapultMovementComponent, RotateRearTorque) == 0x00029C, "Member 'UCatapultMovementComponent::RotateRearTorque' has a wrong offset!");
static_assert(offsetof(UCatapultMovementComponent, RotateFrontWheelAngle) == 0x0002A0, "Member 'UCatapultMovementComponent::RotateFrontWheelAngle' has a wrong offset!");
static_assert(offsetof(UCatapultMovementComponent, RotateRearWheelAngle) == 0x0002A4, "Member 'UCatapultMovementComponent::RotateRearWheelAngle' has a wrong offset!");
static_assert(offsetof(UCatapultMovementComponent, BrakeStrength) == 0x0002A8, "Member 'UCatapultMovementComponent::BrakeStrength' has a wrong offset!");
static_assert(offsetof(UCatapultMovementComponent, Bias) == 0x0002AC, "Member 'UCatapultMovementComponent::Bias' has a wrong offset!");
static_assert(offsetof(UCatapultMovementComponent, StuckVelocity) == 0x0002B0, "Member 'UCatapultMovementComponent::StuckVelocity' has a wrong offset!");

// Class Mordhau.ChangeLevelCommand
// 0x0000 (0x0080 - 0x0080)
class UChangeLevelCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeLevelCommand">();
	}
	static class UChangeLevelCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeLevelCommand>();
	}
};
static_assert(alignof(UChangeLevelCommand) == 0x000008, "Wrong alignment on UChangeLevelCommand");
static_assert(sizeof(UChangeLevelCommand) == 0x000080, "Wrong size on UChangeLevelCommand");

// Class Mordhau.MordhauLevelScriptActor
// 0x0000 (0x0228 - 0x0228)
class AMordhauLevelScriptActor final : public ALevelScriptActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauLevelScriptActor">();
	}
	static class AMordhauLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauLevelScriptActor>();
	}
};
static_assert(alignof(AMordhauLevelScriptActor) == 0x000008, "Wrong alignment on AMordhauLevelScriptActor");
static_assert(sizeof(AMordhauLevelScriptActor) == 0x000228, "Wrong size on AMordhauLevelScriptActor");

// Class Mordhau.ChangeTeamCommand
// 0x0000 (0x0080 - 0x0080)
class UChangeTeamCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeTeamCommand">();
	}
	static class UChangeTeamCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeTeamCommand>();
	}
};
static_assert(alignof(UChangeTeamCommand) == 0x000008, "Wrong alignment on UChangeTeamCommand");
static_assert(sizeof(UChangeTeamCommand) == 0x000080, "Wrong size on UChangeTeamCommand");

// Class Mordhau.CharacterBurnableComponent
// 0x0008 (0x0140 - 0x0138)
class UCharacterBurnableComponent final : public UBurnableComponent
{
public:
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterBurnableComponent">();
	}
	static class UCharacterBurnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterBurnableComponent>();
	}
};
static_assert(alignof(UCharacterBurnableComponent) == 0x000008, "Wrong alignment on UCharacterBurnableComponent");
static_assert(sizeof(UCharacterBurnableComponent) == 0x000140, "Wrong size on UCharacterBurnableComponent");

// Class Mordhau.MordhauGameUserSettings
// 0x0218 (0x0338 - 0x0120)
class UMordhauGameUserSettings final : public UGameUserSettings
{
public:
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnSettingsChanged;                                 // 0x0128(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         AvailableLanguages;                                // 0x0148(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint32                                        MordhauVersion;                                    // 0x0158(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Language;                                          // 0x0160(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Gore;                                              // 0x0170(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ProfanityFilter;                                   // 0x0174(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ThirdPersonDeathCamera;                            // 0x0178(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CharacterCloth;                                    // 0x017C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FriendlyMarkers;                                   // 0x0180(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HideDefaultLoadouts;                               // 0x0184(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NoTeamColorsOnGear;                                // 0x0188(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Headbob;                                           // 0x018C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementHeadbob;                                   // 0x0190(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CombatHeadbob;                                     // 0x0194(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxRagdolls;                                       // 0x0198(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RagdollStayTime;                                   // 0x019C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseSmoothing;                                    // 0x01A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RangedSensitivity;                                 // 0x01A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ForceFeedback;                                     // 0x01A8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DrawTracers;                                       // 0x01AC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DrawTracersStayTime;                               // 0x01B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShowServerInScoreboard;                            // 0x01B8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CrosshairType;                                     // 0x01BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowKilledBy;                                      // 0x01C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowStatusBar;                                     // 0x01C4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowTargetInfo;                                    // 0x01C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowSpawnInfo;                                     // 0x01CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowChatBox;                                       // 0x01D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowEmotesMenu;                                    // 0x01D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowEquipment;                                     // 0x01D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowAmmo;                                          // 0x01DC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowAnnouncements;                                 // 0x01E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowTips;                                          // 0x01E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowObjectives;                                    // 0x01E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowHitMarker;                                     // 0x01EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowScoreFeed;                                     // 0x01F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowCombatHints;                                   // 0x01F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowKillFeed;                                      // 0x01F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         QuickSpawn;                                        // 0x01FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowObservedDelay;                                 // 0x0200(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HideWatermark;                                     // 0x0204(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShowInteractionChecks;                             // 0x0208(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScreenPercentage;                                  // 0x020C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FieldOfView;                                       // 0x0210(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraDistance;                                    // 0x0214(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Gamma;                                             // 0x0218(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NvidiaReflex;                                      // 0x021C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AntiAliasing;                                      // 0x0220(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IndirectCapsuleShadows;                            // 0x0224(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CharacterFidelity;                                 // 0x0228(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RagdollFidelity;                                   // 0x022C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ScreenSpaceReflections;                            // 0x0230(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Bloom;                                             // 0x0234(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MotionBlur;                                        // 0x0238(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AmbientOcclusion;                                  // 0x023C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LensFlares;                                        // 0x0240(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MasterVolume;                                      // 0x0244(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EffectsVolume;                                     // 0x0248(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MusicVolume;                                       // 0x024C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VideoVolume;                                       // 0x0250(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VoiceVolume;                                       // 0x0254(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InstrumentsVolume;                                 // 0x0258(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCrossplayEnabled;                                 // 0x025C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EServerRegion                                 CasualMatchmakingRegion;                           // 0x025D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EServerRegion                                 RankedMatchmakingRegion;                           // 0x025E(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F[0x1];                                      // 0x025F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         CasualMatchmakingGameModes;                        // 0x0260(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         RankedMatchmakingGameModes;                        // 0x0270(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, struct FPlayerCountArray> SelectedGameModePlayerCounts;                      // 0x0280(0x0050)(Config, Protected, NativeAccessSpecifierProtected)
	bool                                          bServerBrowserIsOfficial;                          // 0x02D0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bServerBrowserConsoleServer;                       // 0x02D1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bServerBrowserNotFull;                             // 0x02D2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bServerBrowserHasPlayers;                          // 0x02D3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bServerBrowserNoPassword;                          // 0x02D4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerBrowserServerName;                           // 0x02D8(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ServerBrowserGameMode;                             // 0x02E8(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ServerBrowserMaxPing;                              // 0x02F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerBrowserSortType;                             // 0x0300(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         FavoriteServers;                                   // 0x0310(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         RecentServers;                                     // 0x0320(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         ServerTypeFilter;                                  // 0x0330(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ServerPopulationFilter;                            // 0x0331(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ServerModdedFilter;                                // 0x0332(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ServerPasswordFilter;                              // 0x0333(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlatformSpecific                             PlatformSpecific;                                  // 0x0334(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_335[0x3];                                      // 0x0335(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAudioVolumes();
	void CheckAndUpdateDeviceSpecificParameters();
	bool GetCrossplayEnabled();
	EPlatformSpecific GetPlatformSpecific();
	bool GetPSNLockEnabledValue();
	TArray<int32> GetSelectedGameModePlayerCounts(const class FString& GameMode);
	uint8 GetServerFilterValue(EServerFilterCategories FilterCategory);
	void SetAmbientOcclusion(int32 NewAmbientOcclusion);
	void SetAntiAliasing(int32 NewAntiAliasing);
	void SetBloom(float NewBloom);
	void SetCameraDistance(float NewCameraDistance);
	void SetCasualMatchmakingGameModes(const TArray<class FString>& NewGameModes);
	void SetCasualMatchmakingRegion(EServerRegion NewRegion);
	void SetCharacterCloth(int32 NewCharacterCloth);
	void SetCharacterFidelity(int32 NewFidelity);
	void SetCombatHeadbob(float NewCombatHeadbob);
	void SetCrosshairType(int32 NewCrosshairType);
	void SetCrossplayEnabled(bool NewValue);
	void SetDefaultRangedSensitivity();
	void SetDrawTracers(int32 NewDrawTracers);
	void SetEffectsVolume(float NewVolume);
	void SetFavoriteServers(const TArray<class FString>& NewFavoriteServers);
	void SetFieldOfView(float NewFOV);
	void SetForceFeedbackEnabled(bool Enabled);
	void SetFriendlyMarkers(int32 NewFriendlyMarkers);
	void SetGamma(float NewGamma);
	void SetGore(int32 NewGore);
	void SetHeadbob(float NewHeadbob);
	void SetHideDefaultLoadouts(int32 NewHideDefaultLoadouts);
	void SetHideHUD(int32 NewHideHUD);
	void SetHideWatermark(int32 NewHideWatermark);
	void SetIndirectCapsuleShadows(int32 NewShadows);
	void SetInstrumentsVolume(float NewVolume);
	void SetLanguage(const class FString& NewLanguage);
	void SetLensFlares(int32 NewLensFlares);
	void SetMasterVolume(float NewVolume);
	void SetMaxRagdolls(int32 NewMax);
	void SetMotionBlur(float NewMotionBlur);
	void SetMouseSmoothing(float NewSmoothing);
	void SetMovementHeadbob(float NewMovementHeadbob);
	void SetMusicVolume(float NewVolume);
	void SetNoTeamColorsOnGear(int32 NewNoTeamColorsOnGear);
	void SetNvidiaReflex(int32 NewNvidiaReflex);
	void SetPlatformSpecific(EPlatformSpecific NewValue);
	void SetProfanityFilter(int32 NewProfanityFilter);
	void SetQuickSpawn(int32 NewQuickSpawn);
	void SetRagdollFidelity(int32 NewFidelity);
	void SetRagdollStayTime(float NewTime);
	void SetRangedSensitivity(float NewRangedSensitivity);
	void SetRankedMatchmakingGameModes(const TArray<class FString>& NewGameModes);
	void SetRankedMatchmakingRegion(EServerRegion NewRegion);
	void SetRecentServers(const TArray<class FString>& NewRecentServers);
	void SetScreenPercentage(float NewScreenPercentage);
	void SetScreenSpaceReflections(int32 NewScreenSpaceReflections);
	void SetSelectedGameModePlayerCounts(const class FString& GameMode, const TArray<int32>& SelectedPlayerCounts);
	void SetServerBrowserGameMode(const class FString& NewGameMode);
	void SetServerBrowserHasPlayers(bool bNewHasPlayers);
	void SetServerBrowserIsConsoleServer(bool bNewIsOfficial);
	void SetServerBrowserIsOfficial(bool bNewIsOfficial);
	void SetServerBrowserMaxPing(int32 NewMaxPing);
	void SetServerBrowserNoPassword(bool bNewNoPassword);
	void SetServerBrowserNotFull(bool bNewNotFull);
	void SetServerBrowserServerName(const class FString& NewServerName);
	void SetServerBrowserSortType(const class FString& NewSortType);
	void SetServerFilter(EServerFilterCategories FilterCategory, uint8 Value);
	void SetShowAmmo(int32 NewShowAmmo);
	void SetShowAnnouncements(int32 NewShowAnnouncements);
	void SetShowChatBox(int32 NewShowChatBox);
	void SetShowCombatHints(int32 NewShowCombatHints);
	void SetShowEmotesMenu(int32 NewEmotesMenu);
	void SetShowEquipment(int32 NewShowEquipment);
	void SetShowHitMarker(int32 NewShowHitMarker);
	void SetShowKilledBy(int32 NewShowKilledBy);
	void SetShowKillFeed(int32 NewShowKillFeed);
	void SetShowMatchmakingDebug(int32 NewShowMatchmakingDebug);
	void SetShowObjectives(int32 NewShowObjectives);
	void SetShowObservedDelay(int32 NewShowObservedDelay);
	void SetShowScoreFeed(int32 NewShowScoreFeed);
	void SetShowServerInScoreboard(int32 NewShowServerInScoreboard);
	void SetShowSpawnInfo(int32 NewShowSpawnInfo);
	void SetShowStatusBar(int32 NewShowStatusBar);
	void SetShowTargetInfo(int32 NewShowTargetInfo);
	void SetShowTips(int32 NewShowTips);
	void SetThirdPersonDeathcamera(int32 NewThirdPersonDeathCamera);
	void SetTracersStayTime(float NewStayTime);
	void SetVideoVolume(float NewVolume);
	void SetVoiceVolume(float NewVolume);

	void ApplyTextureQualityUsingTextureGroups(int32 Quality) const;
	int32 GetActualCrosshairType() const;
	int32 GetAmbientOcclusion() const;
	int32 GetAntiAliasing() const;
	void GetAvailableLanguages(TArray<class FString>* AvailableLanguages_0) const;
	float GetBloom() const;
	struct FVector2D GetBloomLimits() const;
	float GetCameraDistance() const;
	struct FVector2D GetCameraDistanceLimits() const;
	TArray<class FString> GetCasualMatchmakingGameModes() const;
	EServerRegion GetCasualMatchmakingRegion() const;
	int32 GetCharacterCloth() const;
	int32 GetCharacterFidelity() const;
	float GetCombatHeadbob() const;
	struct FVector2D GetCombatHeadbobLimits() const;
	int32 GetCrosshairType() const;
	float GetCurrentBloom() const;
	float GetCurrentGamma() const;
	float GetCurrentMotionBlur() const;
	int32 GetDrawTracers() const;
	float GetEffectsVolume() const;
	TArray<class FString> GetFavoriteServers() const;
	float GetFieldOfView() const;
	struct FVector2D GetFieldOfViewLimits() const;
	bool GetForceFeedbackEnabled() const;
	struct FVector2D GetFrameRateLimits() const;
	int32 GetFriendlyMarkers() const;
	float GetGamma() const;
	struct FVector2D GetGammaLimits() const;
	int32 GetGore() const;
	float GetHeadbob() const;
	struct FVector2D GetHeadbobLimits() const;
	int32 GetHideDefaultLoadouts() const;
	int32 GetHideHUD() const;
	int32 GetHideWatermark() const;
	int32 GetIndirectCapsuleShadows() const;
	float GetInstrumentsVolume() const;
	class FString GetLanguage() const;
	int32 GetLensFlares() const;
	float GetMasterVolume() const;
	int32 GetMaxRagdolls() const;
	int32 GetMaxRagdollsLimit() const;
	float GetMotionBlur() const;
	struct FVector2D GetMotionBlurLimits() const;
	float GetMouseSmoothing() const;
	struct FVector2D GetMouseSmoothingLimits() const;
	float GetMovementHeadbob() const;
	struct FVector2D GetMovementHeadbobLimits() const;
	float GetMusicVolume() const;
	int32 GetNoTeamColorsOnGear() const;
	int32 GetNvidiaReflex() const;
	int32 GetProfanityFilter() const;
	int32 GetQuickSpawn() const;
	int32 GetRagdollFidelity() const;
	float GetRagdollStayTime() const;
	float GetRagdollStayTimeLimit() const;
	float GetRangedSensitivity() const;
	struct FVector2D GetRangedSensitivityLimits() const;
	TArray<class FString> GetRankedMatchmakingGameModes() const;
	EServerRegion GetRankedMatchmakingRegion() const;
	TArray<class FString> GetRecentServers() const;
	float GetScreenPercentage() const;
	struct FVector2D GetScreenPercentageLimits() const;
	int32 GetScreenSpaceReflections() const;
	class FString GetServerBrowserGameMode() const;
	bool GetServerBrowserHasPlayers() const;
	bool GetServerBrowserIsConsoleServer() const;
	bool GetServerBrowserIsOfficial() const;
	int32 GetServerBrowserMaxPing() const;
	bool GetServerBrowserNoPassword() const;
	bool GetServerBrowserNotFull() const;
	class FString GetServerBrowserServerName() const;
	class FString GetServerBrowserSortType() const;
	int32 GetShowAmmo() const;
	int32 GetShowAnnouncements() const;
	int32 GetShowChatBox() const;
	int32 GetShowCombatHints() const;
	int32 GetShowEmotesMenu() const;
	int32 GetShowEquipment() const;
	int32 GetShowHitMarker() const;
	int32 GetShowKilledBy() const;
	int32 GetShowKillFeed() const;
	int32 GetShowObjectives() const;
	int32 GetShowObservedDelay() const;
	int32 GetShowScoreFeed() const;
	int32 GetShowServerInScoreboard() const;
	int32 GetShowSpawnInfo() const;
	int32 GetShowStatusBar() const;
	int32 GetShowTargetInfo() const;
	int32 GetShowTips() const;
	int32 GetThirdPersonDeathCamera() const;
	float GetTracersStayTime() const;
	struct FVector2D GetTracersStayTimeLimits() const;
	float GetVideoVolume() const;
	float GetVoiceVolume() const;
	class FString GetXboxSandboxID() const;
	bool ShouldDrawTracers() const;
	bool ShouldQuickSpawn() const;
	bool ShouldShowAmmo() const;
	bool ShouldShowAnnouncements() const;
	bool ShouldShowBlood() const;
	bool ShouldShowChatBox() const;
	bool ShouldShowEmotesMenu() const;
	bool ShouldShowEquipment() const;
	bool ShouldShowHitMarker() const;
	bool ShouldShowHUD() const;
	bool ShouldShowKilledBy() const;
	bool ShouldShowKillFeed() const;
	bool ShouldShowMatchmakingDebug() const;
	bool ShouldShowObjectives() const;
	bool ShouldShowObservedDelay() const;
	bool ShouldShowScoreFeed() const;
	bool ShouldShowServerInScoreboard() const;
	bool ShouldShowSpawnInfo() const;
	bool ShouldShowStatusBar() const;
	bool ShouldShowTargetInfo() const;
	bool ShouldShowTips() const;
	bool ShouldShowWatermark() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauGameUserSettings">();
	}
	static class UMordhauGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauGameUserSettings>();
	}
};
static_assert(alignof(UMordhauGameUserSettings) == 0x000008, "Wrong alignment on UMordhauGameUserSettings");
static_assert(sizeof(UMordhauGameUserSettings) == 0x000338, "Wrong size on UMordhauGameUserSettings");
static_assert(offsetof(UMordhauGameUserSettings, OnSettingsChanged) == 0x000128, "Member 'UMordhauGameUserSettings::OnSettingsChanged' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, AvailableLanguages) == 0x000148, "Member 'UMordhauGameUserSettings::AvailableLanguages' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, MordhauVersion) == 0x000158, "Member 'UMordhauGameUserSettings::MordhauVersion' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, Language) == 0x000160, "Member 'UMordhauGameUserSettings::Language' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, Gore) == 0x000170, "Member 'UMordhauGameUserSettings::Gore' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ProfanityFilter) == 0x000174, "Member 'UMordhauGameUserSettings::ProfanityFilter' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ThirdPersonDeathCamera) == 0x000178, "Member 'UMordhauGameUserSettings::ThirdPersonDeathCamera' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, CharacterCloth) == 0x00017C, "Member 'UMordhauGameUserSettings::CharacterCloth' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, FriendlyMarkers) == 0x000180, "Member 'UMordhauGameUserSettings::FriendlyMarkers' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, HideDefaultLoadouts) == 0x000184, "Member 'UMordhauGameUserSettings::HideDefaultLoadouts' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, NoTeamColorsOnGear) == 0x000188, "Member 'UMordhauGameUserSettings::NoTeamColorsOnGear' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, Headbob) == 0x00018C, "Member 'UMordhauGameUserSettings::Headbob' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, MovementHeadbob) == 0x000190, "Member 'UMordhauGameUserSettings::MovementHeadbob' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, CombatHeadbob) == 0x000194, "Member 'UMordhauGameUserSettings::CombatHeadbob' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, MaxRagdolls) == 0x000198, "Member 'UMordhauGameUserSettings::MaxRagdolls' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, RagdollStayTime) == 0x00019C, "Member 'UMordhauGameUserSettings::RagdollStayTime' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, MouseSmoothing) == 0x0001A0, "Member 'UMordhauGameUserSettings::MouseSmoothing' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, RangedSensitivity) == 0x0001A4, "Member 'UMordhauGameUserSettings::RangedSensitivity' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ForceFeedback) == 0x0001A8, "Member 'UMordhauGameUserSettings::ForceFeedback' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, DrawTracers) == 0x0001AC, "Member 'UMordhauGameUserSettings::DrawTracers' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, DrawTracersStayTime) == 0x0001B0, "Member 'UMordhauGameUserSettings::DrawTracersStayTime' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowServerInScoreboard) == 0x0001B8, "Member 'UMordhauGameUserSettings::ShowServerInScoreboard' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, CrosshairType) == 0x0001BC, "Member 'UMordhauGameUserSettings::CrosshairType' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowKilledBy) == 0x0001C0, "Member 'UMordhauGameUserSettings::ShowKilledBy' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowStatusBar) == 0x0001C4, "Member 'UMordhauGameUserSettings::ShowStatusBar' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowTargetInfo) == 0x0001C8, "Member 'UMordhauGameUserSettings::ShowTargetInfo' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowSpawnInfo) == 0x0001CC, "Member 'UMordhauGameUserSettings::ShowSpawnInfo' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowChatBox) == 0x0001D0, "Member 'UMordhauGameUserSettings::ShowChatBox' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowEmotesMenu) == 0x0001D4, "Member 'UMordhauGameUserSettings::ShowEmotesMenu' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowEquipment) == 0x0001D8, "Member 'UMordhauGameUserSettings::ShowEquipment' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowAmmo) == 0x0001DC, "Member 'UMordhauGameUserSettings::ShowAmmo' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowAnnouncements) == 0x0001E0, "Member 'UMordhauGameUserSettings::ShowAnnouncements' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowTips) == 0x0001E4, "Member 'UMordhauGameUserSettings::ShowTips' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowObjectives) == 0x0001E8, "Member 'UMordhauGameUserSettings::ShowObjectives' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowHitMarker) == 0x0001EC, "Member 'UMordhauGameUserSettings::ShowHitMarker' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowScoreFeed) == 0x0001F0, "Member 'UMordhauGameUserSettings::ShowScoreFeed' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowCombatHints) == 0x0001F4, "Member 'UMordhauGameUserSettings::ShowCombatHints' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowKillFeed) == 0x0001F8, "Member 'UMordhauGameUserSettings::ShowKillFeed' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, QuickSpawn) == 0x0001FC, "Member 'UMordhauGameUserSettings::QuickSpawn' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowObservedDelay) == 0x000200, "Member 'UMordhauGameUserSettings::ShowObservedDelay' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, HideWatermark) == 0x000204, "Member 'UMordhauGameUserSettings::HideWatermark' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ShowInteractionChecks) == 0x000208, "Member 'UMordhauGameUserSettings::ShowInteractionChecks' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ScreenPercentage) == 0x00020C, "Member 'UMordhauGameUserSettings::ScreenPercentage' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, FieldOfView) == 0x000210, "Member 'UMordhauGameUserSettings::FieldOfView' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, CameraDistance) == 0x000214, "Member 'UMordhauGameUserSettings::CameraDistance' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, Gamma) == 0x000218, "Member 'UMordhauGameUserSettings::Gamma' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, NvidiaReflex) == 0x00021C, "Member 'UMordhauGameUserSettings::NvidiaReflex' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, AntiAliasing) == 0x000220, "Member 'UMordhauGameUserSettings::AntiAliasing' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, IndirectCapsuleShadows) == 0x000224, "Member 'UMordhauGameUserSettings::IndirectCapsuleShadows' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, CharacterFidelity) == 0x000228, "Member 'UMordhauGameUserSettings::CharacterFidelity' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, RagdollFidelity) == 0x00022C, "Member 'UMordhauGameUserSettings::RagdollFidelity' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ScreenSpaceReflections) == 0x000230, "Member 'UMordhauGameUserSettings::ScreenSpaceReflections' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, Bloom) == 0x000234, "Member 'UMordhauGameUserSettings::Bloom' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, MotionBlur) == 0x000238, "Member 'UMordhauGameUserSettings::MotionBlur' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, AmbientOcclusion) == 0x00023C, "Member 'UMordhauGameUserSettings::AmbientOcclusion' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, LensFlares) == 0x000240, "Member 'UMordhauGameUserSettings::LensFlares' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, MasterVolume) == 0x000244, "Member 'UMordhauGameUserSettings::MasterVolume' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, EffectsVolume) == 0x000248, "Member 'UMordhauGameUserSettings::EffectsVolume' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, MusicVolume) == 0x00024C, "Member 'UMordhauGameUserSettings::MusicVolume' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, VideoVolume) == 0x000250, "Member 'UMordhauGameUserSettings::VideoVolume' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, VoiceVolume) == 0x000254, "Member 'UMordhauGameUserSettings::VoiceVolume' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, InstrumentsVolume) == 0x000258, "Member 'UMordhauGameUserSettings::InstrumentsVolume' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, bCrossplayEnabled) == 0x00025C, "Member 'UMordhauGameUserSettings::bCrossplayEnabled' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, CasualMatchmakingRegion) == 0x00025D, "Member 'UMordhauGameUserSettings::CasualMatchmakingRegion' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, RankedMatchmakingRegion) == 0x00025E, "Member 'UMordhauGameUserSettings::RankedMatchmakingRegion' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, CasualMatchmakingGameModes) == 0x000260, "Member 'UMordhauGameUserSettings::CasualMatchmakingGameModes' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, RankedMatchmakingGameModes) == 0x000270, "Member 'UMordhauGameUserSettings::RankedMatchmakingGameModes' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, SelectedGameModePlayerCounts) == 0x000280, "Member 'UMordhauGameUserSettings::SelectedGameModePlayerCounts' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, bServerBrowserIsOfficial) == 0x0002D0, "Member 'UMordhauGameUserSettings::bServerBrowserIsOfficial' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, bServerBrowserConsoleServer) == 0x0002D1, "Member 'UMordhauGameUserSettings::bServerBrowserConsoleServer' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, bServerBrowserNotFull) == 0x0002D2, "Member 'UMordhauGameUserSettings::bServerBrowserNotFull' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, bServerBrowserHasPlayers) == 0x0002D3, "Member 'UMordhauGameUserSettings::bServerBrowserHasPlayers' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, bServerBrowserNoPassword) == 0x0002D4, "Member 'UMordhauGameUserSettings::bServerBrowserNoPassword' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ServerBrowserServerName) == 0x0002D8, "Member 'UMordhauGameUserSettings::ServerBrowserServerName' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ServerBrowserGameMode) == 0x0002E8, "Member 'UMordhauGameUserSettings::ServerBrowserGameMode' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ServerBrowserMaxPing) == 0x0002F8, "Member 'UMordhauGameUserSettings::ServerBrowserMaxPing' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ServerBrowserSortType) == 0x000300, "Member 'UMordhauGameUserSettings::ServerBrowserSortType' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, FavoriteServers) == 0x000310, "Member 'UMordhauGameUserSettings::FavoriteServers' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, RecentServers) == 0x000320, "Member 'UMordhauGameUserSettings::RecentServers' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ServerTypeFilter) == 0x000330, "Member 'UMordhauGameUserSettings::ServerTypeFilter' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ServerPopulationFilter) == 0x000331, "Member 'UMordhauGameUserSettings::ServerPopulationFilter' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ServerModdedFilter) == 0x000332, "Member 'UMordhauGameUserSettings::ServerModdedFilter' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, ServerPasswordFilter) == 0x000333, "Member 'UMordhauGameUserSettings::ServerPasswordFilter' has a wrong offset!");
static_assert(offsetof(UMordhauGameUserSettings, PlatformSpecific) == 0x000334, "Member 'UMordhauGameUserSettings::PlatformSpecific' has a wrong offset!");

// Class Mordhau.CharacterFace
// 0x0478 (0x04D8 - 0x0060)
class UCharacterFace : public UMordhauInventoryItem
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0060(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Albedo;                                            // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Normal;                                            // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             AgedNormal;                                        // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             PBRMap;                                            // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             TorsoAlbedo;                                       // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             TorsoNormal;                                       // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             TorsoPBRMap;                                       // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Arms1PAlbedo;                                      // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Arms1PNormal;                                      // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Arms1PPBRMap;                                      // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SkinColorTable;                                    // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           BaseSkin;                                          // 0x00DC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EyebrowOffset;                                     // 0x00EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EyebrowScale;                                      // 0x00F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EyebrowDistance;                                   // 0x0104(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyebrowRotation;                                   // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EyeColorTable;                                     // 0x0114(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          NormalPose;                                        // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FatPose;                                           // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SkinnyPose;                                        // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StrongPose;                                        // 0x0130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ReducedNormalPose;                                 // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ReducedFatPose;                                    // 0x0140(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ReducedSkinnyPose;                                 // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ReducedStrongPose;                                 // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Eyes;                                              // 0x0158(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           LeftArm;                                           // 0x0180(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           LeftArm1P;                                         // 0x01A8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           RightArm;                                          // 0x01D0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           RightArm1P;                                        // 0x01F8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           LeftHand;                                          // 0x0220(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           LeftHand1P;                                        // 0x0248(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           RightHand;                                         // 0x0270(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           RightHand1P;                                       // 0x0298(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           LeftLeg;                                           // 0x02C0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           RightLeg;                                          // 0x02E8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           LeftFoot;                                          // 0x0310(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           RightFoot;                                         // 0x0338(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Torso;                                             // 0x0360(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           FullArmAuxiliaryMesh;                              // 0x0388(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           FullArmAuxiliaryMesh1P;                            // 0x03B0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           ForeArmAuxiliaryMesh;                              // 0x03D8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           ForeArmAuxiliaryMesh1P;                            // 0x0400(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           UpperChestAuxiliaryMesh;                           // 0x0428(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           AnkleAuxiliaryMesh;                                // 0x0450(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BloodOffsetA;                                      // 0x0478(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BloodOffsetB;                                      // 0x0484(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BloodMaskSizeFine;                                 // 0x0490(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BloodMaskSizeSoft;                                 // 0x049C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BloodTextureSize;                                  // 0x04A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UCharacterHair>>     Hair;                                              // 0x04B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCharacterHair>>     FacialHair;                                        // 0x04C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterFace">();
	}
	static class UCharacterFace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterFace>();
	}
};
static_assert(alignof(UCharacterFace) == 0x000008, "Wrong alignment on UCharacterFace");
static_assert(sizeof(UCharacterFace) == 0x0004D8, "Wrong size on UCharacterFace");
static_assert(offsetof(UCharacterFace, Mesh) == 0x000060, "Member 'UCharacterFace::Mesh' has a wrong offset!");
static_assert(offsetof(UCharacterFace, Albedo) == 0x000088, "Member 'UCharacterFace::Albedo' has a wrong offset!");
static_assert(offsetof(UCharacterFace, Normal) == 0x000090, "Member 'UCharacterFace::Normal' has a wrong offset!");
static_assert(offsetof(UCharacterFace, AgedNormal) == 0x000098, "Member 'UCharacterFace::AgedNormal' has a wrong offset!");
static_assert(offsetof(UCharacterFace, PBRMap) == 0x0000A0, "Member 'UCharacterFace::PBRMap' has a wrong offset!");
static_assert(offsetof(UCharacterFace, TorsoAlbedo) == 0x0000A8, "Member 'UCharacterFace::TorsoAlbedo' has a wrong offset!");
static_assert(offsetof(UCharacterFace, TorsoNormal) == 0x0000B0, "Member 'UCharacterFace::TorsoNormal' has a wrong offset!");
static_assert(offsetof(UCharacterFace, TorsoPBRMap) == 0x0000B8, "Member 'UCharacterFace::TorsoPBRMap' has a wrong offset!");
static_assert(offsetof(UCharacterFace, Arms1PAlbedo) == 0x0000C0, "Member 'UCharacterFace::Arms1PAlbedo' has a wrong offset!");
static_assert(offsetof(UCharacterFace, Arms1PNormal) == 0x0000C8, "Member 'UCharacterFace::Arms1PNormal' has a wrong offset!");
static_assert(offsetof(UCharacterFace, Arms1PPBRMap) == 0x0000D0, "Member 'UCharacterFace::Arms1PPBRMap' has a wrong offset!");
static_assert(offsetof(UCharacterFace, SkinColorTable) == 0x0000D8, "Member 'UCharacterFace::SkinColorTable' has a wrong offset!");
static_assert(offsetof(UCharacterFace, BaseSkin) == 0x0000DC, "Member 'UCharacterFace::BaseSkin' has a wrong offset!");
static_assert(offsetof(UCharacterFace, EyebrowOffset) == 0x0000EC, "Member 'UCharacterFace::EyebrowOffset' has a wrong offset!");
static_assert(offsetof(UCharacterFace, EyebrowScale) == 0x0000F8, "Member 'UCharacterFace::EyebrowScale' has a wrong offset!");
static_assert(offsetof(UCharacterFace, EyebrowDistance) == 0x000104, "Member 'UCharacterFace::EyebrowDistance' has a wrong offset!");
static_assert(offsetof(UCharacterFace, EyebrowRotation) == 0x000110, "Member 'UCharacterFace::EyebrowRotation' has a wrong offset!");
static_assert(offsetof(UCharacterFace, EyeColorTable) == 0x000114, "Member 'UCharacterFace::EyeColorTable' has a wrong offset!");
static_assert(offsetof(UCharacterFace, NormalPose) == 0x000118, "Member 'UCharacterFace::NormalPose' has a wrong offset!");
static_assert(offsetof(UCharacterFace, FatPose) == 0x000120, "Member 'UCharacterFace::FatPose' has a wrong offset!");
static_assert(offsetof(UCharacterFace, SkinnyPose) == 0x000128, "Member 'UCharacterFace::SkinnyPose' has a wrong offset!");
static_assert(offsetof(UCharacterFace, StrongPose) == 0x000130, "Member 'UCharacterFace::StrongPose' has a wrong offset!");
static_assert(offsetof(UCharacterFace, ReducedNormalPose) == 0x000138, "Member 'UCharacterFace::ReducedNormalPose' has a wrong offset!");
static_assert(offsetof(UCharacterFace, ReducedFatPose) == 0x000140, "Member 'UCharacterFace::ReducedFatPose' has a wrong offset!");
static_assert(offsetof(UCharacterFace, ReducedSkinnyPose) == 0x000148, "Member 'UCharacterFace::ReducedSkinnyPose' has a wrong offset!");
static_assert(offsetof(UCharacterFace, ReducedStrongPose) == 0x000150, "Member 'UCharacterFace::ReducedStrongPose' has a wrong offset!");
static_assert(offsetof(UCharacterFace, Eyes) == 0x000158, "Member 'UCharacterFace::Eyes' has a wrong offset!");
static_assert(offsetof(UCharacterFace, LeftArm) == 0x000180, "Member 'UCharacterFace::LeftArm' has a wrong offset!");
static_assert(offsetof(UCharacterFace, LeftArm1P) == 0x0001A8, "Member 'UCharacterFace::LeftArm1P' has a wrong offset!");
static_assert(offsetof(UCharacterFace, RightArm) == 0x0001D0, "Member 'UCharacterFace::RightArm' has a wrong offset!");
static_assert(offsetof(UCharacterFace, RightArm1P) == 0x0001F8, "Member 'UCharacterFace::RightArm1P' has a wrong offset!");
static_assert(offsetof(UCharacterFace, LeftHand) == 0x000220, "Member 'UCharacterFace::LeftHand' has a wrong offset!");
static_assert(offsetof(UCharacterFace, LeftHand1P) == 0x000248, "Member 'UCharacterFace::LeftHand1P' has a wrong offset!");
static_assert(offsetof(UCharacterFace, RightHand) == 0x000270, "Member 'UCharacterFace::RightHand' has a wrong offset!");
static_assert(offsetof(UCharacterFace, RightHand1P) == 0x000298, "Member 'UCharacterFace::RightHand1P' has a wrong offset!");
static_assert(offsetof(UCharacterFace, LeftLeg) == 0x0002C0, "Member 'UCharacterFace::LeftLeg' has a wrong offset!");
static_assert(offsetof(UCharacterFace, RightLeg) == 0x0002E8, "Member 'UCharacterFace::RightLeg' has a wrong offset!");
static_assert(offsetof(UCharacterFace, LeftFoot) == 0x000310, "Member 'UCharacterFace::LeftFoot' has a wrong offset!");
static_assert(offsetof(UCharacterFace, RightFoot) == 0x000338, "Member 'UCharacterFace::RightFoot' has a wrong offset!");
static_assert(offsetof(UCharacterFace, Torso) == 0x000360, "Member 'UCharacterFace::Torso' has a wrong offset!");
static_assert(offsetof(UCharacterFace, FullArmAuxiliaryMesh) == 0x000388, "Member 'UCharacterFace::FullArmAuxiliaryMesh' has a wrong offset!");
static_assert(offsetof(UCharacterFace, FullArmAuxiliaryMesh1P) == 0x0003B0, "Member 'UCharacterFace::FullArmAuxiliaryMesh1P' has a wrong offset!");
static_assert(offsetof(UCharacterFace, ForeArmAuxiliaryMesh) == 0x0003D8, "Member 'UCharacterFace::ForeArmAuxiliaryMesh' has a wrong offset!");
static_assert(offsetof(UCharacterFace, ForeArmAuxiliaryMesh1P) == 0x000400, "Member 'UCharacterFace::ForeArmAuxiliaryMesh1P' has a wrong offset!");
static_assert(offsetof(UCharacterFace, UpperChestAuxiliaryMesh) == 0x000428, "Member 'UCharacterFace::UpperChestAuxiliaryMesh' has a wrong offset!");
static_assert(offsetof(UCharacterFace, AnkleAuxiliaryMesh) == 0x000450, "Member 'UCharacterFace::AnkleAuxiliaryMesh' has a wrong offset!");
static_assert(offsetof(UCharacterFace, BloodOffsetA) == 0x000478, "Member 'UCharacterFace::BloodOffsetA' has a wrong offset!");
static_assert(offsetof(UCharacterFace, BloodOffsetB) == 0x000484, "Member 'UCharacterFace::BloodOffsetB' has a wrong offset!");
static_assert(offsetof(UCharacterFace, BloodMaskSizeFine) == 0x000490, "Member 'UCharacterFace::BloodMaskSizeFine' has a wrong offset!");
static_assert(offsetof(UCharacterFace, BloodMaskSizeSoft) == 0x00049C, "Member 'UCharacterFace::BloodMaskSizeSoft' has a wrong offset!");
static_assert(offsetof(UCharacterFace, BloodTextureSize) == 0x0004A8, "Member 'UCharacterFace::BloodTextureSize' has a wrong offset!");
static_assert(offsetof(UCharacterFace, Hair) == 0x0004B8, "Member 'UCharacterFace::Hair' has a wrong offset!");
static_assert(offsetof(UCharacterFace, FacialHair) == 0x0004C8, "Member 'UCharacterFace::FacialHair' has a wrong offset!");

// Class Mordhau.CharacterHair
// 0x0040 (0x00A0 - 0x0060)
class UCharacterHair : public UMordhauInventoryItem
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0060(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Albedo;                                            // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Normal;                                            // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HairColorTable;                                    // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterHair">();
	}
	static class UCharacterHair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterHair>();
	}
};
static_assert(alignof(UCharacterHair) == 0x000008, "Wrong alignment on UCharacterHair");
static_assert(sizeof(UCharacterHair) == 0x0000A0, "Wrong size on UCharacterHair");
static_assert(offsetof(UCharacterHair, Mesh) == 0x000060, "Member 'UCharacterHair::Mesh' has a wrong offset!");
static_assert(offsetof(UCharacterHair, Albedo) == 0x000088, "Member 'UCharacterHair::Albedo' has a wrong offset!");
static_assert(offsetof(UCharacterHair, Normal) == 0x000090, "Member 'UCharacterHair::Normal' has a wrong offset!");
static_assert(offsetof(UCharacterHair, HairColorTable) == 0x000098, "Member 'UCharacterHair::HairColorTable' has a wrong offset!");

// Class Mordhau.ProjectileShooterComponent
// 0x01E0 (0x0290 - 0x00B0)
class UProjectileShooterComponent : public UActorComponent
{
public:
	EWeaponState                                  WeaponState;                                       // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFire;                                           // 0x00B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BuildingStageDuration;                             // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReleasingStageDuration;                            // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryStageDuration;                             // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadingStageDuration;                            // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Projectile;                                        // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProjectileSocketName;                              // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AMordhauProjectile>         NormalProjectileClass;                             // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AMordhauProjectile>         FireProjectileClass;                               // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnProjectileFiredAttachSocket;                     // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OnProjectileFiredSoundCue;                         // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               OnProjectileFiredParticleSystemComponent;          // 0x00F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReloadSoundAttachSocket;                           // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ReloadSoundCue;                                    // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             FireProjectileTransform;                           // 0x0110(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UParticleSystem*                        FireProjectileParticleSystem;                      // 0x0140(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FireProjectileParticleSystemScale;                 // 0x0148(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProjectileOnFireAttachSocket;                      // 0x0154(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              ProjectileOnFireSoundCue;                          // 0x0160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShakeCameraOnFire;                                // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowDebugCameraShakeRadius;                       // 0x0169(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A[0x6];                                      // 0x016A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatineeCameraShake>        CameraShakeOnFired;                                // 0x0170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeInnerRadius;                            // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeOuterRadius;                            // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeFalloff;                                // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CameraOrientShakeTowardsEpicenter;                 // 0x0184(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowProjectileTrajectory;                         // 0x0185(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_186[0x2];                                      // 0x0186(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ProjectileTrajectorySocketName;                    // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PredictionLaunchVelocity;                          // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PredictionSphereScale;                             // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimTime;                                        // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PredictionGravity;                                 // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileRadius;                                  // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimFrequency;                                      // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawDebugTime;                                     // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceWithCollision;                               // 0x01AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceWithChannel;                                 // 0x01AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x01AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AF[0x1];                                      // 0x01AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              RestockSoundCue;                                   // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAmmo;                                          // 0x01B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmmoReplenishInterval;                             // 0x01BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAmmo;                                           // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Ammo;                                              // 0x01C4(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C5[0x3];                                      // 0x01C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        OnFireSpawnedParticleSystem;                       // 0x01C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              OnFireSpawnedSoundCue;                             // 0x01D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              ProjectileOnFireMaterial;                          // 0x01D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnBuildingCompleted;                               // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnReleasingCompleted;                              // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRecoveryCompleted;                               // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLoadingCompleted;                                // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UParticleSystemComponent> FireEffectParticleComponent;                       // 0x0220(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAudioComponent>         FireEffectAudioComponent;                          // 0x0228(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ProjectileParticleFX;                              // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FireLocation;                                      // 0x0238(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               FireRotation;                                      // 0x0244(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         StageTotalTime;                                    // 0x0250(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StageRemainingTime;                                // 0x0254(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x18];                                     // 0x0258(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasAddedInstances;                                // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          ProjectileTrajectoryInstancedMeshComponent;        // 0x0278(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsReplenishingAmmo;                               // 0x0280(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_281[0xF];                                      // 0x0281(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckProjectileMeshComponentReference();
	void ClearProjectileTrajectoryAddedInstances();
	void FireProjectile();
	void InitializeProjectileTrajectory();
	void OnBuildingStageCompleted();
	void OnCharacterDestroyed(class AAdvancedCharacter* Character);
	void OnCharacterDied(class AAdvancedCharacter* Character);
	bool OnFirePressed();
	void OnLoadingStageCompleted();
	void OnRecoveryStageCompleted();
	void OnReleasingStageCompleted();
	void OnRep_AmmoChanged();
	void OnRep_ProjectileIsOnFireChanged();
	void OnRep_WeaponStateChanged();
	void OnStopDriving();
	void OnVehicleDestroyed(class AVehicleBase* Vehicle);
	void OnVehicleDied(class AVehicleBase* Vehicle);
	void OnWeaponStateBuilding();
	void OnWeaponStateLoaded();
	void OnWeaponStateLoading();
	void OnWeaponStateRecovery();
	void OnWeaponStateReleasing();
	void ReplenishAmmo();
	void SetOnFire(bool bOnFire);
	void UpdateProjectileTrajectory();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileShooterComponent">();
	}
	static class UProjectileShooterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileShooterComponent>();
	}
};
static_assert(alignof(UProjectileShooterComponent) == 0x000010, "Wrong alignment on UProjectileShooterComponent");
static_assert(sizeof(UProjectileShooterComponent) == 0x000290, "Wrong size on UProjectileShooterComponent");
static_assert(offsetof(UProjectileShooterComponent, WeaponState) == 0x0000B0, "Member 'UProjectileShooterComponent::WeaponState' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, bIsFire) == 0x0000B1, "Member 'UProjectileShooterComponent::bIsFire' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, BuildingStageDuration) == 0x0000B4, "Member 'UProjectileShooterComponent::BuildingStageDuration' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, ReleasingStageDuration) == 0x0000B8, "Member 'UProjectileShooterComponent::ReleasingStageDuration' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, RecoveryStageDuration) == 0x0000BC, "Member 'UProjectileShooterComponent::RecoveryStageDuration' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, ReloadingStageDuration) == 0x0000C0, "Member 'UProjectileShooterComponent::ReloadingStageDuration' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, Projectile) == 0x0000C8, "Member 'UProjectileShooterComponent::Projectile' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, ProjectileSocketName) == 0x0000D0, "Member 'UProjectileShooterComponent::ProjectileSocketName' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, NormalProjectileClass) == 0x0000D8, "Member 'UProjectileShooterComponent::NormalProjectileClass' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, FireProjectileClass) == 0x0000E0, "Member 'UProjectileShooterComponent::FireProjectileClass' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, OnProjectileFiredAttachSocket) == 0x0000E8, "Member 'UProjectileShooterComponent::OnProjectileFiredAttachSocket' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, OnProjectileFiredSoundCue) == 0x0000F0, "Member 'UProjectileShooterComponent::OnProjectileFiredSoundCue' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, OnProjectileFiredParticleSystemComponent) == 0x0000F8, "Member 'UProjectileShooterComponent::OnProjectileFiredParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, ReloadSoundAttachSocket) == 0x000100, "Member 'UProjectileShooterComponent::ReloadSoundAttachSocket' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, ReloadSoundCue) == 0x000108, "Member 'UProjectileShooterComponent::ReloadSoundCue' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, FireProjectileTransform) == 0x000110, "Member 'UProjectileShooterComponent::FireProjectileTransform' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, FireProjectileParticleSystem) == 0x000140, "Member 'UProjectileShooterComponent::FireProjectileParticleSystem' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, FireProjectileParticleSystemScale) == 0x000148, "Member 'UProjectileShooterComponent::FireProjectileParticleSystemScale' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, ProjectileOnFireAttachSocket) == 0x000154, "Member 'UProjectileShooterComponent::ProjectileOnFireAttachSocket' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, ProjectileOnFireSoundCue) == 0x000160, "Member 'UProjectileShooterComponent::ProjectileOnFireSoundCue' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, bShakeCameraOnFire) == 0x000168, "Member 'UProjectileShooterComponent::bShakeCameraOnFire' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, bShowDebugCameraShakeRadius) == 0x000169, "Member 'UProjectileShooterComponent::bShowDebugCameraShakeRadius' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, CameraShakeOnFired) == 0x000170, "Member 'UProjectileShooterComponent::CameraShakeOnFired' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, CameraShakeInnerRadius) == 0x000178, "Member 'UProjectileShooterComponent::CameraShakeInnerRadius' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, CameraShakeOuterRadius) == 0x00017C, "Member 'UProjectileShooterComponent::CameraShakeOuterRadius' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, CameraShakeFalloff) == 0x000180, "Member 'UProjectileShooterComponent::CameraShakeFalloff' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, CameraOrientShakeTowardsEpicenter) == 0x000184, "Member 'UProjectileShooterComponent::CameraOrientShakeTowardsEpicenter' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, bShowProjectileTrajectory) == 0x000185, "Member 'UProjectileShooterComponent::bShowProjectileTrajectory' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, ProjectileTrajectorySocketName) == 0x000188, "Member 'UProjectileShooterComponent::ProjectileTrajectorySocketName' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, PredictionLaunchVelocity) == 0x000190, "Member 'UProjectileShooterComponent::PredictionLaunchVelocity' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, PredictionSphereScale) == 0x000194, "Member 'UProjectileShooterComponent::PredictionSphereScale' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, MaxSimTime) == 0x000198, "Member 'UProjectileShooterComponent::MaxSimTime' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, PredictionGravity) == 0x00019C, "Member 'UProjectileShooterComponent::PredictionGravity' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, ProjectileRadius) == 0x0001A0, "Member 'UProjectileShooterComponent::ProjectileRadius' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, SimFrequency) == 0x0001A4, "Member 'UProjectileShooterComponent::SimFrequency' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, DrawDebugTime) == 0x0001A8, "Member 'UProjectileShooterComponent::DrawDebugTime' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, bTraceWithCollision) == 0x0001AC, "Member 'UProjectileShooterComponent::bTraceWithCollision' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, bTraceWithChannel) == 0x0001AD, "Member 'UProjectileShooterComponent::bTraceWithChannel' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, bTraceComplex) == 0x0001AE, "Member 'UProjectileShooterComponent::bTraceComplex' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, RestockSoundCue) == 0x0001B0, "Member 'UProjectileShooterComponent::RestockSoundCue' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, bHasAmmo) == 0x0001B8, "Member 'UProjectileShooterComponent::bHasAmmo' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, AmmoReplenishInterval) == 0x0001BC, "Member 'UProjectileShooterComponent::AmmoReplenishInterval' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, MaxAmmo) == 0x0001C0, "Member 'UProjectileShooterComponent::MaxAmmo' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, Ammo) == 0x0001C4, "Member 'UProjectileShooterComponent::Ammo' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, OnFireSpawnedParticleSystem) == 0x0001C8, "Member 'UProjectileShooterComponent::OnFireSpawnedParticleSystem' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, OnFireSpawnedSoundCue) == 0x0001D0, "Member 'UProjectileShooterComponent::OnFireSpawnedSoundCue' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, ProjectileOnFireMaterial) == 0x0001D8, "Member 'UProjectileShooterComponent::ProjectileOnFireMaterial' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, OnBuildingCompleted) == 0x0001E0, "Member 'UProjectileShooterComponent::OnBuildingCompleted' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, OnReleasingCompleted) == 0x0001F0, "Member 'UProjectileShooterComponent::OnReleasingCompleted' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, OnRecoveryCompleted) == 0x000200, "Member 'UProjectileShooterComponent::OnRecoveryCompleted' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, OnLoadingCompleted) == 0x000210, "Member 'UProjectileShooterComponent::OnLoadingCompleted' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, FireEffectParticleComponent) == 0x000220, "Member 'UProjectileShooterComponent::FireEffectParticleComponent' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, FireEffectAudioComponent) == 0x000228, "Member 'UProjectileShooterComponent::FireEffectAudioComponent' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, ProjectileParticleFX) == 0x000230, "Member 'UProjectileShooterComponent::ProjectileParticleFX' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, FireLocation) == 0x000238, "Member 'UProjectileShooterComponent::FireLocation' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, FireRotation) == 0x000244, "Member 'UProjectileShooterComponent::FireRotation' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, StageTotalTime) == 0x000250, "Member 'UProjectileShooterComponent::StageTotalTime' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, StageRemainingTime) == 0x000254, "Member 'UProjectileShooterComponent::StageRemainingTime' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, bHasAddedInstances) == 0x000270, "Member 'UProjectileShooterComponent::bHasAddedInstances' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, ProjectileTrajectoryInstancedMeshComponent) == 0x000278, "Member 'UProjectileShooterComponent::ProjectileTrajectoryInstancedMeshComponent' has a wrong offset!");
static_assert(offsetof(UProjectileShooterComponent, bIsReplenishingAmmo) == 0x000280, "Member 'UProjectileShooterComponent::bIsReplenishingAmmo' has a wrong offset!");

// Class Mordhau.SendFriendRequest
// 0x0090 (0x00C0 - 0x0030)
class USendFriendRequest final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(bool bUsedPlatform)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bUsedPlatform)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayFabPlayer                         Player;                                            // 0x0058(0x0060)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUsedPlatform;                                     // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USendFriendRequest* SendFriendRequest(class UObject* WorldContextObject, const struct FPlayFabPlayer& Player_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SendFriendRequest">();
	}
	static class USendFriendRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<USendFriendRequest>();
	}
};
static_assert(alignof(USendFriendRequest) == 0x000008, "Wrong alignment on USendFriendRequest");
static_assert(sizeof(USendFriendRequest) == 0x0000C0, "Wrong size on USendFriendRequest");
static_assert(offsetof(USendFriendRequest, onSuccess) == 0x000030, "Member 'USendFriendRequest::onSuccess' has a wrong offset!");
static_assert(offsetof(USendFriendRequest, onFailure) == 0x000040, "Member 'USendFriendRequest::onFailure' has a wrong offset!");
static_assert(offsetof(USendFriendRequest, World) == 0x000050, "Member 'USendFriendRequest::World' has a wrong offset!");
static_assert(offsetof(USendFriendRequest, Player) == 0x000058, "Member 'USendFriendRequest::Player' has a wrong offset!");
static_assert(offsetof(USendFriendRequest, bUsedPlatform) == 0x0000B8, "Member 'USendFriendRequest::bUsedPlatform' has a wrong offset!");

// Class Mordhau.CharacterProfileBPWrapper
// 0x00B8 (0x00E0 - 0x0028)
class UCharacterProfileBPWrapper final : public UObject
{
public:
	struct FCharacterProfile                      Profile;                                           // 0x0028(0x00B8)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void ForceValidate();
	bool HasPerk(uint8 Perk);
	void RemoveAllEquipment();
	void SetAge(uint8 NewValue);
	void SetEmblem(uint8 NewValue);
	void SetEmblemColor(uint8 ColorIdx, uint8 NewValue);
	void SetEquipmentColor(uint8 Slot, uint8 ColorIdx, uint8 NewColor);
	void SetEquipmentCustomizationDirect(uint8 Slot, const struct FEquipmentCustomization& NewCustomization);
	void SetEquipmentId(uint8 Slot, uint8 NewId);
	void SetEquipmentPartId(uint8 Slot, uint8 PartIdx, uint8 NewPartId);
	void SetEquipmentPattern(uint8 Slot, uint8 NewPattern);
	void SetEquipmentSkin(uint8 Slot, uint8 NewSkin);
	void SetEyebrows(uint8 NewValue);
	void SetEyeColor(uint8 NewValue);
	void SetFace(uint8 NewValue);
	void SetFacialHair(uint8 NewValue);
	void SetFat(uint8 NewValue);
	void SetHair(uint8 NewValue);
	void SetHairColor(uint8 NewValue);
	void SetIsFemale(bool bNewValue);
	void SetMetalRoughnessScale(uint8 NewValue);
	void SetMetalTint(uint8 NewValue);
	void SetProfileCategory(const class FString& NewCategory);
	void SetProfileName(const class FText& NewName);
	void SetSkinColor(uint8 NewValue);
	void SetSkinny(uint8 NewValue);
	void SetStrong(uint8 NewValue);
	void SetVoice(uint8 NewValue);
	void SetVoicePitch(uint8 NewValue);
	void SetWearableColor(uint8 Slot, uint8 ColorIdx, uint8 NewColor);
	void SetWearableId(uint8 Slot, uint8 NewId);
	void SetWearablePattern(uint8 Slot, uint8 NewPattern);
	void TogglePerk(uint8 Perk);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterProfileBPWrapper">();
	}
	static class UCharacterProfileBPWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterProfileBPWrapper>();
	}
};
static_assert(alignof(UCharacterProfileBPWrapper) == 0x000008, "Wrong alignment on UCharacterProfileBPWrapper");
static_assert(sizeof(UCharacterProfileBPWrapper) == 0x0000E0, "Wrong size on UCharacterProfileBPWrapper");
static_assert(offsetof(UCharacterProfileBPWrapper, Profile) == 0x000028, "Member 'UCharacterProfileBPWrapper::Profile' has a wrong offset!");

// Class Mordhau.CharacterVoice
// 0x0048 (0x00A8 - 0x0060)
class UCharacterVoice : public UMordhauInventoryItem
{
public:
	class USoundCue*                              VoiceCommands;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              Hurt;                                              // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              Death;                                             // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              AttackYell;                                        // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              Breathing;                                         // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              Screaming;                                         // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PitchLimits;                                       // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 ClipCounts;                                        // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterVoice">();
	}
	static class UCharacterVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterVoice>();
	}
};
static_assert(alignof(UCharacterVoice) == 0x000008, "Wrong alignment on UCharacterVoice");
static_assert(sizeof(UCharacterVoice) == 0x0000A8, "Wrong size on UCharacterVoice");
static_assert(offsetof(UCharacterVoice, VoiceCommands) == 0x000060, "Member 'UCharacterVoice::VoiceCommands' has a wrong offset!");
static_assert(offsetof(UCharacterVoice, Hurt) == 0x000068, "Member 'UCharacterVoice::Hurt' has a wrong offset!");
static_assert(offsetof(UCharacterVoice, Death) == 0x000070, "Member 'UCharacterVoice::Death' has a wrong offset!");
static_assert(offsetof(UCharacterVoice, AttackYell) == 0x000078, "Member 'UCharacterVoice::AttackYell' has a wrong offset!");
static_assert(offsetof(UCharacterVoice, Breathing) == 0x000080, "Member 'UCharacterVoice::Breathing' has a wrong offset!");
static_assert(offsetof(UCharacterVoice, Screaming) == 0x000088, "Member 'UCharacterVoice::Screaming' has a wrong offset!");
static_assert(offsetof(UCharacterVoice, PitchLimits) == 0x000090, "Member 'UCharacterVoice::PitchLimits' has a wrong offset!");
static_assert(offsetof(UCharacterVoice, ClipCounts) == 0x000098, "Member 'UCharacterVoice::ClipCounts' has a wrong offset!");

// Class Mordhau.MordhauCameraManager
// 0x0670 (0x2E20 - 0x27B0)
class AMordhauCameraManager : public APlayerCameraManager
{
public:
	uint8                                         Pad_27B0[0x8];                                     // 0x27B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTagSystemComponent*                    TagSystemComponent;                                // 0x27B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ClosestWidgetVisibilityQueueDistances;             // 0x27C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ClosestWidgetVisibilityQueueMaxDistance;           // 0x27D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D4[0x4];                                     // 0x27D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AAtmosphericFog*                        AtmosphericFog;                                    // 0x27D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E0[0x4];                                     // 0x27E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AtmosphericFogMultiplierChangeSpeed;               // 0x27E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInMainMenu;                                     // 0x27E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E9[0x7];                                     // 0x27E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalViewInfo                       LastViewInfo;                                      // 0x27F0(0x05E0)(NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  QueuedViewTarget;                                  // 0x2DD0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UMordhauWidgetComponent>> LateTickRequests;                                  // 0x2DD8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         HitFlashIgnoreUntilTime;                           // 0x2DE8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFlashFadeInDuration;                            // 0x2DEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFlashStayDuration;                              // 0x2DF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFlashFadeOutDuration;                           // 0x2DF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DF8[0x8];                                     // 0x2DF8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitFlashValue;                                     // 0x2E00(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHitFlashDirectional;                            // 0x2E04(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E05[0x3];                                     // 0x2E05(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  HitFlashSource;                                    // 0x2E08(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitFlashDegrees;                                   // 0x2E10(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E14[0xC];                                     // 0x2E14(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterCustomization(class AActor* CustomizationTarget);
	void EnterMapView();
	struct FMinimalViewInfo GetCameraCache();
	class FName GetCameraStyleBP();
	class AActor* GetViewTargetBP();
	void LeaveCustomization();
	void LeaveMapView();
	void OnHitFlash(bool bIsDirectional, class AActor* Source);
	void SetCameraStyleBP(class FName NewCameraStyle);
	void SetViewTargetBP(class AActor* NewTarget);

	bool GetIsInCustomization() const;
	bool GetIsInMapView() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauCameraManager">();
	}
	static class AMordhauCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauCameraManager>();
	}
};
static_assert(alignof(AMordhauCameraManager) == 0x000010, "Wrong alignment on AMordhauCameraManager");
static_assert(sizeof(AMordhauCameraManager) == 0x002E20, "Wrong size on AMordhauCameraManager");
static_assert(offsetof(AMordhauCameraManager, TagSystemComponent) == 0x0027B8, "Member 'AMordhauCameraManager::TagSystemComponent' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, ClosestWidgetVisibilityQueueDistances) == 0x0027C0, "Member 'AMordhauCameraManager::ClosestWidgetVisibilityQueueDistances' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, ClosestWidgetVisibilityQueueMaxDistance) == 0x0027D0, "Member 'AMordhauCameraManager::ClosestWidgetVisibilityQueueMaxDistance' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, AtmosphericFog) == 0x0027D8, "Member 'AMordhauCameraManager::AtmosphericFog' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, AtmosphericFogMultiplierChangeSpeed) == 0x0027E4, "Member 'AMordhauCameraManager::AtmosphericFogMultiplierChangeSpeed' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, bIsInMainMenu) == 0x0027E8, "Member 'AMordhauCameraManager::bIsInMainMenu' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, LastViewInfo) == 0x0027F0, "Member 'AMordhauCameraManager::LastViewInfo' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, QueuedViewTarget) == 0x002DD0, "Member 'AMordhauCameraManager::QueuedViewTarget' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, LateTickRequests) == 0x002DD8, "Member 'AMordhauCameraManager::LateTickRequests' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, HitFlashIgnoreUntilTime) == 0x002DE8, "Member 'AMordhauCameraManager::HitFlashIgnoreUntilTime' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, HitFlashFadeInDuration) == 0x002DEC, "Member 'AMordhauCameraManager::HitFlashFadeInDuration' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, HitFlashStayDuration) == 0x002DF0, "Member 'AMordhauCameraManager::HitFlashStayDuration' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, HitFlashFadeOutDuration) == 0x002DF4, "Member 'AMordhauCameraManager::HitFlashFadeOutDuration' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, HitFlashValue) == 0x002E00, "Member 'AMordhauCameraManager::HitFlashValue' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, bIsHitFlashDirectional) == 0x002E04, "Member 'AMordhauCameraManager::bIsHitFlashDirectional' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, HitFlashSource) == 0x002E08, "Member 'AMordhauCameraManager::HitFlashSource' has a wrong offset!");
static_assert(offsetof(AMordhauCameraManager, HitFlashDegrees) == 0x002E10, "Member 'AMordhauCameraManager::HitFlashDegrees' has a wrong offset!");

// Class Mordhau.CharacterVoiceComponent
// 0x0080 (0x0130 - 0x00B0)
class UCharacterVoiceComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAudioComponent>         LastHurtYell;                                      // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         DeathScreamPtr;                                    // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         LastVoiceCommand;                                  // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         LastAttackYell;                                    // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         LastScream;                                        // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterVoice*                        CharacterVoice;                                    // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRequestedVoiceCommandTime;                     // 0x00E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoiceCommandQueueDuration;                         // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayBetweenVoiceCommands;                      // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayBetweenBattlecries;                        // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoicePitch;                                        // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVoiceMuffled;                                   // 0x00FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MuffledVoiceLowPassFrequency;                      // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MuffledVoiceVolumeMultiplier;                      // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackYellVolumeMultiplierViewTarget;              // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           FaceAttackAnimation;                               // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FaceBattlecryAnimation;                            // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FaceTalkingAnimation;                              // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FaceHurtAnimation;                                 // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnCharacterBuilt(class AMordhauCharacter* Character);
	void OnCharacterDied(class AAdvancedCharacter* Character);
	void OnLODTick(float DeltaTime);
	void OnTakeDamage(class AAdvancedCharacter* Character, const struct FMordhauDamageInfo& DamageInfo, class AController* EventInstigator, class AActor* DamageCauser);
	void OnVoiceCommandReplicated();
	void UpdateVoiceDataFromCharacter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterVoiceComponent">();
	}
	static class UCharacterVoiceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterVoiceComponent>();
	}
};
static_assert(alignof(UCharacterVoiceComponent) == 0x000008, "Wrong alignment on UCharacterVoiceComponent");
static_assert(sizeof(UCharacterVoiceComponent) == 0x000130, "Wrong size on UCharacterVoiceComponent");
static_assert(offsetof(UCharacterVoiceComponent, LastHurtYell) == 0x0000B8, "Member 'UCharacterVoiceComponent::LastHurtYell' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, DeathScreamPtr) == 0x0000C0, "Member 'UCharacterVoiceComponent::DeathScreamPtr' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, LastVoiceCommand) == 0x0000C8, "Member 'UCharacterVoiceComponent::LastVoiceCommand' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, LastAttackYell) == 0x0000D0, "Member 'UCharacterVoiceComponent::LastAttackYell' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, LastScream) == 0x0000D8, "Member 'UCharacterVoiceComponent::LastScream' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, CharacterVoice) == 0x0000E0, "Member 'UCharacterVoiceComponent::CharacterVoice' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, LastRequestedVoiceCommandTime) == 0x0000E8, "Member 'UCharacterVoiceComponent::LastRequestedVoiceCommandTime' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, VoiceCommandQueueDuration) == 0x0000EC, "Member 'UCharacterVoiceComponent::VoiceCommandQueueDuration' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, MinDelayBetweenVoiceCommands) == 0x0000F0, "Member 'UCharacterVoiceComponent::MinDelayBetweenVoiceCommands' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, MinDelayBetweenBattlecries) == 0x0000F4, "Member 'UCharacterVoiceComponent::MinDelayBetweenBattlecries' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, VoicePitch) == 0x0000F8, "Member 'UCharacterVoiceComponent::VoicePitch' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, bIsVoiceMuffled) == 0x0000FC, "Member 'UCharacterVoiceComponent::bIsVoiceMuffled' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, MuffledVoiceLowPassFrequency) == 0x000100, "Member 'UCharacterVoiceComponent::MuffledVoiceLowPassFrequency' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, MuffledVoiceVolumeMultiplier) == 0x000104, "Member 'UCharacterVoiceComponent::MuffledVoiceVolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, AttackYellVolumeMultiplierViewTarget) == 0x000108, "Member 'UCharacterVoiceComponent::AttackYellVolumeMultiplierViewTarget' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, FaceAttackAnimation) == 0x000110, "Member 'UCharacterVoiceComponent::FaceAttackAnimation' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, FaceBattlecryAnimation) == 0x000118, "Member 'UCharacterVoiceComponent::FaceBattlecryAnimation' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, FaceTalkingAnimation) == 0x000120, "Member 'UCharacterVoiceComponent::FaceTalkingAnimation' has a wrong offset!");
static_assert(offsetof(UCharacterVoiceComponent, FaceHurtAnimation) == 0x000128, "Member 'UCharacterVoiceComponent::FaceHurtAnimation' has a wrong offset!");

// Class Mordhau.ClimbingMotion
// 0x0078 (0x0118 - 0x00A0)
class UClimbingMotion : public UMordhauMotion
{
public:
	class USoundCue*                              ClimbSound;                                        // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbRecoveryDuration;                             // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbAnimBlendOutOffset;                           // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AuthorityMoveUpStartTime;                          // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AuthorityMoveLateralStartTime;                     // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AuthorityMoveLateralDuration;                      // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowClimbRecoveryDuration;                         // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowAuthorityMoveUpStartTime;                      // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowAuthorityMoveLateralStartTime;                 // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowAuthorityMoveLateralDuration;                  // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TurnCaps;                                          // 0x00CC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSlowClimb;                                      // 0x00D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ClimbOffset;                                       // 0x00D8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LedgeOffset;                                       // 0x00E4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LedgeNormal;                                       // 0x00F0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClimbStartMeshLocation;                            // 0x00FC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AuthMoveStartLocation;                             // 0x0108(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAuthMovingUp;                                   // 0x0114(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAuthMovingLaterally;                            // 0x0115(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_116[0x2];                                      // 0x0116(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClimbingMotion">();
	}
	static class UClimbingMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClimbingMotion>();
	}
};
static_assert(alignof(UClimbingMotion) == 0x000008, "Wrong alignment on UClimbingMotion");
static_assert(sizeof(UClimbingMotion) == 0x000118, "Wrong size on UClimbingMotion");
static_assert(offsetof(UClimbingMotion, ClimbSound) == 0x0000A0, "Member 'UClimbingMotion::ClimbSound' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, ClimbRecoveryDuration) == 0x0000A8, "Member 'UClimbingMotion::ClimbRecoveryDuration' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, ClimbAnimBlendOutOffset) == 0x0000AC, "Member 'UClimbingMotion::ClimbAnimBlendOutOffset' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, AuthorityMoveUpStartTime) == 0x0000B0, "Member 'UClimbingMotion::AuthorityMoveUpStartTime' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, AuthorityMoveLateralStartTime) == 0x0000B4, "Member 'UClimbingMotion::AuthorityMoveLateralStartTime' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, AuthorityMoveLateralDuration) == 0x0000B8, "Member 'UClimbingMotion::AuthorityMoveLateralDuration' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, SlowClimbRecoveryDuration) == 0x0000BC, "Member 'UClimbingMotion::SlowClimbRecoveryDuration' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, SlowAuthorityMoveUpStartTime) == 0x0000C0, "Member 'UClimbingMotion::SlowAuthorityMoveUpStartTime' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, SlowAuthorityMoveLateralStartTime) == 0x0000C4, "Member 'UClimbingMotion::SlowAuthorityMoveLateralStartTime' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, SlowAuthorityMoveLateralDuration) == 0x0000C8, "Member 'UClimbingMotion::SlowAuthorityMoveLateralDuration' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, TurnCaps) == 0x0000CC, "Member 'UClimbingMotion::TurnCaps' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, bIsSlowClimb) == 0x0000D4, "Member 'UClimbingMotion::bIsSlowClimb' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, ClimbOffset) == 0x0000D8, "Member 'UClimbingMotion::ClimbOffset' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, LedgeOffset) == 0x0000E4, "Member 'UClimbingMotion::LedgeOffset' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, LedgeNormal) == 0x0000F0, "Member 'UClimbingMotion::LedgeNormal' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, ClimbStartMeshLocation) == 0x0000FC, "Member 'UClimbingMotion::ClimbStartMeshLocation' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, AuthMoveStartLocation) == 0x000108, "Member 'UClimbingMotion::AuthMoveStartLocation' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, bIsAuthMovingUp) == 0x000114, "Member 'UClimbingMotion::bIsAuthMovingUp' has a wrong offset!");
static_assert(offsetof(UClimbingMotion, bIsAuthMovingLaterally) == 0x000115, "Member 'UClimbingMotion::bIsAuthMovingLaterally' has a wrong offset!");

// Class Mordhau.MordhauInventory
// 0x01F0 (0x0218 - 0x0028)
class UMordhauInventory final : public UObject
{
public:
	uint8                                         Pad_28[0x1A0];                                     // 0x0028(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bWasSuccessful, struct FPlayFabApiError& Error, TArray<struct FItemStack>& ItemStacks)> OnItemsRefreshed;                                  // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bWasSuccessful, TArray<struct FItemStack>& ItemStacks)> OnItemsDropped;                                    // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bWasSuccessful, const class FString& PlayFabId, int32 Gold, int32 XP)> OnRewardsDropped;                                  // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bWasSuccessful, TArray<struct FItemStack>& ItemStacks)> OnItemsUnlocked;                                   // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bWasSuccessful, struct FPlayFabEntitlements& UpdatedEntitlements)> OnDLCItemsUpdate;                                  // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static int32 GetGoldItemDefID();
	static class UMordhauInventoryItem* GetItem(const int32 ItemDefID);
	static class UMordhauInventoryItem* GetStackItem(const struct FItemStack& ItemStack);
	static int32 GetStackItemDefID(const struct FItemStack& ItemStack);
	static int32 GetStackQuantity(const struct FItemStack& ItemStack);
	static int32 GetSupporterPackageItemDefID();
	static int32 GetTutorialPackageItemDefID();
	static int32 GetXPItemDefID();

	void AddItem(ECallResult* CallResult, const int32 ItemDefID);
	void AddItems(ECallResult* CallResult, const TArray<int32>& ItemDefIDs);
	bool AreUnlockRecipesAvailable();
	bool CanUnlockItem(const class FString& PlayFabId, const int32 ItemDefID);
	bool CanUnlockItems(const class FString& PlayFabId, const TArray<int32>& ItemDefIDs);
	bool ClearPlayerItems(const class FString& PlayFabId);
	void FakeItemDrop(ECallResult* CallResult, const int32 ItemDefID, const int32 Quantity);
	void FakeRewardDrop(ECallResult* CallResult, const int32 Gold, const int32 XP);
	int32 GetGold();
	void GetItemQuantity(ECallResult* CallResult, const class FString& PlayFabId, const int32 ItemDefID, int32* Quantity);
	void GetItemStacks(ECallResult* CallResult, const class FString& PlayFabId, TArray<struct FItemStack>* ItemStacks);
	int32 GetPlayerGold(const class FString& PlayFabId);
	int32 GetPlayerXP(const class FString& PlayFabId);
	EItemRarity GetSkinRarity(const struct FEquipmentSkinEntry& Skin);
	void GetUnlockRecipe(ECallResult* CallResult, const int32 ItemDefID, struct FUnlockRecipe* Recipe);
	int32 GetXP();
	bool HasItem(const class FString& PlayFabId, const int32 ItemDefID);
	bool HasSkin(const class FString& PlayFabId, const struct FEquipmentSkinEntry& Skin);
	bool IsInventoryAvailable(const class FString& PlayFabId);
	bool IsItemPlatformAvailable(const int32 ItemDefID);
	bool IsSkinAvailable(const class FString& PlayFabId, const struct FEquipmentSkinEntry& Skin);
	void RefreshItems(ECallResult* CallResult);
	void RefreshPlayerItems(ECallResult* CallResult, const class FString& PlayFabId);
	void RequestUnlockRecipes();
	void ResetInventory(ECallResult* CallResult);
	void SetItemQuantity(ECallResult* CallResult, const class FString& PlayFabId, const int32 ItemDefID, const int32 Quantity);
	bool SetPlayerGold(const class FString& PlayFabId, int32 Gold);
	bool SetPlayerXP(const class FString& PlayFabId, int32 XP);
	void TriggerItemDrop(ECallResult* CallResult, const int32 ItemDefID);
	void UnlockItem(ECallResult* CallResult, const class FString& PlayFabId, const int32 ItemDefID);
	void UnlockItems(ECallResult* CallResult, const class FString& PlayFabId, const TArray<int32>& ItemDefIDs);
	void UnlockLevelUnlocks(ECallResult* CallResult, const class FString& PlayFabId);
	void UpdateEntitlementsAndRefreshInventory(ECallResult* CallResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauInventory">();
	}
	static class UMordhauInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauInventory>();
	}
};
static_assert(alignof(UMordhauInventory) == 0x000008, "Wrong alignment on UMordhauInventory");
static_assert(sizeof(UMordhauInventory) == 0x000218, "Wrong size on UMordhauInventory");
static_assert(offsetof(UMordhauInventory, OnItemsRefreshed) == 0x0001C8, "Member 'UMordhauInventory::OnItemsRefreshed' has a wrong offset!");
static_assert(offsetof(UMordhauInventory, OnItemsDropped) == 0x0001D8, "Member 'UMordhauInventory::OnItemsDropped' has a wrong offset!");
static_assert(offsetof(UMordhauInventory, OnRewardsDropped) == 0x0001E8, "Member 'UMordhauInventory::OnRewardsDropped' has a wrong offset!");
static_assert(offsetof(UMordhauInventory, OnItemsUnlocked) == 0x0001F8, "Member 'UMordhauInventory::OnItemsUnlocked' has a wrong offset!");
static_assert(offsetof(UMordhauInventory, OnDLCItemsUpdate) == 0x000208, "Member 'UMordhauInventory::OnDLCItemsUpdate' has a wrong offset!");

// Class Mordhau.ComboBoxText
// 0x0CF0 (0x0DF8 - 0x0108)
class UComboBoxText final : public UWidget
{
public:
	TArray<class FText>                           DefaultOptions;                                    // 0x0108(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FText                                   SelectedOption;                                    // 0x0118(0x0018)(Edit, NativeAccessSpecifierPrivate)
	struct FComboBoxStyle                         WidgetStyle;                                       // 0x0130(0x03F0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTableRowStyle                         ItemStyle;                                         // 0x0520(0x07C8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMargin                                ContentPadding;                                    // 0x0CE8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxListHeight;                                     // 0x0CF8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDownArrow;                                      // 0x0CFC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableGamepadNavigationMode;                       // 0x0CFD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CFE[0x2];                                      // 0x0CFE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         Font;                                              // 0x0D00(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ForegroundColor;                                   // 0x0D58(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsFocusable;                                      // 0x0D80(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D81[0x3];                                      // 0x0D81(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const class FString& Item)>    OnGenerateWidgetEvent;                             // 0x0D84(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D94[0x4];                                      // 0x0D94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class FText SelectedItem, ESelectInfo SelectionType)> OnSelectionChanged;                                // 0x0D98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnOpening;                                         // 0x0DA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB8[0x40];                                     // 0x0DB8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOption(const class FText& Option);
	void ClearOptions();
	void ClearSelection();
	void RefreshOptions();
	bool RemoveOption(const class FText& Option);
	void SetSelectedOption(const class FText& Option);

	int32 FindOptionIndex(const class FText& Option) const;
	bool GetIsOpen() const;
	class FText GetOptionAtIndex(int32 Index_0) const;
	int32 GetOptionCount() const;
	class FText GetSelectedOption() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComboBoxText">();
	}
	static class UComboBoxText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComboBoxText>();
	}
};
static_assert(alignof(UComboBoxText) == 0x000008, "Wrong alignment on UComboBoxText");
static_assert(sizeof(UComboBoxText) == 0x000DF8, "Wrong size on UComboBoxText");
static_assert(offsetof(UComboBoxText, DefaultOptions) == 0x000108, "Member 'UComboBoxText::DefaultOptions' has a wrong offset!");
static_assert(offsetof(UComboBoxText, SelectedOption) == 0x000118, "Member 'UComboBoxText::SelectedOption' has a wrong offset!");
static_assert(offsetof(UComboBoxText, WidgetStyle) == 0x000130, "Member 'UComboBoxText::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UComboBoxText, ItemStyle) == 0x000520, "Member 'UComboBoxText::ItemStyle' has a wrong offset!");
static_assert(offsetof(UComboBoxText, ContentPadding) == 0x000CE8, "Member 'UComboBoxText::ContentPadding' has a wrong offset!");
static_assert(offsetof(UComboBoxText, MaxListHeight) == 0x000CF8, "Member 'UComboBoxText::MaxListHeight' has a wrong offset!");
static_assert(offsetof(UComboBoxText, HasDownArrow) == 0x000CFC, "Member 'UComboBoxText::HasDownArrow' has a wrong offset!");
static_assert(offsetof(UComboBoxText, EnableGamepadNavigationMode) == 0x000CFD, "Member 'UComboBoxText::EnableGamepadNavigationMode' has a wrong offset!");
static_assert(offsetof(UComboBoxText, Font) == 0x000D00, "Member 'UComboBoxText::Font' has a wrong offset!");
static_assert(offsetof(UComboBoxText, ForegroundColor) == 0x000D58, "Member 'UComboBoxText::ForegroundColor' has a wrong offset!");
static_assert(offsetof(UComboBoxText, bIsFocusable) == 0x000D80, "Member 'UComboBoxText::bIsFocusable' has a wrong offset!");
static_assert(offsetof(UComboBoxText, OnGenerateWidgetEvent) == 0x000D84, "Member 'UComboBoxText::OnGenerateWidgetEvent' has a wrong offset!");
static_assert(offsetof(UComboBoxText, OnSelectionChanged) == 0x000D98, "Member 'UComboBoxText::OnSelectionChanged' has a wrong offset!");
static_assert(offsetof(UComboBoxText, OnOpening) == 0x000DA8, "Member 'UComboBoxText::OnOpening' has a wrong offset!");

// Class Mordhau.CompoundVehicleAnimInstance
// 0x0000 (0x0380 - 0x0380)
class UCompoundVehicleAnimInstance final : public UAdvancedCharacterAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompoundVehicleAnimInstance">();
	}
	static class UCompoundVehicleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompoundVehicleAnimInstance>();
	}
};
static_assert(alignof(UCompoundVehicleAnimInstance) == 0x000010, "Wrong alignment on UCompoundVehicleAnimInstance");
static_assert(sizeof(UCompoundVehicleAnimInstance) == 0x000380, "Wrong size on UCompoundVehicleAnimInstance");

// Class Mordhau.RangedCancelMotion
// 0x0018 (0x00B8 - 0x00A0)
class URangedCancelMotion final : public UMordhauMotion
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AMordhauEquipment*                      RangedEquipment;                                   // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        CurrentlyPlayingRangedCancel;                      // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangedCancelMotion">();
	}
	static class URangedCancelMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangedCancelMotion>();
	}
};
static_assert(alignof(URangedCancelMotion) == 0x000008, "Wrong alignment on URangedCancelMotion");
static_assert(sizeof(URangedCancelMotion) == 0x0000B8, "Wrong size on URangedCancelMotion");
static_assert(offsetof(URangedCancelMotion, RangedEquipment) == 0x0000A8, "Member 'URangedCancelMotion::RangedEquipment' has a wrong offset!");
static_assert(offsetof(URangedCancelMotion, CurrentlyPlayingRangedCancel) == 0x0000B0, "Member 'URangedCancelMotion::CurrentlyPlayingRangedCancel' has a wrong offset!");

// Class Mordhau.ConfigCommand
// 0x0050 (0x00D0 - 0x0080)
class UConfigCommand final : public URconCommand
{
public:
	TMap<class FString, EConfigValueType>         ValueTypes;                                        // 0x0080(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfigCommand">();
	}
	static class UConfigCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfigCommand>();
	}
};
static_assert(alignof(UConfigCommand) == 0x000008, "Wrong alignment on UConfigCommand");
static_assert(sizeof(UConfigCommand) == 0x0000D0, "Wrong size on UConfigCommand");
static_assert(offsetof(UConfigCommand, ValueTypes) == 0x000080, "Member 'UConfigCommand::ValueTypes' has a wrong offset!");

// Class Mordhau.ControlPoint
// 0x0118 (0x0338 - 0x0220)
class AControlPoint : public AActor
{
public:
	TArray<class AActor*>                         OverlapsCache;                                     // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FText                                   Name_0;                                            // 0x0230(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bShouldPauseCaptureIfEnemyNear;                    // 0x0248(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bObjectivesCompleted;                              // 0x0249(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHiddenPoint;                                    // 0x024A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCapturable;                                     // 0x024B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeam1OwnsPrerequisites;                           // 0x024C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeam2OwnsPrerequisites;                           // 0x024D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnsDisabled;                                   // 0x024E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F[0x1];                                      // 0x024F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               DecalMaterialInstance;                             // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnsTeam;                                        // 0x0258(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnsToken;                                       // 0x025C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMordhauWidgetComponent*                WidgetComponent;                                   // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotShowFloaterWidget;                           // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotShowInTopBarWidget;                          // 0x0269(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A[0x6];                                      // 0x026A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     UIMaterial;                                        // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               UIMaterialInstance;                                // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LastSetUIIconColor;                                // 0x0280(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LastSetUIBorderColor;                              // 0x0290(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSetUIProgress;                                 // 0x02A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AwardScoreInterval;                                // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AwardScoreCapturing;                               // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AwardScoreCaptured;                                // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AwardScoreNeutralizing;                            // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AwardScoreNeutralized;                             // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ACapturePointBanner*>            Banners;                                           // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    CaptureArea;                                       // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CaptureProgress;                                   // 0x02D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnchangedCaptureProgressTime;                      // 0x02D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBannersDoNotAnimateCaptureProgress;               // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedCaptureProgress;                         // 0x02D9(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DA[0x2];                                      // 0x02DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NetworkSmoothTime;                                 // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OwningTeam;                                        // 0x02E0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CapturingTeam;                                     // 0x02E1(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E2[0x6];                                      // 0x02E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AControlPoint*>                  Team1PrerequisitePoints;                           // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AControlPoint*>                  Team2PrerequisitePoints;                           // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AMordhauPlayerStart*>            SpawnPoints;                                       // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Team1Presence;                                     // 0x0318(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Team2Presence;                                     // 0x031C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlashing;                                       // 0x0320(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreventSpawningIfContested;                       // 0x0321(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEverReplicatedProgress;                        // 0x0322(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_323[0x1];                                      // 0x0323(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UncaptureSpeed;                                    // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            NeutralizeSpeedCurve;                              // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CaptureSpeedCurve;                                 // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CanCapture(uint8 Team);
	void EnemyGainedPrerequisites();
	void EnemyLostPrerequisites();
	void OnCaptureAreaBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnCaptureAreaEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnCapturingTeamChanged();
	void OnOwningTeamChanged();
	void OnRep_CapturingTeam();
	void OnRep_OwningTeam();
	void OnRep_ReplicatedCaptureProgress();
	void OnStartedFlashing();
	void OnStoppedFlashing();
	void SetCaptureProgress(float NewProgress, uint8 NewCaptor, bool bAwardScore);
	void SetCapturingTeam(uint8 NewTeam);
	void SetOwningTeam(uint8 NewTeam);
	void UpdateCaptureProgress(float DeltaTime);
	void UpdatePresenceNumbers();
	void UpdateUIMaterialInstance();
	void UpdateUIWidgets();
	void UpdateVisuals();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlPoint">();
	}
	static class AControlPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AControlPoint>();
	}
};
static_assert(alignof(AControlPoint) == 0x000008, "Wrong alignment on AControlPoint");
static_assert(sizeof(AControlPoint) == 0x000338, "Wrong size on AControlPoint");
static_assert(offsetof(AControlPoint, OverlapsCache) == 0x000220, "Member 'AControlPoint::OverlapsCache' has a wrong offset!");
static_assert(offsetof(AControlPoint, Name_0) == 0x000230, "Member 'AControlPoint::Name_0' has a wrong offset!");
static_assert(offsetof(AControlPoint, bShouldPauseCaptureIfEnemyNear) == 0x000248, "Member 'AControlPoint::bShouldPauseCaptureIfEnemyNear' has a wrong offset!");
static_assert(offsetof(AControlPoint, bObjectivesCompleted) == 0x000249, "Member 'AControlPoint::bObjectivesCompleted' has a wrong offset!");
static_assert(offsetof(AControlPoint, bIsHiddenPoint) == 0x00024A, "Member 'AControlPoint::bIsHiddenPoint' has a wrong offset!");
static_assert(offsetof(AControlPoint, bIsCapturable) == 0x00024B, "Member 'AControlPoint::bIsCapturable' has a wrong offset!");
static_assert(offsetof(AControlPoint, bTeam1OwnsPrerequisites) == 0x00024C, "Member 'AControlPoint::bTeam1OwnsPrerequisites' has a wrong offset!");
static_assert(offsetof(AControlPoint, bTeam2OwnsPrerequisites) == 0x00024D, "Member 'AControlPoint::bTeam2OwnsPrerequisites' has a wrong offset!");
static_assert(offsetof(AControlPoint, bSpawnsDisabled) == 0x00024E, "Member 'AControlPoint::bSpawnsDisabled' has a wrong offset!");
static_assert(offsetof(AControlPoint, DecalMaterialInstance) == 0x000250, "Member 'AControlPoint::DecalMaterialInstance' has a wrong offset!");
static_assert(offsetof(AControlPoint, SpawnsTeam) == 0x000258, "Member 'AControlPoint::SpawnsTeam' has a wrong offset!");
static_assert(offsetof(AControlPoint, SpawnsToken) == 0x00025C, "Member 'AControlPoint::SpawnsToken' has a wrong offset!");
static_assert(offsetof(AControlPoint, WidgetComponent) == 0x000260, "Member 'AControlPoint::WidgetComponent' has a wrong offset!");
static_assert(offsetof(AControlPoint, bDoNotShowFloaterWidget) == 0x000268, "Member 'AControlPoint::bDoNotShowFloaterWidget' has a wrong offset!");
static_assert(offsetof(AControlPoint, bDoNotShowInTopBarWidget) == 0x000269, "Member 'AControlPoint::bDoNotShowInTopBarWidget' has a wrong offset!");
static_assert(offsetof(AControlPoint, UIMaterial) == 0x000270, "Member 'AControlPoint::UIMaterial' has a wrong offset!");
static_assert(offsetof(AControlPoint, UIMaterialInstance) == 0x000278, "Member 'AControlPoint::UIMaterialInstance' has a wrong offset!");
static_assert(offsetof(AControlPoint, LastSetUIIconColor) == 0x000280, "Member 'AControlPoint::LastSetUIIconColor' has a wrong offset!");
static_assert(offsetof(AControlPoint, LastSetUIBorderColor) == 0x000290, "Member 'AControlPoint::LastSetUIBorderColor' has a wrong offset!");
static_assert(offsetof(AControlPoint, LastSetUIProgress) == 0x0002A0, "Member 'AControlPoint::LastSetUIProgress' has a wrong offset!");
static_assert(offsetof(AControlPoint, AwardScoreInterval) == 0x0002A4, "Member 'AControlPoint::AwardScoreInterval' has a wrong offset!");
static_assert(offsetof(AControlPoint, AwardScoreCapturing) == 0x0002A8, "Member 'AControlPoint::AwardScoreCapturing' has a wrong offset!");
static_assert(offsetof(AControlPoint, AwardScoreCaptured) == 0x0002AC, "Member 'AControlPoint::AwardScoreCaptured' has a wrong offset!");
static_assert(offsetof(AControlPoint, AwardScoreNeutralizing) == 0x0002B0, "Member 'AControlPoint::AwardScoreNeutralizing' has a wrong offset!");
static_assert(offsetof(AControlPoint, AwardScoreNeutralized) == 0x0002B4, "Member 'AControlPoint::AwardScoreNeutralized' has a wrong offset!");
static_assert(offsetof(AControlPoint, Banners) == 0x0002B8, "Member 'AControlPoint::Banners' has a wrong offset!");
static_assert(offsetof(AControlPoint, CaptureArea) == 0x0002C8, "Member 'AControlPoint::CaptureArea' has a wrong offset!");
static_assert(offsetof(AControlPoint, CaptureProgress) == 0x0002D0, "Member 'AControlPoint::CaptureProgress' has a wrong offset!");
static_assert(offsetof(AControlPoint, UnchangedCaptureProgressTime) == 0x0002D4, "Member 'AControlPoint::UnchangedCaptureProgressTime' has a wrong offset!");
static_assert(offsetof(AControlPoint, bBannersDoNotAnimateCaptureProgress) == 0x0002D8, "Member 'AControlPoint::bBannersDoNotAnimateCaptureProgress' has a wrong offset!");
static_assert(offsetof(AControlPoint, ReplicatedCaptureProgress) == 0x0002D9, "Member 'AControlPoint::ReplicatedCaptureProgress' has a wrong offset!");
static_assert(offsetof(AControlPoint, NetworkSmoothTime) == 0x0002DC, "Member 'AControlPoint::NetworkSmoothTime' has a wrong offset!");
static_assert(offsetof(AControlPoint, OwningTeam) == 0x0002E0, "Member 'AControlPoint::OwningTeam' has a wrong offset!");
static_assert(offsetof(AControlPoint, CapturingTeam) == 0x0002E1, "Member 'AControlPoint::CapturingTeam' has a wrong offset!");
static_assert(offsetof(AControlPoint, Team1PrerequisitePoints) == 0x0002E8, "Member 'AControlPoint::Team1PrerequisitePoints' has a wrong offset!");
static_assert(offsetof(AControlPoint, Team2PrerequisitePoints) == 0x0002F8, "Member 'AControlPoint::Team2PrerequisitePoints' has a wrong offset!");
static_assert(offsetof(AControlPoint, SpawnPoints) == 0x000308, "Member 'AControlPoint::SpawnPoints' has a wrong offset!");
static_assert(offsetof(AControlPoint, Team1Presence) == 0x000318, "Member 'AControlPoint::Team1Presence' has a wrong offset!");
static_assert(offsetof(AControlPoint, Team2Presence) == 0x00031C, "Member 'AControlPoint::Team2Presence' has a wrong offset!");
static_assert(offsetof(AControlPoint, bIsFlashing) == 0x000320, "Member 'AControlPoint::bIsFlashing' has a wrong offset!");
static_assert(offsetof(AControlPoint, bPreventSpawningIfContested) == 0x000321, "Member 'AControlPoint::bPreventSpawningIfContested' has a wrong offset!");
static_assert(offsetof(AControlPoint, bHasEverReplicatedProgress) == 0x000322, "Member 'AControlPoint::bHasEverReplicatedProgress' has a wrong offset!");
static_assert(offsetof(AControlPoint, UncaptureSpeed) == 0x000324, "Member 'AControlPoint::UncaptureSpeed' has a wrong offset!");
static_assert(offsetof(AControlPoint, NeutralizeSpeedCurve) == 0x000328, "Member 'AControlPoint::NeutralizeSpeedCurve' has a wrong offset!");
static_assert(offsetof(AControlPoint, CaptureSpeedCurve) == 0x000330, "Member 'AControlPoint::CaptureSpeedCurve' has a wrong offset!");

// Class Mordhau.DisarmedMotion
// 0x0008 (0x00A8 - 0x00A0)
class UDisarmedMotion : public UMordhauMotion
{
public:
	float                                         RecoveryTime;                                      // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisarmedMotion">();
	}
	static class UDisarmedMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisarmedMotion>();
	}
};
static_assert(alignof(UDisarmedMotion) == 0x000008, "Wrong alignment on UDisarmedMotion");
static_assert(sizeof(UDisarmedMotion) == 0x0000A8, "Wrong size on UDisarmedMotion");
static_assert(offsetof(UDisarmedMotion, RecoveryTime) == 0x0000A0, "Member 'UDisarmedMotion::RecoveryTime' has a wrong offset!");

// Class Mordhau.DismemberableComponent
// 0x0270 (0x0320 - 0x00B0)
class UDismemberableComponent final : public UActorComponent
{
public:
	TWeakObjectPtr<class AActor>                  QueuedDismemberAgent;                              // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ASeparatedBodyPart>      SeparatedHead;                                     // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ASeparatedBodyPart>> SeparatedBodyParts;                                // 0x00C0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, TWeakObjectPtr<class AActor>> AttachedGoreMeshes;                                // 0x00D0(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<class FName>                             DismemberedBones;                                  // 0x0120(0x0050)(NativeAccessSpecifierPublic)
	struct FWoundInfo                             DismemberWoundInfo;                                // 0x0170(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ASeparatedBodyPart>         BodyPart;                                          // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DismembermentGore;                                 // 0x0190(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              BluntDismembermentGore;                            // 0x0198(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGoreActor>                 OutGoreMeshBlunt;                                  // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGoreActor>                 OutGoreMesh;                                       // 0x01A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGoreActor>                 OutGoreMeshNeck;                                   // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        LimbExplosionParticle;                             // 0x01B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistFromBoneForAnyDismember;                    // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleDistFromBoneForAnyDismember;               // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistFromBoneForFullDismember;                   // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleDistFromBoneForFullDismember;              // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollMaxDistFromBoneForAnyDismember;             // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollMaxDistFromBoneForFullDismember;            // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      MinimumDamageToExplode;                            // 0x01D8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      MinimumDamageToDismember;                          // 0x0228(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      MinimumDamageToPartialDismember;                   // 0x0278(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector2D                              DismemberArmsSpineYawPitchLimit;                   // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FName>                             DismemberableBones;                                // 0x02D0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	class ASeparatedBodyPart* Dismember(struct FDismemberedBoneData* InDismemberedBoneData);
	void OnCharacterCameraStyleChanged(class AMordhauCharacter* Character);
	bool ProcessQueuedDismemberment();
	bool QueueDismember(class FName bone, bool bIsDismemberPartial, bool bIsBluntForce, const struct FVector& Force, class AActor* Agent);
	bool TryDismember(class FName bone, const struct FVector& Point, class AMordhauWeapon* Weapon, EAttackMove Move, bool bIsRagdollDismember);

	bool CanDismember(class FName bone) const;
	bool IsBoneDismembered(class FName bone) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DismemberableComponent">();
	}
	static class UDismemberableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDismemberableComponent>();
	}
};
static_assert(alignof(UDismemberableComponent) == 0x000008, "Wrong alignment on UDismemberableComponent");
static_assert(sizeof(UDismemberableComponent) == 0x000320, "Wrong size on UDismemberableComponent");
static_assert(offsetof(UDismemberableComponent, QueuedDismemberAgent) == 0x0000B0, "Member 'UDismemberableComponent::QueuedDismemberAgent' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, SeparatedHead) == 0x0000B8, "Member 'UDismemberableComponent::SeparatedHead' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, SeparatedBodyParts) == 0x0000C0, "Member 'UDismemberableComponent::SeparatedBodyParts' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, AttachedGoreMeshes) == 0x0000D0, "Member 'UDismemberableComponent::AttachedGoreMeshes' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, DismemberedBones) == 0x000120, "Member 'UDismemberableComponent::DismemberedBones' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, DismemberWoundInfo) == 0x000170, "Member 'UDismemberableComponent::DismemberWoundInfo' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, BodyPart) == 0x000188, "Member 'UDismemberableComponent::BodyPart' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, DismembermentGore) == 0x000190, "Member 'UDismemberableComponent::DismembermentGore' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, BluntDismembermentGore) == 0x000198, "Member 'UDismemberableComponent::BluntDismembermentGore' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, OutGoreMeshBlunt) == 0x0001A0, "Member 'UDismemberableComponent::OutGoreMeshBlunt' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, OutGoreMesh) == 0x0001A8, "Member 'UDismemberableComponent::OutGoreMesh' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, OutGoreMeshNeck) == 0x0001B0, "Member 'UDismemberableComponent::OutGoreMeshNeck' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, LimbExplosionParticle) == 0x0001B8, "Member 'UDismemberableComponent::LimbExplosionParticle' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, MaxDistFromBoneForAnyDismember) == 0x0001C0, "Member 'UDismemberableComponent::MaxDistFromBoneForAnyDismember' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, MaxAngleDistFromBoneForAnyDismember) == 0x0001C4, "Member 'UDismemberableComponent::MaxAngleDistFromBoneForAnyDismember' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, MaxDistFromBoneForFullDismember) == 0x0001C8, "Member 'UDismemberableComponent::MaxDistFromBoneForFullDismember' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, MaxAngleDistFromBoneForFullDismember) == 0x0001CC, "Member 'UDismemberableComponent::MaxAngleDistFromBoneForFullDismember' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, RagdollMaxDistFromBoneForAnyDismember) == 0x0001D0, "Member 'UDismemberableComponent::RagdollMaxDistFromBoneForAnyDismember' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, RagdollMaxDistFromBoneForFullDismember) == 0x0001D4, "Member 'UDismemberableComponent::RagdollMaxDistFromBoneForFullDismember' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, MinimumDamageToExplode) == 0x0001D8, "Member 'UDismemberableComponent::MinimumDamageToExplode' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, MinimumDamageToDismember) == 0x000228, "Member 'UDismemberableComponent::MinimumDamageToDismember' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, MinimumDamageToPartialDismember) == 0x000278, "Member 'UDismemberableComponent::MinimumDamageToPartialDismember' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, DismemberArmsSpineYawPitchLimit) == 0x0002C8, "Member 'UDismemberableComponent::DismemberArmsSpineYawPitchLimit' has a wrong offset!");
static_assert(offsetof(UDismemberableComponent, DismemberableBones) == 0x0002D0, "Member 'UDismemberableComponent::DismemberableBones' has a wrong offset!");

// Class Mordhau.DriverComponent
// 0x00B0 (0x0160 - 0x00B0)
class UDriverComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0xB0];                                      // 0x00B0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLateTick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DriverComponent">();
	}
	static class UDriverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDriverComponent>();
	}
};
static_assert(alignof(UDriverComponent) == 0x000008, "Wrong alignment on UDriverComponent");
static_assert(sizeof(UDriverComponent) == 0x000160, "Wrong size on UDriverComponent");

// Class Mordhau.PhysicsVehicleAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UPhysicsVehicleAnimInstance : public UAnimInstance
{
public:
	float                                         Velocity;                                          // 0x02B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AVehicleBase*                           VehicleOwner;                                      // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsVehicleAnimInstance">();
	}
	static class UPhysicsVehicleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsVehicleAnimInstance>();
	}
};
static_assert(alignof(UPhysicsVehicleAnimInstance) == 0x000010, "Wrong alignment on UPhysicsVehicleAnimInstance");
static_assert(sizeof(UPhysicsVehicleAnimInstance) == 0x0002D0, "Wrong size on UPhysicsVehicleAnimInstance");
static_assert(offsetof(UPhysicsVehicleAnimInstance, Velocity) == 0x0002B8, "Member 'UPhysicsVehicleAnimInstance::Velocity' has a wrong offset!");
static_assert(offsetof(UPhysicsVehicleAnimInstance, VehicleOwner) == 0x0002C0, "Member 'UPhysicsVehicleAnimInstance::VehicleOwner' has a wrong offset!");

// Class Mordhau.DropEquipmentMotion
// 0x0020 (0x00C0 - 0x00A0)
class UDropEquipmentMotion final : public UMordhauMotion
{
public:
	bool                                          bIsDroppingRightHand;                              // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMordhauEquipment*                      DroppingEquipment;                                 // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropTime;                                          // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDropped;                                       // 0x00BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropEquipmentMotion">();
	}
	static class UDropEquipmentMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropEquipmentMotion>();
	}
};
static_assert(alignof(UDropEquipmentMotion) == 0x000008, "Wrong alignment on UDropEquipmentMotion");
static_assert(sizeof(UDropEquipmentMotion) == 0x0000C0, "Wrong size on UDropEquipmentMotion");
static_assert(offsetof(UDropEquipmentMotion, bIsDroppingRightHand) == 0x0000A0, "Member 'UDropEquipmentMotion::bIsDroppingRightHand' has a wrong offset!");
static_assert(offsetof(UDropEquipmentMotion, DroppingEquipment) == 0x0000A8, "Member 'UDropEquipmentMotion::DroppingEquipment' has a wrong offset!");
static_assert(offsetof(UDropEquipmentMotion, Montage) == 0x0000B0, "Member 'UDropEquipmentMotion::Montage' has a wrong offset!");
static_assert(offsetof(UDropEquipmentMotion, DropTime) == 0x0000B8, "Member 'UDropEquipmentMotion::DropTime' has a wrong offset!");
static_assert(offsetof(UDropEquipmentMotion, bHasDropped) == 0x0000BC, "Member 'UDropEquipmentMotion::bHasDropped' has a wrong offset!");

// Class Mordhau.ECSActor
// 0x0108 (0x0328 - 0x0220)
class AECSActor final : public AActor
{
public:
	int32                                         TotalCharacters;                                   // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneTopLeft;                                      // 0x0224(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneBottomRight;                                  // 0x0230(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveVelocityMax;                                   // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimTicksPerFrame;                                 // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionEnabled                             CollisionEnabled;                                  // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          PhysicsAsset;                                      // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimInstance;                                      // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UECSSkeletalMeshComponent*>      SkeletalMeshComponents;                            // 0x0268(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FCharPhysics>                   CharPhysics;                                       // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharMove>                      CharMove;                                          // 0x0288(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ACharacter*>                     ManagedCharacters;                                 // 0x0298(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharPhysics>                   ManagedCharPhysics;                                // 0x02A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharMove>                      ManagedCharMove;                                   // 0x02B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FECSDuringPhysicsTickFunction          DuringPhysicsTickFunction;                         // 0x02C8(0x0030)(NativeAccessSpecifierPublic)
	struct FECSPostPhysicsTickFunction            PostPhysicsTickFunction;                           // 0x02F8(0x0030)(NativeAccessSpecifierPublic)

public:
	void AddManagedCharacter(class ACharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ECSActor">();
	}
	static class AECSActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AECSActor>();
	}
};
static_assert(alignof(AECSActor) == 0x000008, "Wrong alignment on AECSActor");
static_assert(sizeof(AECSActor) == 0x000328, "Wrong size on AECSActor");
static_assert(offsetof(AECSActor, TotalCharacters) == 0x000220, "Member 'AECSActor::TotalCharacters' has a wrong offset!");
static_assert(offsetof(AECSActor, PlaneTopLeft) == 0x000224, "Member 'AECSActor::PlaneTopLeft' has a wrong offset!");
static_assert(offsetof(AECSActor, PlaneBottomRight) == 0x000230, "Member 'AECSActor::PlaneBottomRight' has a wrong offset!");
static_assert(offsetof(AECSActor, MoveVelocityMax) == 0x00023C, "Member 'AECSActor::MoveVelocityMax' has a wrong offset!");
static_assert(offsetof(AECSActor, AnimTicksPerFrame) == 0x000240, "Member 'AECSActor::AnimTicksPerFrame' has a wrong offset!");
static_assert(offsetof(AECSActor, SkeletalMesh) == 0x000248, "Member 'AECSActor::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AECSActor, CollisionEnabled) == 0x000250, "Member 'AECSActor::CollisionEnabled' has a wrong offset!");
static_assert(offsetof(AECSActor, PhysicsAsset) == 0x000258, "Member 'AECSActor::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(AECSActor, AnimInstance) == 0x000260, "Member 'AECSActor::AnimInstance' has a wrong offset!");
static_assert(offsetof(AECSActor, SkeletalMeshComponents) == 0x000268, "Member 'AECSActor::SkeletalMeshComponents' has a wrong offset!");
static_assert(offsetof(AECSActor, CharPhysics) == 0x000278, "Member 'AECSActor::CharPhysics' has a wrong offset!");
static_assert(offsetof(AECSActor, CharMove) == 0x000288, "Member 'AECSActor::CharMove' has a wrong offset!");
static_assert(offsetof(AECSActor, ManagedCharacters) == 0x000298, "Member 'AECSActor::ManagedCharacters' has a wrong offset!");
static_assert(offsetof(AECSActor, ManagedCharPhysics) == 0x0002A8, "Member 'AECSActor::ManagedCharPhysics' has a wrong offset!");
static_assert(offsetof(AECSActor, ManagedCharMove) == 0x0002B8, "Member 'AECSActor::ManagedCharMove' has a wrong offset!");
static_assert(offsetof(AECSActor, DuringPhysicsTickFunction) == 0x0002C8, "Member 'AECSActor::DuringPhysicsTickFunction' has a wrong offset!");
static_assert(offsetof(AECSActor, PostPhysicsTickFunction) == 0x0002F8, "Member 'AECSActor::PostPhysicsTickFunction' has a wrong offset!");

// Class Mordhau.MordhauCustomizationTypes
// 0x0000 (0x0028 - 0x0028)
class UMordhauCustomizationTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauCustomizationTypes">();
	}
	static class UMordhauCustomizationTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauCustomizationTypes>();
	}
};
static_assert(alignof(UMordhauCustomizationTypes) == 0x000008, "Wrong alignment on UMordhauCustomizationTypes");
static_assert(sizeof(UMordhauCustomizationTypes) == 0x000028, "Wrong size on UMordhauCustomizationTypes");

// Class Mordhau.ECSSkeletalMeshComponent
// 0x0010 (0x0EE0 - 0x0ED0)
class UECSSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	bool                                          bCanTickThisFrame;                                 // 0x0ED0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED1[0x3];                                      // 0x0ED1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AccumulatedDeltaTime;                              // 0x0ED4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED8[0x8];                                      // 0x0ED8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ECSSkeletalMeshComponent">();
	}
	static class UECSSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UECSSkeletalMeshComponent>();
	}
};
static_assert(alignof(UECSSkeletalMeshComponent) == 0x000010, "Wrong alignment on UECSSkeletalMeshComponent");
static_assert(sizeof(UECSSkeletalMeshComponent) == 0x000EE0, "Wrong size on UECSSkeletalMeshComponent");
static_assert(offsetof(UECSSkeletalMeshComponent, bCanTickThisFrame) == 0x000ED0, "Member 'UECSSkeletalMeshComponent::bCanTickThisFrame' has a wrong offset!");
static_assert(offsetof(UECSSkeletalMeshComponent, AccumulatedDeltaTime) == 0x000ED4, "Member 'UECSSkeletalMeshComponent::AccumulatedDeltaTime' has a wrong offset!");

// Class Mordhau.Emblem
// 0x0008 (0x0068 - 0x0060)
class UEmblem : public UMordhauInventoryItem
{
public:
	class UTexture2D*                             Texture;                                           // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Emblem">();
	}
	static class UEmblem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmblem>();
	}
};
static_assert(alignof(UEmblem) == 0x000008, "Wrong alignment on UEmblem");
static_assert(sizeof(UEmblem) == 0x000068, "Wrong size on UEmblem");
static_assert(offsetof(UEmblem, Texture) == 0x000060, "Member 'UEmblem::Texture' has a wrong offset!");

// Class Mordhau.EmoteCancelMotion
// 0x0000 (0x00A0 - 0x00A0)
class UEmoteCancelMotion : public UMordhauMotion
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteCancelMotion">();
	}
	static class UEmoteCancelMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteCancelMotion>();
	}
};
static_assert(alignof(UEmoteCancelMotion) == 0x000008, "Wrong alignment on UEmoteCancelMotion");
static_assert(sizeof(UEmoteCancelMotion) == 0x0000A0, "Wrong size on UEmoteCancelMotion");

// Class Mordhau.EmoteMotion
// 0x0090 (0x0130 - 0x00A0)
class UEmoteMotion : public UMordhauMotion
{
public:
	class FText                                   EmoteName;                                         // 0x00A0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CanEmoteAfter;                                     // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CancelTime;                                        // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CancelBlendTime;                                   // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TurnCaps;                                          // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TransitionInMontage;                               // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TransitionOutMontage;                              // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FaceMontage;                                       // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartMontageTime;                                  // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTransitionOutMontageTime;                     // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForce3P;                                          // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideLeftHand;                                     // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideRightHand;                                    // 0x00FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnequipLeftHand;                                  // 0x00FB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnequipRightHand;                                 // 0x00FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDropLeftHand;                                     // 0x00FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE[0x2];                                       // 0x00FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeftHandDropForce;                                 // 0x0100(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDropRightHand;                                    // 0x010C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RightHandDropForce;                                // 0x0110(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasIn1P;                                          // 0x011C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasStartedMainMontage;                            // 0x011D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasStartedMainMontageTransitionOut;               // 0x011E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11F[0x1];                                      // 0x011F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AMordhauEquipment>       HidLeft;                                           // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauEquipment>       HidRight;                                          // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DoDrop(class AMordhauEquipment* Equipment, const struct FVector& Force);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteMotion">();
	}
	static class UEmoteMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteMotion>();
	}
};
static_assert(alignof(UEmoteMotion) == 0x000008, "Wrong alignment on UEmoteMotion");
static_assert(sizeof(UEmoteMotion) == 0x000130, "Wrong size on UEmoteMotion");
static_assert(offsetof(UEmoteMotion, EmoteName) == 0x0000A0, "Member 'UEmoteMotion::EmoteName' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, Duration) == 0x0000B8, "Member 'UEmoteMotion::Duration' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, CanEmoteAfter) == 0x0000BC, "Member 'UEmoteMotion::CanEmoteAfter' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, CancelTime) == 0x0000C0, "Member 'UEmoteMotion::CancelTime' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, CancelBlendTime) == 0x0000C4, "Member 'UEmoteMotion::CancelBlendTime' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, TurnCaps) == 0x0000C8, "Member 'UEmoteMotion::TurnCaps' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, TransitionInMontage) == 0x0000D0, "Member 'UEmoteMotion::TransitionInMontage' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, Montage) == 0x0000D8, "Member 'UEmoteMotion::Montage' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, TransitionOutMontage) == 0x0000E0, "Member 'UEmoteMotion::TransitionOutMontage' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, FaceMontage) == 0x0000E8, "Member 'UEmoteMotion::FaceMontage' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, StartMontageTime) == 0x0000F0, "Member 'UEmoteMotion::StartMontageTime' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, StartTransitionOutMontageTime) == 0x0000F4, "Member 'UEmoteMotion::StartTransitionOutMontageTime' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, bForce3P) == 0x0000F8, "Member 'UEmoteMotion::bForce3P' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, bHideLeftHand) == 0x0000F9, "Member 'UEmoteMotion::bHideLeftHand' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, bHideRightHand) == 0x0000FA, "Member 'UEmoteMotion::bHideRightHand' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, bUnequipLeftHand) == 0x0000FB, "Member 'UEmoteMotion::bUnequipLeftHand' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, bUnequipRightHand) == 0x0000FC, "Member 'UEmoteMotion::bUnequipRightHand' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, bDropLeftHand) == 0x0000FD, "Member 'UEmoteMotion::bDropLeftHand' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, LeftHandDropForce) == 0x000100, "Member 'UEmoteMotion::LeftHandDropForce' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, bDropRightHand) == 0x00010C, "Member 'UEmoteMotion::bDropRightHand' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, RightHandDropForce) == 0x000110, "Member 'UEmoteMotion::RightHandDropForce' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, bWasIn1P) == 0x00011C, "Member 'UEmoteMotion::bWasIn1P' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, bHasStartedMainMontage) == 0x00011D, "Member 'UEmoteMotion::bHasStartedMainMontage' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, bHasStartedMainMontageTransitionOut) == 0x00011E, "Member 'UEmoteMotion::bHasStartedMainMontageTransitionOut' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, HidLeft) == 0x000120, "Member 'UEmoteMotion::HidLeft' has a wrong offset!");
static_assert(offsetof(UEmoteMotion, HidRight) == 0x000128, "Member 'UEmoteMotion::HidRight' has a wrong offset!");

// Class Mordhau.MordhauDialog
// 0x0018 (0x0278 - 0x0260)
class UMordhauDialog : public UUserWidget
{
public:
	TMulticastInlineDelegate<void()>              OnRequestDialogFocus;                              // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsNoButtonDialog;                                 // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceAllUserFocus(EFocusCause FocusCause);
	void Hide();
	void OnHidden();
	void OnShown();
	void RequestFocus();
	void Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauDialog">();
	}
	static class UMordhauDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauDialog>();
	}
};
static_assert(alignof(UMordhauDialog) == 0x000008, "Wrong alignment on UMordhauDialog");
static_assert(sizeof(UMordhauDialog) == 0x000278, "Wrong size on UMordhauDialog");
static_assert(offsetof(UMordhauDialog, OnRequestDialogFocus) == 0x000260, "Member 'UMordhauDialog::OnRequestDialogFocus' has a wrong offset!");
static_assert(offsetof(UMordhauDialog, bIsNoButtonDialog) == 0x000270, "Member 'UMordhauDialog::bIsNoButtonDialog' has a wrong offset!");

// Class Mordhau.MordhauControllerPairingDialog
// 0x0000 (0x0278 - 0x0278)
class UMordhauControllerPairingDialog final : public UMordhauDialog
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauControllerPairingDialog">();
	}
	static class UMordhauControllerPairingDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauControllerPairingDialog>();
	}
};
static_assert(alignof(UMordhauControllerPairingDialog) == 0x000008, "Wrong alignment on UMordhauControllerPairingDialog");
static_assert(sizeof(UMordhauControllerPairingDialog) == 0x000278, "Wrong size on UMordhauControllerPairingDialog");

// Class Mordhau.EmoteSwitcherMotion
// 0x0008 (0x00A8 - 0x00A0)
class UEmoteSwitcherMotion final : public UMordhauMotion
{
public:
	uint8                                         SwitchToID;                                        // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteSwitcherMotion">();
	}
	static class UEmoteSwitcherMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteSwitcherMotion>();
	}
};
static_assert(alignof(UEmoteSwitcherMotion) == 0x000008, "Wrong alignment on UEmoteSwitcherMotion");
static_assert(sizeof(UEmoteSwitcherMotion) == 0x0000A8, "Wrong size on UEmoteSwitcherMotion");
static_assert(offsetof(UEmoteSwitcherMotion, SwitchToID) == 0x0000A0, "Member 'UEmoteSwitcherMotion::SwitchToID' has a wrong offset!");

// Class Mordhau.EnterVehicleMotion
// 0x0000 (0x00A0 - 0x00A0)
class UEnterVehicleMotion final : public UMordhauMotion
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnterVehicleMotion">();
	}
	static class UEnterVehicleMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnterVehicleMotion>();
	}
};
static_assert(alignof(UEnterVehicleMotion) == 0x000008, "Wrong alignment on UEnterVehicleMotion");
static_assert(sizeof(UEnterVehicleMotion) == 0x0000A0, "Wrong size on UEnterVehicleMotion");

// Class Mordhau.MordhauHUDWidgetComponent
// 0x0028 (0x00D8 - 0x00B0)
class UMordhauHUDWidgetComponent final : public UActorComponent
{
public:
	bool                                          bCreateOnBeginPlay;                                // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOnBeginPlay;                                  // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                WidgetBPReference;                                 // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            Widget;                                            // 0x00C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsPendingToShow;                                  // 0x00C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0xF];                                       // 0x00C9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUserWidget* GetHUDWidget();
	void HideWidget();
	void InstantiateWidget();
	void OnCharacterOwnerBecomeViewTarget(class AAdvancedCharacter* CharacterOwner);
	void OnCharacterOwnerEndViewTarget(class AAdvancedCharacter* CharacterOwner);
	void RemoveWidget();
	bool ShowWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauHUDWidgetComponent">();
	}
	static class UMordhauHUDWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauHUDWidgetComponent>();
	}
};
static_assert(alignof(UMordhauHUDWidgetComponent) == 0x000008, "Wrong alignment on UMordhauHUDWidgetComponent");
static_assert(sizeof(UMordhauHUDWidgetComponent) == 0x0000D8, "Wrong size on UMordhauHUDWidgetComponent");
static_assert(offsetof(UMordhauHUDWidgetComponent, bCreateOnBeginPlay) == 0x0000B0, "Member 'UMordhauHUDWidgetComponent::bCreateOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UMordhauHUDWidgetComponent, bShowOnBeginPlay) == 0x0000B1, "Member 'UMordhauHUDWidgetComponent::bShowOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UMordhauHUDWidgetComponent, WidgetBPReference) == 0x0000B8, "Member 'UMordhauHUDWidgetComponent::WidgetBPReference' has a wrong offset!");
static_assert(offsetof(UMordhauHUDWidgetComponent, Widget) == 0x0000C0, "Member 'UMordhauHUDWidgetComponent::Widget' has a wrong offset!");
static_assert(offsetof(UMordhauHUDWidgetComponent, bIsPendingToShow) == 0x0000C8, "Member 'UMordhauHUDWidgetComponent::bIsPendingToShow' has a wrong offset!");

// Class Mordhau.EnvironmentMovable
// 0x0030 (0x0250 - 0x0220)
class AEnvironmentMovable final : public AActor
{
public:
	ESwayMethod                                   SwayMethod;                                        // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USceneComponent>         SwayingComponent;                                  // 0x0224(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RollPitchYawFrequency;                             // 0x022C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RollPitchYawMagnitude;                             // 0x0238(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RollPitchYawSpeed;                                 // 0x0244(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void InitializeMovable(class USceneComponent* InSwayingComponent, const struct FVector& InRollPitchYawFrequency, const struct FVector& InRollPitchYawMagnitude, const struct FVector& InRollPitchYawSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentMovable">();
	}
	static class AEnvironmentMovable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentMovable>();
	}
};
static_assert(alignof(AEnvironmentMovable) == 0x000008, "Wrong alignment on AEnvironmentMovable");
static_assert(sizeof(AEnvironmentMovable) == 0x000250, "Wrong size on AEnvironmentMovable");
static_assert(offsetof(AEnvironmentMovable, SwayMethod) == 0x000220, "Member 'AEnvironmentMovable::SwayMethod' has a wrong offset!");
static_assert(offsetof(AEnvironmentMovable, SwayingComponent) == 0x000224, "Member 'AEnvironmentMovable::SwayingComponent' has a wrong offset!");
static_assert(offsetof(AEnvironmentMovable, RollPitchYawFrequency) == 0x00022C, "Member 'AEnvironmentMovable::RollPitchYawFrequency' has a wrong offset!");
static_assert(offsetof(AEnvironmentMovable, RollPitchYawMagnitude) == 0x000238, "Member 'AEnvironmentMovable::RollPitchYawMagnitude' has a wrong offset!");
static_assert(offsetof(AEnvironmentMovable, RollPitchYawSpeed) == 0x000244, "Member 'AEnvironmentMovable::RollPitchYawSpeed' has a wrong offset!");

// Class Mordhau.EnvQueryGenerator_Equipment
// 0x0008 (0x0058 - 0x0050)
class UEnvQueryGenerator_Equipment final : public UEnvQueryGenerator
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Equipment">();
	}
	static class UEnvQueryGenerator_Equipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Equipment>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Equipment) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Equipment");
static_assert(sizeof(UEnvQueryGenerator_Equipment) == 0x000058, "Wrong size on UEnvQueryGenerator_Equipment");

// Class Mordhau.LateTickComponent
// 0x0008 (0x00B8 - 0x00B0)
class ULateTickComponent final : public UActorComponent
{
public:
	float                                         LODDeltaTime;                                      // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LateTickComponent">();
	}
	static class ULateTickComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULateTickComponent>();
	}
};
static_assert(alignof(ULateTickComponent) == 0x000008, "Wrong alignment on ULateTickComponent");
static_assert(sizeof(ULateTickComponent) == 0x0000B8, "Wrong size on ULateTickComponent");
static_assert(offsetof(ULateTickComponent, LODDeltaTime) == 0x0000B0, "Member 'ULateTickComponent::LODDeltaTime' has a wrong offset!");

// Class Mordhau.EnvQueryGenerator_Objectives
// 0x0008 (0x0058 - 0x0050)
class UEnvQueryGenerator_Objectives final : public UEnvQueryGenerator
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Objectives">();
	}
	static class UEnvQueryGenerator_Objectives* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Objectives>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Objectives) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Objectives");
static_assert(sizeof(UEnvQueryGenerator_Objectives) == 0x000058, "Wrong size on UEnvQueryGenerator_Objectives");

// Class Mordhau.MordhauEQSTestingPawn
// 0x0010 (0x0560 - 0x0550)
class AMordhauEQSTestingPawn final : public AEQSTestingPawn
{
public:
	uint8                                         Team;                                              // 0x0550(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_551[0xF];                                      // 0x0551(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauEQSTestingPawn">();
	}
	static class AMordhauEQSTestingPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauEQSTestingPawn>();
	}
};
static_assert(alignof(AMordhauEQSTestingPawn) == 0x000010, "Wrong alignment on AMordhauEQSTestingPawn");
static_assert(sizeof(AMordhauEQSTestingPawn) == 0x000560, "Wrong size on AMordhauEQSTestingPawn");
static_assert(offsetof(AMordhauEQSTestingPawn, Team) == 0x000550, "Member 'AMordhauEQSTestingPawn::Team' has a wrong offset!");

// Class Mordhau.EnvQueryTest_Objectives
// 0x0008 (0x0200 - 0x01F8)
class UEnvQueryTest_Objectives final : public UEnvQueryTest
{
public:
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Objectives">();
	}
	static class UEnvQueryTest_Objectives* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Objectives>();
	}
};
static_assert(alignof(UEnvQueryTest_Objectives) == 0x000008, "Wrong alignment on UEnvQueryTest_Objectives");
static_assert(sizeof(UEnvQueryTest_Objectives) == 0x000200, "Wrong size on UEnvQueryTest_Objectives");

// Class Mordhau.EquipmentModeSwitchMotion
// 0x0050 (0x00F0 - 0x00A0)
class UEquipmentModeSwitchMotion final : public UMordhauMotion
{
public:
	float                                         Stage1Duration;                                    // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stage2Duration;                                    // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMordhauEquipment*                      SwitchingEquipment;                                // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VirtualReparentLocation;                           // 0x00B8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0xC];                                       // 0x00C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  VirtualReparentRotation;                           // 0x00D0(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsSwitchingToAlt;                                 // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EModeSwitchType                               SwitchType;                                        // 0x00E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FirstStageEnd;                                     // 0x00E4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondStageEnd;                                    // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Stage;                                             // 0x00EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFinishedSwitch;                                // 0x00ED(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EE[0x2];                                       // 0x00EE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentModeSwitchMotion">();
	}
	static class UEquipmentModeSwitchMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentModeSwitchMotion>();
	}
};
static_assert(alignof(UEquipmentModeSwitchMotion) == 0x000010, "Wrong alignment on UEquipmentModeSwitchMotion");
static_assert(sizeof(UEquipmentModeSwitchMotion) == 0x0000F0, "Wrong size on UEquipmentModeSwitchMotion");
static_assert(offsetof(UEquipmentModeSwitchMotion, Stage1Duration) == 0x0000A0, "Member 'UEquipmentModeSwitchMotion::Stage1Duration' has a wrong offset!");
static_assert(offsetof(UEquipmentModeSwitchMotion, Stage2Duration) == 0x0000A4, "Member 'UEquipmentModeSwitchMotion::Stage2Duration' has a wrong offset!");
static_assert(offsetof(UEquipmentModeSwitchMotion, Montage) == 0x0000A8, "Member 'UEquipmentModeSwitchMotion::Montage' has a wrong offset!");
static_assert(offsetof(UEquipmentModeSwitchMotion, SwitchingEquipment) == 0x0000B0, "Member 'UEquipmentModeSwitchMotion::SwitchingEquipment' has a wrong offset!");
static_assert(offsetof(UEquipmentModeSwitchMotion, VirtualReparentLocation) == 0x0000B8, "Member 'UEquipmentModeSwitchMotion::VirtualReparentLocation' has a wrong offset!");
static_assert(offsetof(UEquipmentModeSwitchMotion, VirtualReparentRotation) == 0x0000D0, "Member 'UEquipmentModeSwitchMotion::VirtualReparentRotation' has a wrong offset!");
static_assert(offsetof(UEquipmentModeSwitchMotion, bIsSwitchingToAlt) == 0x0000E0, "Member 'UEquipmentModeSwitchMotion::bIsSwitchingToAlt' has a wrong offset!");
static_assert(offsetof(UEquipmentModeSwitchMotion, SwitchType) == 0x0000E1, "Member 'UEquipmentModeSwitchMotion::SwitchType' has a wrong offset!");
static_assert(offsetof(UEquipmentModeSwitchMotion, FirstStageEnd) == 0x0000E4, "Member 'UEquipmentModeSwitchMotion::FirstStageEnd' has a wrong offset!");
static_assert(offsetof(UEquipmentModeSwitchMotion, SecondStageEnd) == 0x0000E8, "Member 'UEquipmentModeSwitchMotion::SecondStageEnd' has a wrong offset!");
static_assert(offsetof(UEquipmentModeSwitchMotion, Stage) == 0x0000EC, "Member 'UEquipmentModeSwitchMotion::Stage' has a wrong offset!");
static_assert(offsetof(UEquipmentModeSwitchMotion, bHasFinishedSwitch) == 0x0000ED, "Member 'UEquipmentModeSwitchMotion::bHasFinishedSwitch' has a wrong offset!");

// Class Mordhau.EquipmentSwitchMotion
// 0x0038 (0x00D8 - 0x00A0)
class UEquipmentSwitchMotion final : public UMordhauMotion
{
public:
	float                                         UnhideAfterTimeIfDropped;                          // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x1];                                       // 0x00A4(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasFinishedSwitch;                                // 0x00A5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SwitchingToSlot;                                   // 0x00A6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A7[0x1];                                       // 0x00A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AMordhauEquipment>       SwitchingTo;                                       // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauEquipment>       HiddenLeft;                                        // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauEquipment>       HiddenRight;                                       // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReachEnd;                                          // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESwitchStage                                  Stage;                                             // 0x00CC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocalVirtualReparentStart;                         // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AMordhauEquipment* GetSwitchingTo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentSwitchMotion">();
	}
	static class UEquipmentSwitchMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentSwitchMotion>();
	}
};
static_assert(alignof(UEquipmentSwitchMotion) == 0x000008, "Wrong alignment on UEquipmentSwitchMotion");
static_assert(sizeof(UEquipmentSwitchMotion) == 0x0000D8, "Wrong size on UEquipmentSwitchMotion");
static_assert(offsetof(UEquipmentSwitchMotion, UnhideAfterTimeIfDropped) == 0x0000A0, "Member 'UEquipmentSwitchMotion::UnhideAfterTimeIfDropped' has a wrong offset!");
static_assert(offsetof(UEquipmentSwitchMotion, bHasFinishedSwitch) == 0x0000A5, "Member 'UEquipmentSwitchMotion::bHasFinishedSwitch' has a wrong offset!");
static_assert(offsetof(UEquipmentSwitchMotion, SwitchingToSlot) == 0x0000A6, "Member 'UEquipmentSwitchMotion::SwitchingToSlot' has a wrong offset!");
static_assert(offsetof(UEquipmentSwitchMotion, SwitchingTo) == 0x0000A8, "Member 'UEquipmentSwitchMotion::SwitchingTo' has a wrong offset!");
static_assert(offsetof(UEquipmentSwitchMotion, HiddenLeft) == 0x0000B0, "Member 'UEquipmentSwitchMotion::HiddenLeft' has a wrong offset!");
static_assert(offsetof(UEquipmentSwitchMotion, HiddenRight) == 0x0000B8, "Member 'UEquipmentSwitchMotion::HiddenRight' has a wrong offset!");
static_assert(offsetof(UEquipmentSwitchMotion, Montage) == 0x0000C0, "Member 'UEquipmentSwitchMotion::Montage' has a wrong offset!");
static_assert(offsetof(UEquipmentSwitchMotion, ReachEnd) == 0x0000C8, "Member 'UEquipmentSwitchMotion::ReachEnd' has a wrong offset!");
static_assert(offsetof(UEquipmentSwitchMotion, Stage) == 0x0000CC, "Member 'UEquipmentSwitchMotion::Stage' has a wrong offset!");
static_assert(offsetof(UEquipmentSwitchMotion, LocalVirtualReparentStart) == 0x0000D0, "Member 'UEquipmentSwitchMotion::LocalVirtualReparentStart' has a wrong offset!");

// Class Mordhau.EquipmentSystemComponent
// 0x0040 (0x00F0 - 0x00B0)
class UEquipmentSystemComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AMordhauEquipment>> PrevReplicatedEquipment;                           // 0x00C0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauEquipment>       PrevReplicatedLeftHandEquipment;                   // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauEquipment>       PrevReplicatedRightHandEquipment;                  // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   QuiverStaticMeshComponent;                         // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathEquipmentRagdollAngularFactor;                // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathEquipmentRagdollTranslationalFactor;          // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnAnyEquipmentStateChanged();
	void OnCharacterCameraStyleChanged(class AMordhauCharacter* Character);
	void OnCharacterVehicleChanged(class AMordhauCharacter* Character);
	void OnLateTick(float DeltaTime);
	void OnLODTick(float DeltaTime);
	void OnPreBeginPlay(class AMordhauCharacter* Character);
	void OnUnPossessed(class AAdvancedCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentSystemComponent">();
	}
	static class UEquipmentSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentSystemComponent>();
	}
};
static_assert(alignof(UEquipmentSystemComponent) == 0x000008, "Wrong alignment on UEquipmentSystemComponent");
static_assert(sizeof(UEquipmentSystemComponent) == 0x0000F0, "Wrong size on UEquipmentSystemComponent");
static_assert(offsetof(UEquipmentSystemComponent, PrevReplicatedEquipment) == 0x0000C0, "Member 'UEquipmentSystemComponent::PrevReplicatedEquipment' has a wrong offset!");
static_assert(offsetof(UEquipmentSystemComponent, PrevReplicatedLeftHandEquipment) == 0x0000D0, "Member 'UEquipmentSystemComponent::PrevReplicatedLeftHandEquipment' has a wrong offset!");
static_assert(offsetof(UEquipmentSystemComponent, PrevReplicatedRightHandEquipment) == 0x0000D8, "Member 'UEquipmentSystemComponent::PrevReplicatedRightHandEquipment' has a wrong offset!");
static_assert(offsetof(UEquipmentSystemComponent, QuiverStaticMeshComponent) == 0x0000E0, "Member 'UEquipmentSystemComponent::QuiverStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(UEquipmentSystemComponent, DeathEquipmentRagdollAngularFactor) == 0x0000E8, "Member 'UEquipmentSystemComponent::DeathEquipmentRagdollAngularFactor' has a wrong offset!");
static_assert(offsetof(UEquipmentSystemComponent, DeathEquipmentRagdollTranslationalFactor) == 0x0000EC, "Member 'UEquipmentSystemComponent::DeathEquipmentRagdollTranslationalFactor' has a wrong offset!");

// Class Mordhau.BlockPlayer
// 0x0088 (0x00B8 - 0x0030)
class UBlockPlayer final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayFabPlayer                         Player;                                            // 0x0058(0x0060)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UBlockPlayer* BlockPlayer(class UObject* WorldContextObject, const struct FPlayFabPlayer& Player_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockPlayer">();
	}
	static class UBlockPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockPlayer>();
	}
};
static_assert(alignof(UBlockPlayer) == 0x000008, "Wrong alignment on UBlockPlayer");
static_assert(sizeof(UBlockPlayer) == 0x0000B8, "Wrong size on UBlockPlayer");
static_assert(offsetof(UBlockPlayer, onSuccess) == 0x000030, "Member 'UBlockPlayer::onSuccess' has a wrong offset!");
static_assert(offsetof(UBlockPlayer, onFailure) == 0x000040, "Member 'UBlockPlayer::onFailure' has a wrong offset!");
static_assert(offsetof(UBlockPlayer, World) == 0x000050, "Member 'UBlockPlayer::World' has a wrong offset!");
static_assert(offsetof(UBlockPlayer, Player) == 0x000058, "Member 'UBlockPlayer::Player' has a wrong offset!");

// Class Mordhau.FaceCustomizationComponent
// 0x01A8 (0x0258 - 0x00B0)
class UFaceCustomizationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      BoneToParentGroupIdx;                              // 0x00B8(0x0050)(NativeAccessSpecifierPublic)
	TMap<int32, int32>                            BoneIdxToSculptableFaceBoneIdx;                    // 0x0108(0x0050)(NativeAccessSpecifierPublic)
	TMap<int32, int32>                            SelectionBoneIdxToSculptableFaceBoneIdx;           // 0x0158(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      BoneNameToSculptableFaceBoneIdx;                   // 0x01A8(0x0050)(NativeAccessSpecifierPublic)
	TArray<int32>                                 BakedDefaultFaceValuesTranslate;                   // 0x01F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BakedDefaultFaceValuesRotate;                      // 0x0208(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BakedDefaultFaceValuesScale;                       // 0x0218(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         HideEarsAmount;                                    // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideNoseAmount;                                    // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegenerateBakedDefaultFaceValues;                 // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasScaryFace;                                     // 0x0231(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232[0x2];                                      // 0x0232(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ScaryFaceRotationMultipliers;                      // 0x0234(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScaryFaceTranslationMultipliers;                   // 0x0240(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScaryFaceScaleMultipliers;                         // 0x024C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnCharacterBuilt(class AMordhauCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FaceCustomizationComponent">();
	}
	static class UFaceCustomizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFaceCustomizationComponent>();
	}
};
static_assert(alignof(UFaceCustomizationComponent) == 0x000008, "Wrong alignment on UFaceCustomizationComponent");
static_assert(sizeof(UFaceCustomizationComponent) == 0x000258, "Wrong size on UFaceCustomizationComponent");
static_assert(offsetof(UFaceCustomizationComponent, BoneToParentGroupIdx) == 0x0000B8, "Member 'UFaceCustomizationComponent::BoneToParentGroupIdx' has a wrong offset!");
static_assert(offsetof(UFaceCustomizationComponent, BoneIdxToSculptableFaceBoneIdx) == 0x000108, "Member 'UFaceCustomizationComponent::BoneIdxToSculptableFaceBoneIdx' has a wrong offset!");
static_assert(offsetof(UFaceCustomizationComponent, SelectionBoneIdxToSculptableFaceBoneIdx) == 0x000158, "Member 'UFaceCustomizationComponent::SelectionBoneIdxToSculptableFaceBoneIdx' has a wrong offset!");
static_assert(offsetof(UFaceCustomizationComponent, BoneNameToSculptableFaceBoneIdx) == 0x0001A8, "Member 'UFaceCustomizationComponent::BoneNameToSculptableFaceBoneIdx' has a wrong offset!");
static_assert(offsetof(UFaceCustomizationComponent, BakedDefaultFaceValuesTranslate) == 0x0001F8, "Member 'UFaceCustomizationComponent::BakedDefaultFaceValuesTranslate' has a wrong offset!");
static_assert(offsetof(UFaceCustomizationComponent, BakedDefaultFaceValuesRotate) == 0x000208, "Member 'UFaceCustomizationComponent::BakedDefaultFaceValuesRotate' has a wrong offset!");
static_assert(offsetof(UFaceCustomizationComponent, BakedDefaultFaceValuesScale) == 0x000218, "Member 'UFaceCustomizationComponent::BakedDefaultFaceValuesScale' has a wrong offset!");
static_assert(offsetof(UFaceCustomizationComponent, HideEarsAmount) == 0x000228, "Member 'UFaceCustomizationComponent::HideEarsAmount' has a wrong offset!");
static_assert(offsetof(UFaceCustomizationComponent, HideNoseAmount) == 0x00022C, "Member 'UFaceCustomizationComponent::HideNoseAmount' has a wrong offset!");
static_assert(offsetof(UFaceCustomizationComponent, bRegenerateBakedDefaultFaceValues) == 0x000230, "Member 'UFaceCustomizationComponent::bRegenerateBakedDefaultFaceValues' has a wrong offset!");
static_assert(offsetof(UFaceCustomizationComponent, bHasScaryFace) == 0x000231, "Member 'UFaceCustomizationComponent::bHasScaryFace' has a wrong offset!");
static_assert(offsetof(UFaceCustomizationComponent, ScaryFaceRotationMultipliers) == 0x000234, "Member 'UFaceCustomizationComponent::ScaryFaceRotationMultipliers' has a wrong offset!");
static_assert(offsetof(UFaceCustomizationComponent, ScaryFaceTranslationMultipliers) == 0x000240, "Member 'UFaceCustomizationComponent::ScaryFaceTranslationMultipliers' has a wrong offset!");
static_assert(offsetof(UFaceCustomizationComponent, ScaryFaceScaleMultipliers) == 0x00024C, "Member 'UFaceCustomizationComponent::ScaryFaceScaleMultipliers' has a wrong offset!");

// Class Mordhau.FeintedMotion
// 0x0048 (0x00E8 - 0x00A0)
class UFeintedMotion : public UMordhauMotion
{
public:
	float                                         SpineSpaceAdditiveBlendOutTime;                    // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QueueWindow;                                       // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowKickDuration;                                  // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StrikeAndStabLockoutIn;                            // 0x00AC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StrikeAndStabLockoutOut;                           // 0x00B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StrikeAndStabLateFeintAdjustmentCurve;             // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraStabLockout;                                  // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraStrikeLockout;                                // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0xC];                                       // 0x00D0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EFeintType                                    Type;                                              // 0x00DC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackMove                                   FromMove;                                          // 0x00DD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasQueuedMove;                                    // 0x00DE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackMove                                   QueuedMove;                                        // 0x00DF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QueuedAngle;                                       // 0x00E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FeintedMotion">();
	}
	static class UFeintedMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFeintedMotion>();
	}
};
static_assert(alignof(UFeintedMotion) == 0x000008, "Wrong alignment on UFeintedMotion");
static_assert(sizeof(UFeintedMotion) == 0x0000E8, "Wrong size on UFeintedMotion");
static_assert(offsetof(UFeintedMotion, SpineSpaceAdditiveBlendOutTime) == 0x0000A0, "Member 'UFeintedMotion::SpineSpaceAdditiveBlendOutTime' has a wrong offset!");
static_assert(offsetof(UFeintedMotion, QueueWindow) == 0x0000A4, "Member 'UFeintedMotion::QueueWindow' has a wrong offset!");
static_assert(offsetof(UFeintedMotion, SlowKickDuration) == 0x0000A8, "Member 'UFeintedMotion::SlowKickDuration' has a wrong offset!");
static_assert(offsetof(UFeintedMotion, StrikeAndStabLockoutIn) == 0x0000AC, "Member 'UFeintedMotion::StrikeAndStabLockoutIn' has a wrong offset!");
static_assert(offsetof(UFeintedMotion, StrikeAndStabLockoutOut) == 0x0000B4, "Member 'UFeintedMotion::StrikeAndStabLockoutOut' has a wrong offset!");
static_assert(offsetof(UFeintedMotion, StrikeAndStabLateFeintAdjustmentCurve) == 0x0000C0, "Member 'UFeintedMotion::StrikeAndStabLateFeintAdjustmentCurve' has a wrong offset!");
static_assert(offsetof(UFeintedMotion, ExtraStabLockout) == 0x0000C8, "Member 'UFeintedMotion::ExtraStabLockout' has a wrong offset!");
static_assert(offsetof(UFeintedMotion, ExtraStrikeLockout) == 0x0000CC, "Member 'UFeintedMotion::ExtraStrikeLockout' has a wrong offset!");
static_assert(offsetof(UFeintedMotion, Type) == 0x0000DC, "Member 'UFeintedMotion::Type' has a wrong offset!");
static_assert(offsetof(UFeintedMotion, FromMove) == 0x0000DD, "Member 'UFeintedMotion::FromMove' has a wrong offset!");
static_assert(offsetof(UFeintedMotion, bHasQueuedMove) == 0x0000DE, "Member 'UFeintedMotion::bHasQueuedMove' has a wrong offset!");
static_assert(offsetof(UFeintedMotion, QueuedMove) == 0x0000DF, "Member 'UFeintedMotion::QueuedMove' has a wrong offset!");
static_assert(offsetof(UFeintedMotion, QueuedAngle) == 0x0000E0, "Member 'UFeintedMotion::QueuedAngle' has a wrong offset!");

// Class Mordhau.ManageMatchCommand
// 0x0000 (0x0080 - 0x0080)
class UManageMatchCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManageMatchCommand">();
	}
	static class UManageMatchCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UManageMatchCommand>();
	}
};
static_assert(alignof(UManageMatchCommand) == 0x000008, "Wrong alignment on UManageMatchCommand");
static_assert(sizeof(UManageMatchCommand) == 0x000080, "Wrong size on UManageMatchCommand");

// Class Mordhau.FieldSpawnComponent
// 0x0020 (0x0220 - 0x0200)
class UFieldSpawnComponent final : public USceneComponent
{
public:
	TSubclassOf<class ASubField>                  SubFieldClass;                                     // 0x01F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapLocationToGround;                             // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapLocationToGroundDestroyIfNoGround;            // 0x0201(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapRotationToGroundNormal;                       // 0x0202(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_203[0x1];                                      // 0x0203(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAllowedRotation;                                // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapGroundTraceOffsetZ;                            // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapGroundRadius;                                  // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceSnapGround;                             // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCheckLineOfSight;                           // 0x0214(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215[0x3];                                      // 0x0215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineOfSightRadiusCheck;                            // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FieldSpawnComponent">();
	}
	static class UFieldSpawnComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFieldSpawnComponent>();
	}
};
static_assert(alignof(UFieldSpawnComponent) == 0x000010, "Wrong alignment on UFieldSpawnComponent");
static_assert(sizeof(UFieldSpawnComponent) == 0x000220, "Wrong size on UFieldSpawnComponent");
static_assert(offsetof(UFieldSpawnComponent, SubFieldClass) == 0x0001F8, "Member 'UFieldSpawnComponent::SubFieldClass' has a wrong offset!");
static_assert(offsetof(UFieldSpawnComponent, bSnapLocationToGround) == 0x000200, "Member 'UFieldSpawnComponent::bSnapLocationToGround' has a wrong offset!");
static_assert(offsetof(UFieldSpawnComponent, bSnapLocationToGroundDestroyIfNoGround) == 0x000201, "Member 'UFieldSpawnComponent::bSnapLocationToGroundDestroyIfNoGround' has a wrong offset!");
static_assert(offsetof(UFieldSpawnComponent, bSnapRotationToGroundNormal) == 0x000202, "Member 'UFieldSpawnComponent::bSnapRotationToGroundNormal' has a wrong offset!");
static_assert(offsetof(UFieldSpawnComponent, MaxAllowedRotation) == 0x000204, "Member 'UFieldSpawnComponent::MaxAllowedRotation' has a wrong offset!");
static_assert(offsetof(UFieldSpawnComponent, SnapGroundTraceOffsetZ) == 0x000208, "Member 'UFieldSpawnComponent::SnapGroundTraceOffsetZ' has a wrong offset!");
static_assert(offsetof(UFieldSpawnComponent, SnapGroundRadius) == 0x00020C, "Member 'UFieldSpawnComponent::SnapGroundRadius' has a wrong offset!");
static_assert(offsetof(UFieldSpawnComponent, MaxDistanceSnapGround) == 0x000210, "Member 'UFieldSpawnComponent::MaxDistanceSnapGround' has a wrong offset!");
static_assert(offsetof(UFieldSpawnComponent, bShouldCheckLineOfSight) == 0x000214, "Member 'UFieldSpawnComponent::bShouldCheckLineOfSight' has a wrong offset!");
static_assert(offsetof(UFieldSpawnComponent, LineOfSightRadiusCheck) == 0x000218, "Member 'UFieldSpawnComponent::LineOfSightRadiusCheck' has a wrong offset!");

// Class Mordhau.AcceptFriendRequest
// 0x0088 (0x00B8 - 0x0030)
class UAcceptFriendRequest final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayFabPlayer                         Player;                                            // 0x0058(0x0060)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UAcceptFriendRequest* AcceptFriendRequest(class UObject* WorldContextObject, const struct FPlayFabPlayer& Player_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AcceptFriendRequest">();
	}
	static class UAcceptFriendRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAcceptFriendRequest>();
	}
};
static_assert(alignof(UAcceptFriendRequest) == 0x000008, "Wrong alignment on UAcceptFriendRequest");
static_assert(sizeof(UAcceptFriendRequest) == 0x0000B8, "Wrong size on UAcceptFriendRequest");
static_assert(offsetof(UAcceptFriendRequest, onSuccess) == 0x000030, "Member 'UAcceptFriendRequest::onSuccess' has a wrong offset!");
static_assert(offsetof(UAcceptFriendRequest, onFailure) == 0x000040, "Member 'UAcceptFriendRequest::onFailure' has a wrong offset!");
static_assert(offsetof(UAcceptFriendRequest, World) == 0x000050, "Member 'UAcceptFriendRequest::World' has a wrong offset!");
static_assert(offsetof(UAcceptFriendRequest, Player) == 0x000058, "Member 'UAcceptFriendRequest::Player' has a wrong offset!");

// Class Mordhau.MordhauCapsuleComponent
// 0x0010 (0x0470 - 0x0460)
class UMordhauCapsuleComponent final : public UCapsuleComponent
{
public:
	uint8                                         Pad_460[0x10];                                     // 0x0460(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauCapsuleComponent">();
	}
	static class UMordhauCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauCapsuleComponent>();
	}
};
static_assert(alignof(UMordhauCapsuleComponent) == 0x000010, "Wrong alignment on UMordhauCapsuleComponent");
static_assert(sizeof(UMordhauCapsuleComponent) == 0x000470, "Wrong size on UMordhauCapsuleComponent");

// Class Mordhau.FistsWeapon
// 0x0000 (0x1C90 - 0x1C90)
class AFistsWeapon : public AVirtualWeapon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FistsWeapon">();
	}
	static class AFistsWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFistsWeapon>();
	}
};
static_assert(alignof(AFistsWeapon) == 0x000010, "Wrong alignment on AFistsWeapon");
static_assert(sizeof(AFistsWeapon) == 0x001C90, "Wrong size on AFistsWeapon");

// Class Mordhau.FlinchMotion
// 0x0020 (0x00C0 - 0x00A0)
class UFlinchMotion : public UMordhauMotion
{
public:
	bool                                          bHasDoneFlinchEffect;                              // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlinchDuration;                                    // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParryLockOutTime;                                  // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FlinchDurationModifierToShakeScaleIn;              // 0x00AC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FlinchDurationModifierToShakeScaleOut;             // 0x00B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlinchMotion">();
	}
	static class UFlinchMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlinchMotion>();
	}
};
static_assert(alignof(UFlinchMotion) == 0x000008, "Wrong alignment on UFlinchMotion");
static_assert(sizeof(UFlinchMotion) == 0x0000C0, "Wrong size on UFlinchMotion");
static_assert(offsetof(UFlinchMotion, bHasDoneFlinchEffect) == 0x0000A0, "Member 'UFlinchMotion::bHasDoneFlinchEffect' has a wrong offset!");
static_assert(offsetof(UFlinchMotion, FlinchDuration) == 0x0000A4, "Member 'UFlinchMotion::FlinchDuration' has a wrong offset!");
static_assert(offsetof(UFlinchMotion, ParryLockOutTime) == 0x0000A8, "Member 'UFlinchMotion::ParryLockOutTime' has a wrong offset!");
static_assert(offsetof(UFlinchMotion, FlinchDurationModifierToShakeScaleIn) == 0x0000AC, "Member 'UFlinchMotion::FlinchDurationModifierToShakeScaleIn' has a wrong offset!");
static_assert(offsetof(UFlinchMotion, FlinchDurationModifierToShakeScaleOut) == 0x0000B4, "Member 'UFlinchMotion::FlinchDurationModifierToShakeScaleOut' has a wrong offset!");

// Class Mordhau.GameModeMetadata
// 0x00B8 (0x00E0 - 0x0028)
class UGameModeMetadata : public UObject
{
public:
	class FString                                 Prefix;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name_0;                                            // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 QueueName;                                         // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Thumbnail;                                         // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           Tips;                                              // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EServerRegion, struct FPlayerCountArray> PlayerCount;                                       // 0x0090(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UGameModeMetadata* GetDefaultObject(TSubclassOf<class UGameModeMetadata> MetadataClass);

	TArray<int32> GetPlayerCount(EServerRegion ServerRegion);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeMetadata">();
	}
	static class UGameModeMetadata* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameModeMetadata>();
	}
};
static_assert(alignof(UGameModeMetadata) == 0x000008, "Wrong alignment on UGameModeMetadata");
static_assert(sizeof(UGameModeMetadata) == 0x0000E0, "Wrong size on UGameModeMetadata");
static_assert(offsetof(UGameModeMetadata, Prefix) == 0x000028, "Member 'UGameModeMetadata::Prefix' has a wrong offset!");
static_assert(offsetof(UGameModeMetadata, Name_0) == 0x000038, "Member 'UGameModeMetadata::Name_0' has a wrong offset!");
static_assert(offsetof(UGameModeMetadata, Description) == 0x000050, "Member 'UGameModeMetadata::Description' has a wrong offset!");
static_assert(offsetof(UGameModeMetadata, QueueName) == 0x000068, "Member 'UGameModeMetadata::QueueName' has a wrong offset!");
static_assert(offsetof(UGameModeMetadata, Thumbnail) == 0x000078, "Member 'UGameModeMetadata::Thumbnail' has a wrong offset!");
static_assert(offsetof(UGameModeMetadata, Tips) == 0x000080, "Member 'UGameModeMetadata::Tips' has a wrong offset!");
static_assert(offsetof(UGameModeMetadata, PlayerCount) == 0x000090, "Member 'UGameModeMetadata::PlayerCount' has a wrong offset!");

// Class Mordhau.CreateMatchmakingTicket
// 0x00B8 (0x00E8 - 0x0030)
class UCreateMatchmakingTicket final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const class FString& QueueName, const class FString& TicketId)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& QueueName, const class FString& TicketId)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QueueName;                                         // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayFabMatchmakingAttributes          Attributes;                                        // 0x0068(0x0068)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         Members;                                           // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         Timeout;                                           // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCreateMatchmakingTicket* CreateMatchmakingTicket(const class FString& QueueName_0, const struct FPlayFabMatchmakingAttributes& Attributes_0, const TArray<class FString>& Members_0, int32 Timeout_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreateMatchmakingTicket">();
	}
	static class UCreateMatchmakingTicket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCreateMatchmakingTicket>();
	}
};
static_assert(alignof(UCreateMatchmakingTicket) == 0x000008, "Wrong alignment on UCreateMatchmakingTicket");
static_assert(sizeof(UCreateMatchmakingTicket) == 0x0000E8, "Wrong size on UCreateMatchmakingTicket");
static_assert(offsetof(UCreateMatchmakingTicket, onSuccess) == 0x000030, "Member 'UCreateMatchmakingTicket::onSuccess' has a wrong offset!");
static_assert(offsetof(UCreateMatchmakingTicket, onFailure) == 0x000040, "Member 'UCreateMatchmakingTicket::onFailure' has a wrong offset!");
static_assert(offsetof(UCreateMatchmakingTicket, QueueName) == 0x000058, "Member 'UCreateMatchmakingTicket::QueueName' has a wrong offset!");
static_assert(offsetof(UCreateMatchmakingTicket, Attributes) == 0x000068, "Member 'UCreateMatchmakingTicket::Attributes' has a wrong offset!");
static_assert(offsetof(UCreateMatchmakingTicket, Members) == 0x0000D0, "Member 'UCreateMatchmakingTicket::Members' has a wrong offset!");
static_assert(offsetof(UCreateMatchmakingTicket, Timeout) == 0x0000E0, "Member 'UCreateMatchmakingTicket::Timeout' has a wrong offset!");

// Class Mordhau.GoreActor
// 0x0010 (0x0230 - 0x0220)
class AGoreActor : public AActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GoreActor">();
	}
	static class AGoreActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGoreActor>();
	}
};
static_assert(alignof(AGoreActor) == 0x000008, "Wrong alignment on AGoreActor");
static_assert(sizeof(AGoreActor) == 0x000230, "Wrong size on AGoreActor");
static_assert(offsetof(AGoreActor, StaticMeshComponent) == 0x000220, "Member 'AGoreActor::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGoreActor, ParticleSystemComponent) == 0x000228, "Member 'AGoreActor::ParticleSystemComponent' has a wrong offset!");

// Class Mordhau.HeadWearable
// 0x0028 (0x0250 - 0x0228)
class UHeadWearable : public UMordhauWearable
{
public:
	uint8                                         DefaultCoif;                                       // 0x0228(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           CoifWearables;                                     // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         HelmetAOOffset;                                    // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HelmetAOPower;                                     // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HelmetAOIntensity;                                 // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HelmetAOEyeIntensity;                              // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddCoifWearable(TSoftClassPtr<class UClass> Wearable);
	TSubclassOf<class UMordhauWearable> GetCoifWearable(int32 Index_0);

	int32 GetCoifWearablesNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadWearable">();
	}
	static class UHeadWearable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadWearable>();
	}
};
static_assert(alignof(UHeadWearable) == 0x000008, "Wrong alignment on UHeadWearable");
static_assert(sizeof(UHeadWearable) == 0x000250, "Wrong size on UHeadWearable");
static_assert(offsetof(UHeadWearable, DefaultCoif) == 0x000228, "Member 'UHeadWearable::DefaultCoif' has a wrong offset!");
static_assert(offsetof(UHeadWearable, CoifWearables) == 0x000230, "Member 'UHeadWearable::CoifWearables' has a wrong offset!");
static_assert(offsetof(UHeadWearable, HelmetAOOffset) == 0x000240, "Member 'UHeadWearable::HelmetAOOffset' has a wrong offset!");
static_assert(offsetof(UHeadWearable, HelmetAOPower) == 0x000244, "Member 'UHeadWearable::HelmetAOPower' has a wrong offset!");
static_assert(offsetof(UHeadWearable, HelmetAOIntensity) == 0x000248, "Member 'UHeadWearable::HelmetAOIntensity' has a wrong offset!");
static_assert(offsetof(UHeadWearable, HelmetAOEyeIntensity) == 0x00024C, "Member 'UHeadWearable::HelmetAOEyeIntensity' has a wrong offset!");

// Class Mordhau.ParryMotion
// 0x04D0 (0x0570 - 0x00A0)
class UParryMotion : public UMordhauMotion
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UMordhauMotion*, float>            BlockedAttacks;                                    // 0x00A8(0x0050)(NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauCharacter>       LastBlockedCharacter;                              // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnglingSpineSpaceAdditive             AngleAdditive;                                     // 0x0100(0x0318)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveAnimMontage                Animation;                                         // 0x0418(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveAnimMontage                AltAnimation;                                      // 0x0428(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveBlendSpaceBase             AnimationAdditive;                                 // 0x0438(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveBlendSpaceBase             ParriedAdditive;                                   // 0x0448(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPerspectiveBlendSpaceBase             AltParriedAdditive;                                // 0x0458(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bLegacyAnimationPlayingMethod;                     // 0x0468(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetectedAnyNonFriendlyAttack;                     // 0x0469(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShieldWall;                                     // 0x046A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMissParry;                                      // 0x046B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChamberFTPExtraStaminaDrain;                       // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiveMissParryIfFlinchedBeforeDuration;             // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissParryRecoveryTime;                             // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldWallRaiseTime;                               // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldWallRaiseTimeAnimOffset;                     // 0x047C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxParryAngle;                                     // 0x0480(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxParryWeaponAngle;                               // 0x0484(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeldBlockMemoryDuration;                           // 0x0488(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimedBlockMemoryDuration;                          // 0x048C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParryInFlinchDurationMax;                          // 0x0490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EasyParryDuration;                                 // 0x0494(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EasyParryStaminaCost;                              // 0x0498(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeldRiposteWindowExtra;                            // 0x049C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonHeldParryExtensionAndRiposteWindowExtra;        // 0x04A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementRestriction                          SuccessfulParryRecoveryMovementRestriction;        // 0x04A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementRestriction                          FailedParryRecoveryMovementRestriction;            // 0x04A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A6[0x2];                                      // 0x04A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeleeWeaponAnimationProfile*           MWAP;                                              // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B0[0x4];                                      // 0x04B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RiposteWindowBase;                                 // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParryMissFadeOut;                                  // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParryMissFadeOut1P;                                // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ParryMissLocalSoundCue;                            // 0x04C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParryFailPlayRate;                                 // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParryFailFadeOut;                                  // 0x04CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParryFailPlayRate1P;                               // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParryFailFadeOut1P;                                // 0x04D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeldParryFailPlayRate;                             // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeldParryFailFadeOut;                              // 0x04DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeldParryFailPlayRate1P;                           // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeldParryFailFadeOut1P;                            // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldWallPlayRate;                                // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldWallFadeOut;                                 // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldWallPlayRate1P;                              // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldWallFadeOut1P;                               // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumHeldParryTime;                              // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumHeldRiposteParryTime;                       // 0x04FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParryRecoveryTime;                                 // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeldParryRecoveryTime;                             // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldWallRecoveryTime;                            // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParrySuccessRecoveryTime;                          // 0x050C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeldParrySuccessRecoveryTime;                      // 0x0510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParryUpTime;                                       // 0x0514(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockStaminaRecover;                               // 0x0518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldWallStaminaDrainFactor;                      // 0x051C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShieldWallSpeedFactor;                             // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunInHeldRecoveryWindow;                          // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_528[0x10];                                     // 0x0528(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         TotalBlocks;                                       // 0x0538(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBlockHoldable;                                  // 0x0539(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParryStage                                   Stage;                                             // 0x053A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53B[0x1];                                      // 0x053B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ParryEnd;                                          // 0x053C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_540[0x4];                                      // 0x0540(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RiposteWindowStart;                                // 0x0544(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0548(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauWeapon>          WeaponPtr;                                         // 0x0550(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasQueuedMove;                                    // 0x0558(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_559[0x3];                                      // 0x0559(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QueuedMoveTime;                                    // 0x055C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QueuedAngle;                                       // 0x0560(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackMove                                   QueuedMove;                                        // 0x0564(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_565[0xB];                                      // 0x0565(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParryMotion">();
	}
	static class UParryMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParryMotion>();
	}
};
static_assert(alignof(UParryMotion) == 0x000008, "Wrong alignment on UParryMotion");
static_assert(sizeof(UParryMotion) == 0x000570, "Wrong size on UParryMotion");
static_assert(offsetof(UParryMotion, BlockedAttacks) == 0x0000A8, "Member 'UParryMotion::BlockedAttacks' has a wrong offset!");
static_assert(offsetof(UParryMotion, LastBlockedCharacter) == 0x0000F8, "Member 'UParryMotion::LastBlockedCharacter' has a wrong offset!");
static_assert(offsetof(UParryMotion, AngleAdditive) == 0x000100, "Member 'UParryMotion::AngleAdditive' has a wrong offset!");
static_assert(offsetof(UParryMotion, Animation) == 0x000418, "Member 'UParryMotion::Animation' has a wrong offset!");
static_assert(offsetof(UParryMotion, AltAnimation) == 0x000428, "Member 'UParryMotion::AltAnimation' has a wrong offset!");
static_assert(offsetof(UParryMotion, AnimationAdditive) == 0x000438, "Member 'UParryMotion::AnimationAdditive' has a wrong offset!");
static_assert(offsetof(UParryMotion, ParriedAdditive) == 0x000448, "Member 'UParryMotion::ParriedAdditive' has a wrong offset!");
static_assert(offsetof(UParryMotion, AltParriedAdditive) == 0x000458, "Member 'UParryMotion::AltParriedAdditive' has a wrong offset!");
static_assert(offsetof(UParryMotion, bLegacyAnimationPlayingMethod) == 0x000468, "Member 'UParryMotion::bLegacyAnimationPlayingMethod' has a wrong offset!");
static_assert(offsetof(UParryMotion, bDetectedAnyNonFriendlyAttack) == 0x000469, "Member 'UParryMotion::bDetectedAnyNonFriendlyAttack' has a wrong offset!");
static_assert(offsetof(UParryMotion, bIsShieldWall) == 0x00046A, "Member 'UParryMotion::bIsShieldWall' has a wrong offset!");
static_assert(offsetof(UParryMotion, bIsMissParry) == 0x00046B, "Member 'UParryMotion::bIsMissParry' has a wrong offset!");
static_assert(offsetof(UParryMotion, ChamberFTPExtraStaminaDrain) == 0x00046C, "Member 'UParryMotion::ChamberFTPExtraStaminaDrain' has a wrong offset!");
static_assert(offsetof(UParryMotion, GiveMissParryIfFlinchedBeforeDuration) == 0x000470, "Member 'UParryMotion::GiveMissParryIfFlinchedBeforeDuration' has a wrong offset!");
static_assert(offsetof(UParryMotion, MissParryRecoveryTime) == 0x000474, "Member 'UParryMotion::MissParryRecoveryTime' has a wrong offset!");
static_assert(offsetof(UParryMotion, ShieldWallRaiseTime) == 0x000478, "Member 'UParryMotion::ShieldWallRaiseTime' has a wrong offset!");
static_assert(offsetof(UParryMotion, ShieldWallRaiseTimeAnimOffset) == 0x00047C, "Member 'UParryMotion::ShieldWallRaiseTimeAnimOffset' has a wrong offset!");
static_assert(offsetof(UParryMotion, MaxParryAngle) == 0x000480, "Member 'UParryMotion::MaxParryAngle' has a wrong offset!");
static_assert(offsetof(UParryMotion, MaxParryWeaponAngle) == 0x000484, "Member 'UParryMotion::MaxParryWeaponAngle' has a wrong offset!");
static_assert(offsetof(UParryMotion, HeldBlockMemoryDuration) == 0x000488, "Member 'UParryMotion::HeldBlockMemoryDuration' has a wrong offset!");
static_assert(offsetof(UParryMotion, TimedBlockMemoryDuration) == 0x00048C, "Member 'UParryMotion::TimedBlockMemoryDuration' has a wrong offset!");
static_assert(offsetof(UParryMotion, ParryInFlinchDurationMax) == 0x000490, "Member 'UParryMotion::ParryInFlinchDurationMax' has a wrong offset!");
static_assert(offsetof(UParryMotion, EasyParryDuration) == 0x000494, "Member 'UParryMotion::EasyParryDuration' has a wrong offset!");
static_assert(offsetof(UParryMotion, EasyParryStaminaCost) == 0x000498, "Member 'UParryMotion::EasyParryStaminaCost' has a wrong offset!");
static_assert(offsetof(UParryMotion, HeldRiposteWindowExtra) == 0x00049C, "Member 'UParryMotion::HeldRiposteWindowExtra' has a wrong offset!");
static_assert(offsetof(UParryMotion, NonHeldParryExtensionAndRiposteWindowExtra) == 0x0004A0, "Member 'UParryMotion::NonHeldParryExtensionAndRiposteWindowExtra' has a wrong offset!");
static_assert(offsetof(UParryMotion, SuccessfulParryRecoveryMovementRestriction) == 0x0004A4, "Member 'UParryMotion::SuccessfulParryRecoveryMovementRestriction' has a wrong offset!");
static_assert(offsetof(UParryMotion, FailedParryRecoveryMovementRestriction) == 0x0004A5, "Member 'UParryMotion::FailedParryRecoveryMovementRestriction' has a wrong offset!");
static_assert(offsetof(UParryMotion, MWAP) == 0x0004A8, "Member 'UParryMotion::MWAP' has a wrong offset!");
static_assert(offsetof(UParryMotion, RiposteWindowBase) == 0x0004B4, "Member 'UParryMotion::RiposteWindowBase' has a wrong offset!");
static_assert(offsetof(UParryMotion, ParryMissFadeOut) == 0x0004B8, "Member 'UParryMotion::ParryMissFadeOut' has a wrong offset!");
static_assert(offsetof(UParryMotion, ParryMissFadeOut1P) == 0x0004BC, "Member 'UParryMotion::ParryMissFadeOut1P' has a wrong offset!");
static_assert(offsetof(UParryMotion, ParryMissLocalSoundCue) == 0x0004C0, "Member 'UParryMotion::ParryMissLocalSoundCue' has a wrong offset!");
static_assert(offsetof(UParryMotion, ParryFailPlayRate) == 0x0004C8, "Member 'UParryMotion::ParryFailPlayRate' has a wrong offset!");
static_assert(offsetof(UParryMotion, ParryFailFadeOut) == 0x0004CC, "Member 'UParryMotion::ParryFailFadeOut' has a wrong offset!");
static_assert(offsetof(UParryMotion, ParryFailPlayRate1P) == 0x0004D0, "Member 'UParryMotion::ParryFailPlayRate1P' has a wrong offset!");
static_assert(offsetof(UParryMotion, ParryFailFadeOut1P) == 0x0004D4, "Member 'UParryMotion::ParryFailFadeOut1P' has a wrong offset!");
static_assert(offsetof(UParryMotion, HeldParryFailPlayRate) == 0x0004D8, "Member 'UParryMotion::HeldParryFailPlayRate' has a wrong offset!");
static_assert(offsetof(UParryMotion, HeldParryFailFadeOut) == 0x0004DC, "Member 'UParryMotion::HeldParryFailFadeOut' has a wrong offset!");
static_assert(offsetof(UParryMotion, HeldParryFailPlayRate1P) == 0x0004E0, "Member 'UParryMotion::HeldParryFailPlayRate1P' has a wrong offset!");
static_assert(offsetof(UParryMotion, HeldParryFailFadeOut1P) == 0x0004E4, "Member 'UParryMotion::HeldParryFailFadeOut1P' has a wrong offset!");
static_assert(offsetof(UParryMotion, ShieldWallPlayRate) == 0x0004E8, "Member 'UParryMotion::ShieldWallPlayRate' has a wrong offset!");
static_assert(offsetof(UParryMotion, ShieldWallFadeOut) == 0x0004EC, "Member 'UParryMotion::ShieldWallFadeOut' has a wrong offset!");
static_assert(offsetof(UParryMotion, ShieldWallPlayRate1P) == 0x0004F0, "Member 'UParryMotion::ShieldWallPlayRate1P' has a wrong offset!");
static_assert(offsetof(UParryMotion, ShieldWallFadeOut1P) == 0x0004F4, "Member 'UParryMotion::ShieldWallFadeOut1P' has a wrong offset!");
static_assert(offsetof(UParryMotion, MinimumHeldParryTime) == 0x0004F8, "Member 'UParryMotion::MinimumHeldParryTime' has a wrong offset!");
static_assert(offsetof(UParryMotion, MinimumHeldRiposteParryTime) == 0x0004FC, "Member 'UParryMotion::MinimumHeldRiposteParryTime' has a wrong offset!");
static_assert(offsetof(UParryMotion, ParryRecoveryTime) == 0x000500, "Member 'UParryMotion::ParryRecoveryTime' has a wrong offset!");
static_assert(offsetof(UParryMotion, HeldParryRecoveryTime) == 0x000504, "Member 'UParryMotion::HeldParryRecoveryTime' has a wrong offset!");
static_assert(offsetof(UParryMotion, ShieldWallRecoveryTime) == 0x000508, "Member 'UParryMotion::ShieldWallRecoveryTime' has a wrong offset!");
static_assert(offsetof(UParryMotion, ParrySuccessRecoveryTime) == 0x00050C, "Member 'UParryMotion::ParrySuccessRecoveryTime' has a wrong offset!");
static_assert(offsetof(UParryMotion, HeldParrySuccessRecoveryTime) == 0x000510, "Member 'UParryMotion::HeldParrySuccessRecoveryTime' has a wrong offset!");
static_assert(offsetof(UParryMotion, ParryUpTime) == 0x000514, "Member 'UParryMotion::ParryUpTime' has a wrong offset!");
static_assert(offsetof(UParryMotion, BlockStaminaRecover) == 0x000518, "Member 'UParryMotion::BlockStaminaRecover' has a wrong offset!");
static_assert(offsetof(UParryMotion, ShieldWallStaminaDrainFactor) == 0x00051C, "Member 'UParryMotion::ShieldWallStaminaDrainFactor' has a wrong offset!");
static_assert(offsetof(UParryMotion, ShieldWallSpeedFactor) == 0x000520, "Member 'UParryMotion::ShieldWallSpeedFactor' has a wrong offset!");
static_assert(offsetof(UParryMotion, StunInHeldRecoveryWindow) == 0x000524, "Member 'UParryMotion::StunInHeldRecoveryWindow' has a wrong offset!");
static_assert(offsetof(UParryMotion, TotalBlocks) == 0x000538, "Member 'UParryMotion::TotalBlocks' has a wrong offset!");
static_assert(offsetof(UParryMotion, bIsBlockHoldable) == 0x000539, "Member 'UParryMotion::bIsBlockHoldable' has a wrong offset!");
static_assert(offsetof(UParryMotion, Stage) == 0x00053A, "Member 'UParryMotion::Stage' has a wrong offset!");
static_assert(offsetof(UParryMotion, ParryEnd) == 0x00053C, "Member 'UParryMotion::ParryEnd' has a wrong offset!");
static_assert(offsetof(UParryMotion, RiposteWindowStart) == 0x000544, "Member 'UParryMotion::RiposteWindowStart' has a wrong offset!");
static_assert(offsetof(UParryMotion, Montage) == 0x000548, "Member 'UParryMotion::Montage' has a wrong offset!");
static_assert(offsetof(UParryMotion, WeaponPtr) == 0x000550, "Member 'UParryMotion::WeaponPtr' has a wrong offset!");
static_assert(offsetof(UParryMotion, bHasQueuedMove) == 0x000558, "Member 'UParryMotion::bHasQueuedMove' has a wrong offset!");
static_assert(offsetof(UParryMotion, QueuedMoveTime) == 0x00055C, "Member 'UParryMotion::QueuedMoveTime' has a wrong offset!");
static_assert(offsetof(UParryMotion, QueuedAngle) == 0x000560, "Member 'UParryMotion::QueuedAngle' has a wrong offset!");
static_assert(offsetof(UParryMotion, QueuedMove) == 0x000564, "Member 'UParryMotion::QueuedMove' has a wrong offset!");

// Class Mordhau.StatComponent
// 0x0028 (0x00D8 - 0x00B0)
class UStatComponent : public UActorComponent
{
public:
	int32                                         StatValue;                                         // 0x00B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialStatValue;                                  // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinStatValue;                                      // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxStatValue;                                      // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRegenerable;                                    // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RegenerationStoppedDelay;                          // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RegenerationPerTick;                               // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RegenerationTickRate;                              // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_StatValue(int32 OldStatValue);
	void TickStat(float DeltaTime);

	int32 GetStatValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatComponent">();
	}
	static class UStatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatComponent>();
	}
};
static_assert(alignof(UStatComponent) == 0x000008, "Wrong alignment on UStatComponent");
static_assert(sizeof(UStatComponent) == 0x0000D8, "Wrong size on UStatComponent");
static_assert(offsetof(UStatComponent, StatValue) == 0x0000B0, "Member 'UStatComponent::StatValue' has a wrong offset!");
static_assert(offsetof(UStatComponent, InitialStatValue) == 0x0000B8, "Member 'UStatComponent::InitialStatValue' has a wrong offset!");
static_assert(offsetof(UStatComponent, MinStatValue) == 0x0000BC, "Member 'UStatComponent::MinStatValue' has a wrong offset!");
static_assert(offsetof(UStatComponent, MaxStatValue) == 0x0000C0, "Member 'UStatComponent::MaxStatValue' has a wrong offset!");
static_assert(offsetof(UStatComponent, bIsRegenerable) == 0x0000C4, "Member 'UStatComponent::bIsRegenerable' has a wrong offset!");
static_assert(offsetof(UStatComponent, RegenerationStoppedDelay) == 0x0000C8, "Member 'UStatComponent::RegenerationStoppedDelay' has a wrong offset!");
static_assert(offsetof(UStatComponent, RegenerationPerTick) == 0x0000CC, "Member 'UStatComponent::RegenerationPerTick' has a wrong offset!");
static_assert(offsetof(UStatComponent, RegenerationTickRate) == 0x0000D0, "Member 'UStatComponent::RegenerationTickRate' has a wrong offset!");

// Class Mordhau.HealthStatComponent
// 0x0030 (0x0108 - 0x00D8)
class UHealthStatComponent final : public UStatComponent
{
public:
	bool                                          bPlaysHeartbeatSound;                              // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              HeartbeatSound;                                    // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeartbeatSoundPlayBelowHealth;                     // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         LastHeartbeat;                                     // 0x00EC(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x14];                                      // 0x00F4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterDied(class AAdvancedCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthStatComponent">();
	}
	static class UHealthStatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthStatComponent>();
	}
};
static_assert(alignof(UHealthStatComponent) == 0x000008, "Wrong alignment on UHealthStatComponent");
static_assert(sizeof(UHealthStatComponent) == 0x000108, "Wrong size on UHealthStatComponent");
static_assert(offsetof(UHealthStatComponent, bPlaysHeartbeatSound) == 0x0000D8, "Member 'UHealthStatComponent::bPlaysHeartbeatSound' has a wrong offset!");
static_assert(offsetof(UHealthStatComponent, HeartbeatSound) == 0x0000E0, "Member 'UHealthStatComponent::HeartbeatSound' has a wrong offset!");
static_assert(offsetof(UHealthStatComponent, HeartbeatSoundPlayBelowHealth) == 0x0000E8, "Member 'UHealthStatComponent::HeartbeatSoundPlayBelowHealth' has a wrong offset!");
static_assert(offsetof(UHealthStatComponent, LastHeartbeat) == 0x0000EC, "Member 'UHealthStatComponent::LastHeartbeat' has a wrong offset!");

// Class Mordhau.HelpCommand
// 0x0000 (0x0080 - 0x0080)
class UHelpCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelpCommand">();
	}
	static class UHelpCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelpCommand>();
	}
};
static_assert(alignof(UHelpCommand) == 0x000008, "Wrong alignment on UHelpCommand");
static_assert(sizeof(UHelpCommand) == 0x000080, "Wrong size on UHelpCommand");

// Class Mordhau.HolsterMotion
// 0x0008 (0x00A8 - 0x00A0)
class UHolsterMotion final : public UMordhauMotion
{
public:
	uint8                                         Mode;                                              // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HolsterMotion">();
	}
	static class UHolsterMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHolsterMotion>();
	}
};
static_assert(alignof(UHolsterMotion) == 0x000008, "Wrong alignment on UHolsterMotion");
static_assert(sizeof(UHolsterMotion) == 0x0000A8, "Wrong size on UHolsterMotion");
static_assert(offsetof(UHolsterMotion, Mode) == 0x0000A0, "Member 'UHolsterMotion::Mode' has a wrong offset!");

// Class Mordhau.MordhauVehicle
// 0x0080 (0x0B90 - 0x0B10)
#pragma pack(push, 0x1)
class alignas(0x10) AMordhauVehicle : public AAdvancedCharacter
{
public:
	TMap<class FString, class FText>              ActionToDescriptionMap;                            // 0x0B08(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bShowVehicleHealth;                                // 0x0B58(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVisualPingCompensationOnAttacks;               // 0x0B59(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5A[0x2];                                      // 0x0B5A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistanceCorrectionForLeaveSpot;                 // 0x0B5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableCameraDistance;                            // 0x0B60(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetLookUpWhenNoDriver;                          // 0x0B61(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B62[0x6];                                      // 0x0B62(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   VehicleName;                                       // 0x0B68(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UMordhauVehicleComponent*               VehicleComponent;                                  // 0x0B80(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void KnockOffDriver(class AMordhauCharacter* Character);
	void RequestUse();

	class AMordhauCharacter* GetDriver() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauVehicle">();
	}
	static class AMordhauVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauVehicle>();
	}
};
#pragma pack(pop)
static_assert(alignof(AMordhauVehicle) == 0x000010, "Wrong alignment on AMordhauVehicle");
static_assert(sizeof(AMordhauVehicle) == 0x000B90, "Wrong size on AMordhauVehicle");
static_assert(offsetof(AMordhauVehicle, ActionToDescriptionMap) == 0x000B08, "Member 'AMordhauVehicle::ActionToDescriptionMap' has a wrong offset!");
static_assert(offsetof(AMordhauVehicle, bShowVehicleHealth) == 0x000B58, "Member 'AMordhauVehicle::bShowVehicleHealth' has a wrong offset!");
static_assert(offsetof(AMordhauVehicle, bUseVisualPingCompensationOnAttacks) == 0x000B59, "Member 'AMordhauVehicle::bUseVisualPingCompensationOnAttacks' has a wrong offset!");
static_assert(offsetof(AMordhauVehicle, MaxDistanceCorrectionForLeaveSpot) == 0x000B5C, "Member 'AMordhauVehicle::MaxDistanceCorrectionForLeaveSpot' has a wrong offset!");
static_assert(offsetof(AMordhauVehicle, bDisableCameraDistance) == 0x000B60, "Member 'AMordhauVehicle::bDisableCameraDistance' has a wrong offset!");
static_assert(offsetof(AMordhauVehicle, bResetLookUpWhenNoDriver) == 0x000B61, "Member 'AMordhauVehicle::bResetLookUpWhenNoDriver' has a wrong offset!");
static_assert(offsetof(AMordhauVehicle, VehicleName) == 0x000B68, "Member 'AMordhauVehicle::VehicleName' has a wrong offset!");
static_assert(offsetof(AMordhauVehicle, VehicleComponent) == 0x000B80, "Member 'AMordhauVehicle::VehicleComponent' has a wrong offset!");

// Class Mordhau.Horse
// 0x00E0 (0x0C70 - 0x0B90)
class AHorse : public AMordhauVehicle
{
public:
	TMap<TWeakObjectPtr<class AActor>, float>     RecentKnockbacks;                                  // 0x0B88(0x0050)(NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      BumpCapsule;                                       // 0x0BD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurdSpawnInterval;                                 // 0x0BE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurdSpawnChance;                                   // 0x0BE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTurdSpawnCheck;                                // 0x0BE8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastFootstepParticlesMinVelocity;                  // 0x0BEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystem*>                FastFootstepParticles;                             // 0x0BF0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class USoundCue*                              SoundTrot;                                         // 0x0C00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SoundCanter;                                       // 0x0C08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SoundGallop;                                       // 0x0C10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BumpDamageBySpeedModifierCurve;                    // 0x0C18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AttackDamageBySpeedModifierCurve;                  // 0x0C20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredGear;                                       // 0x0C28(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UncontrolledGear;                                  // 0x0C2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackForce;                                    // 0x0C30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackForceVelocityFactor;                      // 0x0C34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackDamage;                                   // 0x0C38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C3C[0x4];                                      // 0x0C3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              KnockbackSound;                                    // 0x0C40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RearingDuration;                                   // 0x0C48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedRearing;                                 // 0x0C4C(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4D[0x3];                                      // 0x0C4D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplicatedRearingTimeOut;                          // 0x0C50(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRearingTime;                                   // 0x0C54(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRearingRealTime;                               // 0x0C58(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRearing;                                        // 0x0C5C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHorseGear                                    MinimumGearToCouch;                                // 0x0C5D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5E[0x2];                                      // 0x0C5E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackEffect*                   HorseHitForceFeedback;                             // 0x0C60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C68[0x8];                                      // 0x0C68(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBumpCapsuleOverlapped(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnRep_ReplicatedRearing();
	void RequestRearing();
	void SecondaryTurnNotAbsolute(float Value);
	void ServerRequestRearing();
	void SpawnTurd();

	float CalculateBumpDamage(const struct FVector& OurWorldVelocity) const;
	bool GetIsInRearingMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Horse">();
	}
	static class AHorse* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHorse>();
	}
};
static_assert(alignof(AHorse) == 0x000010, "Wrong alignment on AHorse");
static_assert(sizeof(AHorse) == 0x000C70, "Wrong size on AHorse");
static_assert(offsetof(AHorse, RecentKnockbacks) == 0x000B88, "Member 'AHorse::RecentKnockbacks' has a wrong offset!");
static_assert(offsetof(AHorse, BumpCapsule) == 0x000BD8, "Member 'AHorse::BumpCapsule' has a wrong offset!");
static_assert(offsetof(AHorse, TurdSpawnInterval) == 0x000BE0, "Member 'AHorse::TurdSpawnInterval' has a wrong offset!");
static_assert(offsetof(AHorse, TurdSpawnChance) == 0x000BE4, "Member 'AHorse::TurdSpawnChance' has a wrong offset!");
static_assert(offsetof(AHorse, LastTurdSpawnCheck) == 0x000BE8, "Member 'AHorse::LastTurdSpawnCheck' has a wrong offset!");
static_assert(offsetof(AHorse, FastFootstepParticlesMinVelocity) == 0x000BEC, "Member 'AHorse::FastFootstepParticlesMinVelocity' has a wrong offset!");
static_assert(offsetof(AHorse, FastFootstepParticles) == 0x000BF0, "Member 'AHorse::FastFootstepParticles' has a wrong offset!");
static_assert(offsetof(AHorse, SoundTrot) == 0x000C00, "Member 'AHorse::SoundTrot' has a wrong offset!");
static_assert(offsetof(AHorse, SoundCanter) == 0x000C08, "Member 'AHorse::SoundCanter' has a wrong offset!");
static_assert(offsetof(AHorse, SoundGallop) == 0x000C10, "Member 'AHorse::SoundGallop' has a wrong offset!");
static_assert(offsetof(AHorse, BumpDamageBySpeedModifierCurve) == 0x000C18, "Member 'AHorse::BumpDamageBySpeedModifierCurve' has a wrong offset!");
static_assert(offsetof(AHorse, AttackDamageBySpeedModifierCurve) == 0x000C20, "Member 'AHorse::AttackDamageBySpeedModifierCurve' has a wrong offset!");
static_assert(offsetof(AHorse, DesiredGear) == 0x000C28, "Member 'AHorse::DesiredGear' has a wrong offset!");
static_assert(offsetof(AHorse, UncontrolledGear) == 0x000C2C, "Member 'AHorse::UncontrolledGear' has a wrong offset!");
static_assert(offsetof(AHorse, KnockbackForce) == 0x000C30, "Member 'AHorse::KnockbackForce' has a wrong offset!");
static_assert(offsetof(AHorse, KnockbackForceVelocityFactor) == 0x000C34, "Member 'AHorse::KnockbackForceVelocityFactor' has a wrong offset!");
static_assert(offsetof(AHorse, KnockbackDamage) == 0x000C38, "Member 'AHorse::KnockbackDamage' has a wrong offset!");
static_assert(offsetof(AHorse, KnockbackSound) == 0x000C40, "Member 'AHorse::KnockbackSound' has a wrong offset!");
static_assert(offsetof(AHorse, RearingDuration) == 0x000C48, "Member 'AHorse::RearingDuration' has a wrong offset!");
static_assert(offsetof(AHorse, ReplicatedRearing) == 0x000C4C, "Member 'AHorse::ReplicatedRearing' has a wrong offset!");
static_assert(offsetof(AHorse, ReplicatedRearingTimeOut) == 0x000C50, "Member 'AHorse::ReplicatedRearingTimeOut' has a wrong offset!");
static_assert(offsetof(AHorse, LastRearingTime) == 0x000C54, "Member 'AHorse::LastRearingTime' has a wrong offset!");
static_assert(offsetof(AHorse, LastRearingRealTime) == 0x000C58, "Member 'AHorse::LastRearingRealTime' has a wrong offset!");
static_assert(offsetof(AHorse, bIsRearing) == 0x000C5C, "Member 'AHorse::bIsRearing' has a wrong offset!");
static_assert(offsetof(AHorse, MinimumGearToCouch) == 0x000C5D, "Member 'AHorse::MinimumGearToCouch' has a wrong offset!");
static_assert(offsetof(AHorse, HorseHitForceFeedback) == 0x000C60, "Member 'AHorse::HorseHitForceFeedback' has a wrong offset!");

// Class Mordhau.HorseAnimInstance
// 0x01A0 (0x0570 - 0x03D0)
class UHorseAnimInstance : public UCreatureAnimInstance
{
public:
	struct FVector2D                              BackLimits;                                        // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FrontLimits;                                       // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RootOffsetTranslationToRotationFactor;             // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BackOffset;                                        // 0x03E8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftBackLegOffset;                                 // 0x03F4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightBackLegOffset;                                // 0x0400(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FrontOffset;                                       // 0x040C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftFrontLegOffset;                                // 0x0418(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightFrontLegOffset;                               // 0x0424(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRearing;                                        // 0x0430(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentForwardPrediction;                          // 0x0434(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardPredictionUpdateSpeed;                      // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardPredictionMaxPredictTime;                   // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceDuckLimit;                                   // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTiltFactorLeftRight;                           // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTiltFactorForward;                             // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTiltFactorBack;                                // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopBounceLimit;                                   // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceInterpSpeed;                                 // 0x045C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadStopTiltFactorLeftRight;                       // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadStopTiltFactorForward;                         // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadStopTiltFactorBack;                            // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadStopBounceLimit;                               // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadBounceInterpSpeed;                             // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastVelocityLagTime;                               // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowVelocityLagTime;                               // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StopBounce;                                        // 0x047C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               StopBounceWorld;                                   // 0x0488(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               HeadStopBounce;                                    // 0x0494(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               HeadStopBounceWorld;                               // 0x04A0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BounceDuck;                                        // 0x04AC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FastVelocity;                                      // 0x04B8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SlowVelocity;                                      // 0x04C4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FastVelocityChangeVelocity;                        // 0x04D0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SlowVelocityChangeVelocity;                        // 0x04DC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PreviousMeshRotation;                              // 0x04E8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FrontBackLegsDistance;                             // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FeetShuffleWeight;                                 // 0x04F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FeetShuffleAnimRate;                               // 0x04FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorseVelocity;                                     // 0x0500(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_504[0x8];                                      // 0x0504(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimatedHorseVelocity;                             // 0x050C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopSmoothSpeed;                                   // 0x0510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementAnimRate;                                  // 0x0514(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorseDirection;                                    // 0x0518(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeanFactor;                                        // 0x0520(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothedDirectionSmoothTime;                       // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothedDirectionSmoothTimeNoMovement;             // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FrontHorseRotator;                                 // 0x052C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               BackHorseRotator;                                  // 0x0538(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               HorseLeanRotator;                                  // 0x0544(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                HorseLeanOffset;                                   // 0x0550(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HorseHeadRotator;                                  // 0x055C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HasDriverFloat;                                    // 0x0568(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56C[0x4];                                      // 0x056C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HorseAnimInstance">();
	}
	static class UHorseAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHorseAnimInstance>();
	}
};
static_assert(alignof(UHorseAnimInstance) == 0x000010, "Wrong alignment on UHorseAnimInstance");
static_assert(sizeof(UHorseAnimInstance) == 0x000570, "Wrong size on UHorseAnimInstance");
static_assert(offsetof(UHorseAnimInstance, BackLimits) == 0x0003D0, "Member 'UHorseAnimInstance::BackLimits' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, FrontLimits) == 0x0003D8, "Member 'UHorseAnimInstance::FrontLimits' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, RootOffsetTranslationToRotationFactor) == 0x0003E0, "Member 'UHorseAnimInstance::RootOffsetTranslationToRotationFactor' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, BackOffset) == 0x0003E8, "Member 'UHorseAnimInstance::BackOffset' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, LeftBackLegOffset) == 0x0003F4, "Member 'UHorseAnimInstance::LeftBackLegOffset' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, RightBackLegOffset) == 0x000400, "Member 'UHorseAnimInstance::RightBackLegOffset' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, FrontOffset) == 0x00040C, "Member 'UHorseAnimInstance::FrontOffset' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, LeftFrontLegOffset) == 0x000418, "Member 'UHorseAnimInstance::LeftFrontLegOffset' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, RightFrontLegOffset) == 0x000424, "Member 'UHorseAnimInstance::RightFrontLegOffset' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, bIsRearing) == 0x000430, "Member 'UHorseAnimInstance::bIsRearing' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, CurrentForwardPrediction) == 0x000434, "Member 'UHorseAnimInstance::CurrentForwardPrediction' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, ForwardPredictionUpdateSpeed) == 0x000440, "Member 'UHorseAnimInstance::ForwardPredictionUpdateSpeed' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, ForwardPredictionMaxPredictTime) == 0x000444, "Member 'UHorseAnimInstance::ForwardPredictionMaxPredictTime' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, BounceDuckLimit) == 0x000448, "Member 'UHorseAnimInstance::BounceDuckLimit' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, StopTiltFactorLeftRight) == 0x00044C, "Member 'UHorseAnimInstance::StopTiltFactorLeftRight' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, StopTiltFactorForward) == 0x000450, "Member 'UHorseAnimInstance::StopTiltFactorForward' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, StopTiltFactorBack) == 0x000454, "Member 'UHorseAnimInstance::StopTiltFactorBack' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, StopBounceLimit) == 0x000458, "Member 'UHorseAnimInstance::StopBounceLimit' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, BounceInterpSpeed) == 0x00045C, "Member 'UHorseAnimInstance::BounceInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, HeadStopTiltFactorLeftRight) == 0x000460, "Member 'UHorseAnimInstance::HeadStopTiltFactorLeftRight' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, HeadStopTiltFactorForward) == 0x000464, "Member 'UHorseAnimInstance::HeadStopTiltFactorForward' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, HeadStopTiltFactorBack) == 0x000468, "Member 'UHorseAnimInstance::HeadStopTiltFactorBack' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, HeadStopBounceLimit) == 0x00046C, "Member 'UHorseAnimInstance::HeadStopBounceLimit' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, HeadBounceInterpSpeed) == 0x000470, "Member 'UHorseAnimInstance::HeadBounceInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, FastVelocityLagTime) == 0x000474, "Member 'UHorseAnimInstance::FastVelocityLagTime' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, SlowVelocityLagTime) == 0x000478, "Member 'UHorseAnimInstance::SlowVelocityLagTime' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, StopBounce) == 0x00047C, "Member 'UHorseAnimInstance::StopBounce' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, StopBounceWorld) == 0x000488, "Member 'UHorseAnimInstance::StopBounceWorld' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, HeadStopBounce) == 0x000494, "Member 'UHorseAnimInstance::HeadStopBounce' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, HeadStopBounceWorld) == 0x0004A0, "Member 'UHorseAnimInstance::HeadStopBounceWorld' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, BounceDuck) == 0x0004AC, "Member 'UHorseAnimInstance::BounceDuck' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, FastVelocity) == 0x0004B8, "Member 'UHorseAnimInstance::FastVelocity' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, SlowVelocity) == 0x0004C4, "Member 'UHorseAnimInstance::SlowVelocity' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, FastVelocityChangeVelocity) == 0x0004D0, "Member 'UHorseAnimInstance::FastVelocityChangeVelocity' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, SlowVelocityChangeVelocity) == 0x0004DC, "Member 'UHorseAnimInstance::SlowVelocityChangeVelocity' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, PreviousMeshRotation) == 0x0004E8, "Member 'UHorseAnimInstance::PreviousMeshRotation' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, FrontBackLegsDistance) == 0x0004F4, "Member 'UHorseAnimInstance::FrontBackLegsDistance' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, FeetShuffleWeight) == 0x0004F8, "Member 'UHorseAnimInstance::FeetShuffleWeight' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, FeetShuffleAnimRate) == 0x0004FC, "Member 'UHorseAnimInstance::FeetShuffleAnimRate' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, HorseVelocity) == 0x000500, "Member 'UHorseAnimInstance::HorseVelocity' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, AnimatedHorseVelocity) == 0x00050C, "Member 'UHorseAnimInstance::AnimatedHorseVelocity' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, StopSmoothSpeed) == 0x000510, "Member 'UHorseAnimInstance::StopSmoothSpeed' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, MovementAnimRate) == 0x000514, "Member 'UHorseAnimInstance::MovementAnimRate' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, HorseDirection) == 0x000518, "Member 'UHorseAnimInstance::HorseDirection' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, LeanFactor) == 0x000520, "Member 'UHorseAnimInstance::LeanFactor' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, SmoothedDirectionSmoothTime) == 0x000524, "Member 'UHorseAnimInstance::SmoothedDirectionSmoothTime' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, SmoothedDirectionSmoothTimeNoMovement) == 0x000528, "Member 'UHorseAnimInstance::SmoothedDirectionSmoothTimeNoMovement' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, FrontHorseRotator) == 0x00052C, "Member 'UHorseAnimInstance::FrontHorseRotator' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, BackHorseRotator) == 0x000538, "Member 'UHorseAnimInstance::BackHorseRotator' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, HorseLeanRotator) == 0x000544, "Member 'UHorseAnimInstance::HorseLeanRotator' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, HorseLeanOffset) == 0x000550, "Member 'UHorseAnimInstance::HorseLeanOffset' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, HorseHeadRotator) == 0x00055C, "Member 'UHorseAnimInstance::HorseHeadRotator' has a wrong offset!");
static_assert(offsetof(UHorseAnimInstance, HasDriverFloat) == 0x000568, "Member 'UHorseAnimInstance::HasDriverFloat' has a wrong offset!");

// Class Mordhau.PseudoVehicleMovementComponent
// 0x0040 (0x0C90 - 0x0C50)
class UPseudoVehicleMovementComponent : public UAdvancedCharacterMovement
{
public:
	TArray<class UPrimitiveComponent*>            SecondaryComponents;                               // 0x0C48(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            SecondaryStepCapableComponents;                    // 0x0C58(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         TurningVelocity;                                   // 0x0C68(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C6C[0x4];                                      // 0x0C6C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TurningBrakeAccelerationByVelocity;                // 0x0C70(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TurningFactorByVelocity;                           // 0x0C78(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TurningAccelerationByVelocity;                     // 0x0C80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningFactorScaleAirborne;                        // 0x0C88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8C[0x4];                                      // 0x0C8C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PseudoVehicleMovementComponent">();
	}
	static class UPseudoVehicleMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPseudoVehicleMovementComponent>();
	}
};
static_assert(alignof(UPseudoVehicleMovementComponent) == 0x000010, "Wrong alignment on UPseudoVehicleMovementComponent");
static_assert(sizeof(UPseudoVehicleMovementComponent) == 0x000C90, "Wrong size on UPseudoVehicleMovementComponent");
static_assert(offsetof(UPseudoVehicleMovementComponent, SecondaryComponents) == 0x000C48, "Member 'UPseudoVehicleMovementComponent::SecondaryComponents' has a wrong offset!");
static_assert(offsetof(UPseudoVehicleMovementComponent, SecondaryStepCapableComponents) == 0x000C58, "Member 'UPseudoVehicleMovementComponent::SecondaryStepCapableComponents' has a wrong offset!");
static_assert(offsetof(UPseudoVehicleMovementComponent, TurningVelocity) == 0x000C68, "Member 'UPseudoVehicleMovementComponent::TurningVelocity' has a wrong offset!");
static_assert(offsetof(UPseudoVehicleMovementComponent, TurningBrakeAccelerationByVelocity) == 0x000C70, "Member 'UPseudoVehicleMovementComponent::TurningBrakeAccelerationByVelocity' has a wrong offset!");
static_assert(offsetof(UPseudoVehicleMovementComponent, TurningFactorByVelocity) == 0x000C78, "Member 'UPseudoVehicleMovementComponent::TurningFactorByVelocity' has a wrong offset!");
static_assert(offsetof(UPseudoVehicleMovementComponent, TurningAccelerationByVelocity) == 0x000C80, "Member 'UPseudoVehicleMovementComponent::TurningAccelerationByVelocity' has a wrong offset!");
static_assert(offsetof(UPseudoVehicleMovementComponent, TurningFactorScaleAirborne) == 0x000C88, "Member 'UPseudoVehicleMovementComponent::TurningFactorScaleAirborne' has a wrong offset!");

// Class Mordhau.HorseMovementComponent
// 0x0070 (0x0D00 - 0x0C90)
class UHorseMovementComponent final : public UPseudoVehicleMovementComponent
{
public:
	float                                         HeadOnCollisionMinSpeedToRear;                     // 0x0C90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SoftBubbleEllipseRelativeLocation;                 // 0x0C94(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftBubbleEllipseLength;                           // 0x0CA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftBubbleEllipseRadius;                           // 0x0CA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftBubbleMaxHeight;                               // 0x0CA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontAndRearCapsuleHalfHeight;                     // 0x0CAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontAndRearCapsuleRadius;                         // 0x0CB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FrontCapsuleRelativeLocation;                      // 0x0CB4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RearCapsuleRelativeLocation;                       // 0x0CC0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceTurningAcceleration;                      // 0x0CCC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHorseGear                                    Gear;                                              // 0x0CD0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD1[0x7];                                      // 0x0CD1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHorseGearInfo>                 GearInfo;                                          // 0x0CD8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EHorseGear                                    DesiredGear;                                       // 0x0CE8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE9[0x3];                                      // 0x0CE9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedMultiplierOnBump;                             // 0x0CEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMultiplierOnReceivedMeleeDamage;              // 0x0CF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CF4[0xC];                                      // 0x0CF4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HorseMovementComponent">();
	}
	static class UHorseMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHorseMovementComponent>();
	}
};
static_assert(alignof(UHorseMovementComponent) == 0x000010, "Wrong alignment on UHorseMovementComponent");
static_assert(sizeof(UHorseMovementComponent) == 0x000D00, "Wrong size on UHorseMovementComponent");
static_assert(offsetof(UHorseMovementComponent, HeadOnCollisionMinSpeedToRear) == 0x000C90, "Member 'UHorseMovementComponent::HeadOnCollisionMinSpeedToRear' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, SoftBubbleEllipseRelativeLocation) == 0x000C94, "Member 'UHorseMovementComponent::SoftBubbleEllipseRelativeLocation' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, SoftBubbleEllipseLength) == 0x000CA0, "Member 'UHorseMovementComponent::SoftBubbleEllipseLength' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, SoftBubbleEllipseRadius) == 0x000CA4, "Member 'UHorseMovementComponent::SoftBubbleEllipseRadius' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, SoftBubbleMaxHeight) == 0x000CA8, "Member 'UHorseMovementComponent::SoftBubbleMaxHeight' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, FrontAndRearCapsuleHalfHeight) == 0x000CAC, "Member 'UHorseMovementComponent::FrontAndRearCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, FrontAndRearCapsuleRadius) == 0x000CB0, "Member 'UHorseMovementComponent::FrontAndRearCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, FrontCapsuleRelativeLocation) == 0x000CB4, "Member 'UHorseMovementComponent::FrontCapsuleRelativeLocation' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, RearCapsuleRelativeLocation) == 0x000CC0, "Member 'UHorseMovementComponent::RearCapsuleRelativeLocation' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, AvoidanceTurningAcceleration) == 0x000CCC, "Member 'UHorseMovementComponent::AvoidanceTurningAcceleration' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, Gear) == 0x000CD0, "Member 'UHorseMovementComponent::Gear' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, GearInfo) == 0x000CD8, "Member 'UHorseMovementComponent::GearInfo' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, DesiredGear) == 0x000CE8, "Member 'UHorseMovementComponent::DesiredGear' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, SpeedMultiplierOnBump) == 0x000CEC, "Member 'UHorseMovementComponent::SpeedMultiplierOnBump' has a wrong offset!");
static_assert(offsetof(UHorseMovementComponent, SpeedMultiplierOnReceivedMeleeDamage) == 0x000CF0, "Member 'UHorseMovementComponent::SpeedMultiplierOnReceivedMeleeDamage' has a wrong offset!");

// Class Mordhau.MordhauVehicleComponent
// 0x0100 (0x01B0 - 0x00B0)
#pragma pack(push, 0x1)
class alignas(0x10) UMordhauVehicleComponent : public UActorComponent
{
public:
	bool                                          bLeaveOnDamage;                                    // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaveOnDamageIfFriendly;                          // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickDriverAnimsAfterOurs;                         // 0x00B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVisualPingCompensationOnAttacks;               // 0x00B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x00B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AttachSocketOffset;                                // 0x00C0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseDetachRotation;                                // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DetachSocketName;                                  // 0x00F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDriverTurnCaps;                                // 0x00FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OriginalNetUpdateFrequency;                        // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableUnusedNetUpdateFrequency;                   // 0x0104(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasEverDriven;                                    // 0x0105(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_106[0x2];                                      // 0x0106(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MainAnimationType;                                 // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentUnusedTime;                                 // 0x0110(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeToStartUnusedDying;                         // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UnusedDyingHealthReduction;                        // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnusedDyingHealthReductionInterval;                // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnusedNetUpdateFrequency;                          // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillDieIfUnused;                                  // 0x0124(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDriverRegenHealth;                             // 0x0125(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDriverRegenStamina;                            // 0x0126(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_127[0x1];                                      // 0x0127(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinXYDistanceToEnter;                              // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MinZDistanceToEnter;                               // 0x012C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumInteractableVelocity;                       // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastObservedVehicleYaw;                            // 0x0138(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCounteractTurnWithSecondaryTurn;                  // 0x013C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetSecondaryTurnWhenNoDriver;                   // 0x013D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E[0x2];                                      // 0x013E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondaryTurnValue;                                // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryTurnLimit;                                // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedSecondaryTurnValue;                      // 0x0148(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondaryTurnValueSmoothingTarget;                 // 0x014C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryTurnValueSmoothingFrom;                   // 0x0150(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryTurnValueSmoothingStartTime;              // 0x0154(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSmoothedTurnValue;                            // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSmoothingTurnVelocity;                        // 0x015C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisarmOnEnter;                                    // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMordhauCharacter*                      Driver;                                            // 0x0168(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLadder;                                         // 0x0170(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHorse;                                          // 0x0171(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_172[0x1];                                      // 0x0172(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsRangedWeapon;                                   // 0x0173(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AAdvancedCharacter*                     CharacterOwner;                                    // 0x0178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVehicleBase*                           VehicleOwner;                                      // 0x0180(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0188(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0190(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterMovementComponent*            CharacterMovement;                                 // 0x0198(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APawn*                                  PawnOwner;                                         // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DriverLateTick(class AMordhauCharacter* FromDriver, float DeltaTime);
	struct FTransform GetExitTransform();
	struct FVehicleTransitionInfo GetVehicleEnterInfo(class AMordhauCharacter* Character, const struct FTransform& FromTransform);
	struct FVehicleTransitionInfo GetVehicleLeaveInfo(class AMordhauCharacter* Character, const struct FTransform& FromTransform);
	void OnDriverChanged();
	void OnRep_ReplicatedSecondaryTurnValue();
	void OnStartedDriving(class AMordhauCharacter* Character);
	void OnStoppedDriving(class AMordhauCharacter* Character);
	float OverrideAttackAngle(class UAttackMotion* Motion);
	struct FPOV PostProcessCameraPOV(const struct FPOV& InPOV, class AMordhauCharacter* Character);
	void RequestMeshEnablePhysics(float Duration);
	void SecondaryTurn(float Value, bool bIsAbsolute);
	void SecondaryTurnAtRate(float Value);
	void ServerSecondaryTurn(float NewTurn);
	void SetDriver(class AMordhauCharacter* NewDriver);
	void StartDriving(class AMordhauCharacter* Character);
	void StopDriving();
	void Suicide();
	void UpdateAnimationFor(class AMordhauCharacter* Character, class UMordhauAnimInstance* AnimInst, float DeltaTime);
	void UpdateFPCameraFor(class AMordhauCharacter* Character, float DeltaSeconds, bool bRotationOnly);

	bool CanDrive(class AMordhauCharacter* Character) const;
	class AMordhauCharacter* GetDriver() const;
	float GetLookUpValue() const;
	class USkeletalMeshComponent* GetMesh() const;
	class APawn* GetPawnOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauVehicleComponent">();
	}
	static class UMordhauVehicleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauVehicleComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UMordhauVehicleComponent) == 0x000010, "Wrong alignment on UMordhauVehicleComponent");
static_assert(sizeof(UMordhauVehicleComponent) == 0x0001B0, "Wrong size on UMordhauVehicleComponent");
static_assert(offsetof(UMordhauVehicleComponent, bLeaveOnDamage) == 0x0000B0, "Member 'UMordhauVehicleComponent::bLeaveOnDamage' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bLeaveOnDamageIfFriendly) == 0x0000B1, "Member 'UMordhauVehicleComponent::bLeaveOnDamageIfFriendly' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bTickDriverAnimsAfterOurs) == 0x0000B2, "Member 'UMordhauVehicleComponent::bTickDriverAnimsAfterOurs' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bUseVisualPingCompensationOnAttacks) == 0x0000B3, "Member 'UMordhauVehicleComponent::bUseVisualPingCompensationOnAttacks' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, AttachSocketName) == 0x0000B4, "Member 'UMordhauVehicleComponent::AttachSocketName' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, AttachSocketOffset) == 0x0000C0, "Member 'UMordhauVehicleComponent::AttachSocketOffset' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bUseDetachRotation) == 0x0000F0, "Member 'UMordhauVehicleComponent::bUseDetachRotation' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, DetachSocketName) == 0x0000F4, "Member 'UMordhauVehicleComponent::DetachSocketName' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bUseDriverTurnCaps) == 0x0000FC, "Member 'UMordhauVehicleComponent::bUseDriverTurnCaps' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, OriginalNetUpdateFrequency) == 0x000100, "Member 'UMordhauVehicleComponent::OriginalNetUpdateFrequency' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bEnableUnusedNetUpdateFrequency) == 0x000104, "Member 'UMordhauVehicleComponent::bEnableUnusedNetUpdateFrequency' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bWasEverDriven) == 0x000105, "Member 'UMordhauVehicleComponent::bWasEverDriven' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, MainAnimationType) == 0x000108, "Member 'UMordhauVehicleComponent::MainAnimationType' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, CurrentUnusedTime) == 0x000110, "Member 'UMordhauVehicleComponent::CurrentUnusedTime' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, MinTimeToStartUnusedDying) == 0x000114, "Member 'UMordhauVehicleComponent::MinTimeToStartUnusedDying' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, UnusedDyingHealthReduction) == 0x000118, "Member 'UMordhauVehicleComponent::UnusedDyingHealthReduction' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, UnusedDyingHealthReductionInterval) == 0x00011C, "Member 'UMordhauVehicleComponent::UnusedDyingHealthReductionInterval' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, UnusedNetUpdateFrequency) == 0x000120, "Member 'UMordhauVehicleComponent::UnusedNetUpdateFrequency' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bWillDieIfUnused) == 0x000124, "Member 'UMordhauVehicleComponent::bWillDieIfUnused' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bCanDriverRegenHealth) == 0x000125, "Member 'UMordhauVehicleComponent::bCanDriverRegenHealth' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bCanDriverRegenStamina) == 0x000126, "Member 'UMordhauVehicleComponent::bCanDriverRegenStamina' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, MinXYDistanceToEnter) == 0x000128, "Member 'UMordhauVehicleComponent::MinXYDistanceToEnter' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, MinZDistanceToEnter) == 0x00012C, "Member 'UMordhauVehicleComponent::MinZDistanceToEnter' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, MinimumInteractableVelocity) == 0x000134, "Member 'UMordhauVehicleComponent::MinimumInteractableVelocity' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, LastObservedVehicleYaw) == 0x000138, "Member 'UMordhauVehicleComponent::LastObservedVehicleYaw' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bCounteractTurnWithSecondaryTurn) == 0x00013C, "Member 'UMordhauVehicleComponent::bCounteractTurnWithSecondaryTurn' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bResetSecondaryTurnWhenNoDriver) == 0x00013D, "Member 'UMordhauVehicleComponent::bResetSecondaryTurnWhenNoDriver' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, SecondaryTurnValue) == 0x000140, "Member 'UMordhauVehicleComponent::SecondaryTurnValue' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, SecondaryTurnLimit) == 0x000144, "Member 'UMordhauVehicleComponent::SecondaryTurnLimit' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, ReplicatedSecondaryTurnValue) == 0x000148, "Member 'UMordhauVehicleComponent::ReplicatedSecondaryTurnValue' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, SecondaryTurnValueSmoothingTarget) == 0x00014C, "Member 'UMordhauVehicleComponent::SecondaryTurnValueSmoothingTarget' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, SecondaryTurnValueSmoothingFrom) == 0x000150, "Member 'UMordhauVehicleComponent::SecondaryTurnValueSmoothingFrom' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, SecondaryTurnValueSmoothingStartTime) == 0x000154, "Member 'UMordhauVehicleComponent::SecondaryTurnValueSmoothingStartTime' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, MouseSmoothedTurnValue) == 0x000158, "Member 'UMordhauVehicleComponent::MouseSmoothedTurnValue' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, MouseSmoothingTurnVelocity) == 0x00015C, "Member 'UMordhauVehicleComponent::MouseSmoothingTurnVelocity' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bDisarmOnEnter) == 0x000160, "Member 'UMordhauVehicleComponent::bDisarmOnEnter' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, Driver) == 0x000168, "Member 'UMordhauVehicleComponent::Driver' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bIsLadder) == 0x000170, "Member 'UMordhauVehicleComponent::bIsLadder' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bIsHorse) == 0x000171, "Member 'UMordhauVehicleComponent::bIsHorse' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, bIsRangedWeapon) == 0x000173, "Member 'UMordhauVehicleComponent::bIsRangedWeapon' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, CharacterOwner) == 0x000178, "Member 'UMordhauVehicleComponent::CharacterOwner' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, VehicleOwner) == 0x000180, "Member 'UMordhauVehicleComponent::VehicleOwner' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, MeshComponent) == 0x000188, "Member 'UMordhauVehicleComponent::MeshComponent' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, CapsuleComponent) == 0x000190, "Member 'UMordhauVehicleComponent::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, CharacterMovement) == 0x000198, "Member 'UMordhauVehicleComponent::CharacterMovement' has a wrong offset!");
static_assert(offsetof(UMordhauVehicleComponent, PawnOwner) == 0x0001A0, "Member 'UMordhauVehicleComponent::PawnOwner' has a wrong offset!");

// Class Mordhau.HorseVehicleComponent
// 0x0010 (0x01C0 - 0x01B0)
class UHorseVehicleComponent : public UMordhauVehicleComponent
{
public:
	class UCurveFloat*                            RiderRearingCurve;                                 // 0x01A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B0[0x10];                                     // 0x01B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HorseVehicleComponent">();
	}
	static class UHorseVehicleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHorseVehicleComponent>();
	}
};
static_assert(alignof(UHorseVehicleComponent) == 0x000010, "Wrong alignment on UHorseVehicleComponent");
static_assert(sizeof(UHorseVehicleComponent) == 0x0001C0, "Wrong size on UHorseVehicleComponent");
static_assert(offsetof(UHorseVehicleComponent, RiderRearingCurve) == 0x0001A8, "Member 'UHorseVehicleComponent::RiderRearingCurve' has a wrong offset!");

// Class Mordhau.IdleMotion
// 0x0000 (0x00A0 - 0x00A0)
class UIdleMotion final : public UMordhauMotion
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IdleMotion">();
	}
	static class UIdleMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIdleMotion>();
	}
};
static_assert(alignof(UIdleMotion) == 0x000008, "Wrong alignment on UIdleMotion");
static_assert(sizeof(UIdleMotion) == 0x0000A0, "Wrong size on UIdleMotion");

// Class Mordhau.Interactable
// 0x0000 (0x0028 - 0x0028)
class IInteractable final : public IInterface
{
public:
	void HeldInteractionStart(class AMordhauCharacter* Character);
	void Highlight();
	void InteractionEnd(class AMordhauCharacter* Character);
	void InteractionMaintained(class AMordhauCharacter* Character, float DeltaTime);
	void InteractionStart(class AMordhauCharacter* Character);
	void InteractPassively(class AMordhauCharacter* Character);
	void OnHeldInteractionStart(class AMordhauCharacter* Character);
	void OnHighlightEnd();
	void OnHighlightMaintained(class AMordhauCharacter* Character);
	void OnHighlightStart();
	void OnInteractionEnd(class AMordhauCharacter* Character);
	void OnInteractionMaintained(class AMordhauCharacter* Character);
	void OnInteractionStart(class AMordhauCharacter* Character);
	void OnInteractPassively(class AMordhauCharacter* Character);
	void UnHighlight();

	bool CanHeldInteract(class AMordhauCharacter* Character) const;
	bool CanInteract(class AMordhauCharacter* Character) const;
	bool CanInteractPassively(class AMordhauCharacter* Character) const;
	float GetMaxInteractionHoldTime() const;
	bool IsCooperativeInteractionAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interactable">();
	}
	static class IInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractable>();
	}
};
static_assert(alignof(IInteractable) == 0x000008, "Wrong alignment on IInteractable");
static_assert(sizeof(IInteractable) == 0x000028, "Wrong size on IInteractable");

// Class Mordhau.InteractionComponent
// 0x0010 (0x0480 - 0x0470)
class UInteractionComponent final : public UBoxComponent
{
public:
	TArray<class UMeshComponent*>                 VisualMeshComponents;                              // 0x0468(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsInteractable;                                   // 0x0478(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHighlighted;                                    // 0x0479(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47A[0x6];                                      // 0x047A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Highlight();
	void InteractionEnd();
	void InteractionStart(class AAdvancedCharacter* Character);
	void OnHighlightEnd();
	void OnHighlightStart();
	void OnInteractionEnd();
	void OnInteractionStart(class AAdvancedCharacter* Character);
	void UnHighlight();

	bool CanInteract(class AAdvancedCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionComponent">();
	}
	static class UInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionComponent>();
	}
};
static_assert(alignof(UInteractionComponent) == 0x000010, "Wrong alignment on UInteractionComponent");
static_assert(sizeof(UInteractionComponent) == 0x000480, "Wrong size on UInteractionComponent");
static_assert(offsetof(UInteractionComponent, VisualMeshComponents) == 0x000468, "Member 'UInteractionComponent::VisualMeshComponents' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bIsInteractable) == 0x000478, "Member 'UInteractionComponent::bIsInteractable' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bIsHighlighted) == 0x000479, "Member 'UInteractionComponent::bIsHighlighted' has a wrong offset!");

// Class Mordhau.InteractWithMotion
// 0x0038 (0x00D8 - 0x00A0)
class UInteractWithMotion : public UMordhauMotion
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimPauseAt1P;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimPauseAt3P;                                     // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayOut1PAnimRate;                                 // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayOut3PAnimRate;                                 // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Interact1PMontage;                                 // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Interact3PMontage;                                 // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractWithMotion">();
	}
	static class UInteractWithMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractWithMotion>();
	}
};
static_assert(alignof(UInteractWithMotion) == 0x000008, "Wrong alignment on UInteractWithMotion");
static_assert(sizeof(UInteractWithMotion) == 0x0000D8, "Wrong size on UInteractWithMotion");
static_assert(offsetof(UInteractWithMotion, AnimPauseAt1P) == 0x0000A8, "Member 'UInteractWithMotion::AnimPauseAt1P' has a wrong offset!");
static_assert(offsetof(UInteractWithMotion, AnimPauseAt3P) == 0x0000AC, "Member 'UInteractWithMotion::AnimPauseAt3P' has a wrong offset!");
static_assert(offsetof(UInteractWithMotion, PlayOut1PAnimRate) == 0x0000B0, "Member 'UInteractWithMotion::PlayOut1PAnimRate' has a wrong offset!");
static_assert(offsetof(UInteractWithMotion, PlayOut3PAnimRate) == 0x0000B4, "Member 'UInteractWithMotion::PlayOut3PAnimRate' has a wrong offset!");
static_assert(offsetof(UInteractWithMotion, Montage) == 0x0000B8, "Member 'UInteractWithMotion::Montage' has a wrong offset!");
static_assert(offsetof(UInteractWithMotion, Interact1PMontage) == 0x0000C0, "Member 'UInteractWithMotion::Interact1PMontage' has a wrong offset!");
static_assert(offsetof(UInteractWithMotion, Interact3PMontage) == 0x0000C8, "Member 'UInteractWithMotion::Interact3PMontage' has a wrong offset!");

// Class Mordhau.KickMotion
// 0x0018 (0x1118 - 0x1100)
class UKickMotion : public UAttackMotion
{
public:
	float                                         KickDamageModifierTier3Legs;                       // 0x1100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpKickStaminaDrain;                              // 0x1104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpKickExtraWindup;                               // 0x1108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementRestriction                          JumpKickAirMovementRestriction;                    // 0x110C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110D[0x3];                                     // 0x110D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAirborneTimeForJumpKickAnim;                    // 0x1110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAirKick;                                        // 0x1114(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1115[0x3];                                     // 0x1115(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KickMotion">();
	}
	static class UKickMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKickMotion>();
	}
};
static_assert(alignof(UKickMotion) == 0x000008, "Wrong alignment on UKickMotion");
static_assert(sizeof(UKickMotion) == 0x001118, "Wrong size on UKickMotion");
static_assert(offsetof(UKickMotion, KickDamageModifierTier3Legs) == 0x001100, "Member 'UKickMotion::KickDamageModifierTier3Legs' has a wrong offset!");
static_assert(offsetof(UKickMotion, JumpKickStaminaDrain) == 0x001104, "Member 'UKickMotion::JumpKickStaminaDrain' has a wrong offset!");
static_assert(offsetof(UKickMotion, JumpKickExtraWindup) == 0x001108, "Member 'UKickMotion::JumpKickExtraWindup' has a wrong offset!");
static_assert(offsetof(UKickMotion, JumpKickAirMovementRestriction) == 0x00110C, "Member 'UKickMotion::JumpKickAirMovementRestriction' has a wrong offset!");
static_assert(offsetof(UKickMotion, MaxAirborneTimeForJumpKickAnim) == 0x001110, "Member 'UKickMotion::MaxAirborneTimeForJumpKickAnim' has a wrong offset!");
static_assert(offsetof(UKickMotion, bIsAirKick) == 0x001114, "Member 'UKickMotion::bIsAirKick' has a wrong offset!");

// Class Mordhau.KillCommand
// 0x0000 (0x0080 - 0x0080)
class UKillCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillCommand">();
	}
	static class UKillCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillCommand>();
	}
};
static_assert(alignof(UKillCommand) == 0x000008, "Wrong alignment on UKillCommand");
static_assert(sizeof(UKillCommand) == 0x000080, "Wrong size on UKillCommand");

// Class Mordhau.LeaveVehicleMotion
// 0x0000 (0x00A0 - 0x00A0)
class ULeaveVehicleMotion final : public UMordhauMotion
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaveVehicleMotion">();
	}
	static class ULeaveVehicleMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaveVehicleMotion>();
	}
};
static_assert(alignof(ULeaveVehicleMotion) == 0x000008, "Wrong alignment on ULeaveVehicleMotion");
static_assert(sizeof(ULeaveVehicleMotion) == 0x0000A0, "Wrong size on ULeaveVehicleMotion");

// Class Mordhau.LODStaticMeshActor
// 0x0008 (0x0228 - 0x0220)
class ALODStaticMeshActor final : public AActor
{
public:
	class ULODStaticMeshComponent*                StaticMeshComponent;                               // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LODStaticMeshActor">();
	}
	static class ALODStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALODStaticMeshActor>();
	}
};
static_assert(alignof(ALODStaticMeshActor) == 0x000008, "Wrong alignment on ALODStaticMeshActor");
static_assert(sizeof(ALODStaticMeshActor) == 0x000228, "Wrong size on ALODStaticMeshActor");
static_assert(offsetof(ALODStaticMeshActor, StaticMeshComponent) == 0x000220, "Member 'ALODStaticMeshActor::StaticMeshComponent' has a wrong offset!");

// Class Mordhau.LODStaticMeshComponent
// 0x0000 (0x04D0 - 0x04D0)
class ULODStaticMeshComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LODStaticMeshComponent">();
	}
	static class ULODStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULODStaticMeshComponent>();
	}
};
static_assert(alignof(ULODStaticMeshComponent) == 0x000010, "Wrong alignment on ULODStaticMeshComponent");
static_assert(sizeof(ULODStaticMeshComponent) == 0x0004D0, "Wrong size on ULODStaticMeshComponent");

// Class Mordhau.ManageAdminCommand
// 0x0000 (0x0080 - 0x0080)
class UManageAdminCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManageAdminCommand">();
	}
	static class UManageAdminCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UManageAdminCommand>();
	}
};
static_assert(alignof(UManageAdminCommand) == 0x000008, "Wrong alignment on UManageAdminCommand");
static_assert(sizeof(UManageAdminCommand) == 0x000080, "Wrong size on UManageAdminCommand");

// Class Mordhau.MapCameraActor
// 0x0010 (0x07B0 - 0x07A0)
class AMapCameraActor final : public ACameraActor
{
public:
	int32                                         Team;                                              // 0x07A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtmosphericFogMultiplierOverride;                  // 0x07A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A8[0x8];                                      // 0x07A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapCameraActor">();
	}
	static class AMapCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapCameraActor>();
	}
};
static_assert(alignof(AMapCameraActor) == 0x000010, "Wrong alignment on AMapCameraActor");
static_assert(sizeof(AMapCameraActor) == 0x0007B0, "Wrong size on AMapCameraActor");
static_assert(offsetof(AMapCameraActor, Team) == 0x0007A0, "Member 'AMapCameraActor::Team' has a wrong offset!");
static_assert(offsetof(AMapCameraActor, AtmosphericFogMultiplierOverride) == 0x0007A4, "Member 'AMapCameraActor::AtmosphericFogMultiplierOverride' has a wrong offset!");

// Class Mordhau.MapListCommand
// 0x0000 (0x0080 - 0x0080)
class UMapListCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapListCommand">();
	}
	static class UMapListCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapListCommand>();
	}
};
static_assert(alignof(UMapListCommand) == 0x000008, "Wrong alignment on UMapListCommand");
static_assert(sizeof(UMapListCommand) == 0x000080, "Wrong size on UMapListCommand");

// Class Mordhau.MapMetadataOverride
// 0x0000 (0x0098 - 0x0098)
class UMapMetadataOverride : public UMapMetadataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMetadataOverride">();
	}
	static class UMapMetadataOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMetadataOverride>();
	}
};
static_assert(alignof(UMapMetadataOverride) == 0x000008, "Wrong alignment on UMapMetadataOverride");
static_assert(sizeof(UMapMetadataOverride) == 0x000098, "Wrong size on UMapMetadataOverride");

// Class Mordhau.MasterField
// 0x0118 (0x0338 - 0x0220)
class AMasterField : public AActor
{
public:
	uint8                                         Pad_220[0x5C];                                     // 0x0220(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CreatedTime;                                       // 0x027C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeactivatedTime;                                   // 0x0280(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeactivationStartedTime;                           // 0x0284(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAreSubfieldsHidden;                               // 0x0288(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFieldActive;                                    // 0x0289(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBegunDeactivation;                             // 0x028A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28B[0x5];                                      // 0x028B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFieldSpawnComponent*>           SubFieldSpawns;                                    // 0x0290(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ASubField>>       SubFields;                                         // 0x02A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FBox                                   CombinedBoundsBox;                                 // 0x02B0(0x001C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FieldLifeTime;                                     // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldDeactivationTime;                             // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldFadeOutTime;                                  // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             CollisionFilter;                                   // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class AActor*, int32>                    ActorPresenceTickCount;                            // 0x02E8(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void BeginFieldDeactivation();
	float ComputeDistanceIntoField(const struct FVector& Location);
	void CreateField();
	void DeactivateAndDestroyField();
	TArray<class ASubField*> GetSubFields();
	void RecomputeCombinedBoundingBox();
	void SetSubFieldsHidden(bool bAreHidden);
	void UpdateField();

	struct FVector GetFieldBoundsCenter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MasterField">();
	}
	static class AMasterField* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMasterField>();
	}
};
static_assert(alignof(AMasterField) == 0x000008, "Wrong alignment on AMasterField");
static_assert(sizeof(AMasterField) == 0x000338, "Wrong size on AMasterField");
static_assert(offsetof(AMasterField, CreatedTime) == 0x00027C, "Member 'AMasterField::CreatedTime' has a wrong offset!");
static_assert(offsetof(AMasterField, DeactivatedTime) == 0x000280, "Member 'AMasterField::DeactivatedTime' has a wrong offset!");
static_assert(offsetof(AMasterField, DeactivationStartedTime) == 0x000284, "Member 'AMasterField::DeactivationStartedTime' has a wrong offset!");
static_assert(offsetof(AMasterField, bAreSubfieldsHidden) == 0x000288, "Member 'AMasterField::bAreSubfieldsHidden' has a wrong offset!");
static_assert(offsetof(AMasterField, bIsFieldActive) == 0x000289, "Member 'AMasterField::bIsFieldActive' has a wrong offset!");
static_assert(offsetof(AMasterField, bHasBegunDeactivation) == 0x00028A, "Member 'AMasterField::bHasBegunDeactivation' has a wrong offset!");
static_assert(offsetof(AMasterField, SubFieldSpawns) == 0x000290, "Member 'AMasterField::SubFieldSpawns' has a wrong offset!");
static_assert(offsetof(AMasterField, SubFields) == 0x0002A0, "Member 'AMasterField::SubFields' has a wrong offset!");
static_assert(offsetof(AMasterField, CombinedBoundsBox) == 0x0002B0, "Member 'AMasterField::CombinedBoundsBox' has a wrong offset!");
static_assert(offsetof(AMasterField, FieldLifeTime) == 0x0002CC, "Member 'AMasterField::FieldLifeTime' has a wrong offset!");
static_assert(offsetof(AMasterField, FieldDeactivationTime) == 0x0002D0, "Member 'AMasterField::FieldDeactivationTime' has a wrong offset!");
static_assert(offsetof(AMasterField, FieldFadeOutTime) == 0x0002D4, "Member 'AMasterField::FieldFadeOutTime' has a wrong offset!");
static_assert(offsetof(AMasterField, CollisionFilter) == 0x0002D8, "Member 'AMasterField::CollisionFilter' has a wrong offset!");
static_assert(offsetof(AMasterField, ActorPresenceTickCount) == 0x0002E8, "Member 'AMasterField::ActorPresenceTickCount' has a wrong offset!");

// Class Mordhau.JoinMatchmakingTicket
// 0x00B0 (0x00E0 - 0x0030)
class UJoinMatchmakingTicket final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const class FString& QueueName, const class FString& TicketId)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& QueueName, const class FString& TicketId)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QueueName;                                         // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 TicketId;                                          // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayFabMatchmakingAttributes          Attributes;                                        // 0x0078(0x0068)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UJoinMatchmakingTicket* JoinMatchmakingTicket(const class FString& QueueName_0, const class FString& TicketId_0, const struct FPlayFabMatchmakingAttributes& Attributes_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JoinMatchmakingTicket">();
	}
	static class UJoinMatchmakingTicket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJoinMatchmakingTicket>();
	}
};
static_assert(alignof(UJoinMatchmakingTicket) == 0x000008, "Wrong alignment on UJoinMatchmakingTicket");
static_assert(sizeof(UJoinMatchmakingTicket) == 0x0000E0, "Wrong size on UJoinMatchmakingTicket");
static_assert(offsetof(UJoinMatchmakingTicket, onSuccess) == 0x000030, "Member 'UJoinMatchmakingTicket::onSuccess' has a wrong offset!");
static_assert(offsetof(UJoinMatchmakingTicket, onFailure) == 0x000040, "Member 'UJoinMatchmakingTicket::onFailure' has a wrong offset!");
static_assert(offsetof(UJoinMatchmakingTicket, QueueName) == 0x000058, "Member 'UJoinMatchmakingTicket::QueueName' has a wrong offset!");
static_assert(offsetof(UJoinMatchmakingTicket, TicketId) == 0x000068, "Member 'UJoinMatchmakingTicket::TicketId' has a wrong offset!");
static_assert(offsetof(UJoinMatchmakingTicket, Attributes) == 0x000078, "Member 'UJoinMatchmakingTicket::Attributes' has a wrong offset!");

// Class Mordhau.CancelMatchmakingTicket
// 0x0038 (0x0068 - 0x0030)
class UCancelMatchmakingTicket final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const class FString& QueueName)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& QueueName)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QueueName;                                         // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UCancelMatchmakingTicket* CancelMatchmakingTicket(const class FString& QueueName_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CancelMatchmakingTicket">();
	}
	static class UCancelMatchmakingTicket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCancelMatchmakingTicket>();
	}
};
static_assert(alignof(UCancelMatchmakingTicket) == 0x000008, "Wrong alignment on UCancelMatchmakingTicket");
static_assert(sizeof(UCancelMatchmakingTicket) == 0x000068, "Wrong size on UCancelMatchmakingTicket");
static_assert(offsetof(UCancelMatchmakingTicket, onSuccess) == 0x000030, "Member 'UCancelMatchmakingTicket::onSuccess' has a wrong offset!");
static_assert(offsetof(UCancelMatchmakingTicket, onFailure) == 0x000040, "Member 'UCancelMatchmakingTicket::onFailure' has a wrong offset!");
static_assert(offsetof(UCancelMatchmakingTicket, QueueName) == 0x000058, "Member 'UCancelMatchmakingTicket::QueueName' has a wrong offset!");

// Class Mordhau.GetMatchmakingTicket
// 0x0048 (0x0078 - 0x0030)
class UGetMatchmakingTicket final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const class FString& QueueName, const class FString& TicketId, EPlayFabTicketStatus TicketStatus, const class FString& CancellationReason, const class FString& MatchId)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& QueueName, const class FString& TicketId, EPlayFabTicketStatus TicketStatus, const class FString& CancellationReason, const class FString& MatchId)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QueueName;                                         // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 TicketId;                                          // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGetMatchmakingTicket* GetMatchmakingTicket(const class FString& QueueName_0, const class FString& TicketId_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetMatchmakingTicket">();
	}
	static class UGetMatchmakingTicket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetMatchmakingTicket>();
	}
};
static_assert(alignof(UGetMatchmakingTicket) == 0x000008, "Wrong alignment on UGetMatchmakingTicket");
static_assert(sizeof(UGetMatchmakingTicket) == 0x000078, "Wrong size on UGetMatchmakingTicket");
static_assert(offsetof(UGetMatchmakingTicket, onSuccess) == 0x000030, "Member 'UGetMatchmakingTicket::onSuccess' has a wrong offset!");
static_assert(offsetof(UGetMatchmakingTicket, onFailure) == 0x000040, "Member 'UGetMatchmakingTicket::onFailure' has a wrong offset!");
static_assert(offsetof(UGetMatchmakingTicket, QueueName) == 0x000058, "Member 'UGetMatchmakingTicket::QueueName' has a wrong offset!");
static_assert(offsetof(UGetMatchmakingTicket, TicketId) == 0x000068, "Member 'UGetMatchmakingTicket::TicketId' has a wrong offset!");

// Class Mordhau.GetMatchmakingMatch
// 0x0048 (0x0078 - 0x0030)
class UGetMatchmakingMatch final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(struct FPlayFabMatchmakingMatch& Match)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FPlayFabMatchmakingMatch& Match)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QueueName;                                         // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MatchId;                                           // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGetMatchmakingMatch* GetMatchmakingMatch(const class FString& QueueName_0, const class FString& MatchId_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetMatchmakingMatch">();
	}
	static class UGetMatchmakingMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetMatchmakingMatch>();
	}
};
static_assert(alignof(UGetMatchmakingMatch) == 0x000008, "Wrong alignment on UGetMatchmakingMatch");
static_assert(sizeof(UGetMatchmakingMatch) == 0x000078, "Wrong size on UGetMatchmakingMatch");
static_assert(offsetof(UGetMatchmakingMatch, onSuccess) == 0x000030, "Member 'UGetMatchmakingMatch::onSuccess' has a wrong offset!");
static_assert(offsetof(UGetMatchmakingMatch, onFailure) == 0x000040, "Member 'UGetMatchmakingMatch::onFailure' has a wrong offset!");
static_assert(offsetof(UGetMatchmakingMatch, QueueName) == 0x000058, "Member 'UGetMatchmakingMatch::QueueName' has a wrong offset!");
static_assert(offsetof(UGetMatchmakingMatch, MatchId) == 0x000068, "Member 'UGetMatchmakingMatch::MatchId' has a wrong offset!");

// Class Mordhau.GetGameServers
// 0x0070 (0x00A0 - 0x0030)
class UGetGameServers final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(TArray<struct FPlayFabGameServer>& Servers)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<struct FPlayFabGameServer>& Servers)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameServerFilter                      Filter;                                            // 0x0058(0x0048)(NativeAccessSpecifierPrivate)

public:
	static class UGetGameServers* GetGameServers(const struct FGameServerFilter& Filter_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetGameServers">();
	}
	static class UGetGameServers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetGameServers>();
	}
};
static_assert(alignof(UGetGameServers) == 0x000008, "Wrong alignment on UGetGameServers");
static_assert(sizeof(UGetGameServers) == 0x0000A0, "Wrong size on UGetGameServers");
static_assert(offsetof(UGetGameServers, onSuccess) == 0x000030, "Member 'UGetGameServers::onSuccess' has a wrong offset!");
static_assert(offsetof(UGetGameServers, onFailure) == 0x000040, "Member 'UGetGameServers::onFailure' has a wrong offset!");
static_assert(offsetof(UGetGameServers, Filter) == 0x000058, "Member 'UGetGameServers::Filter' has a wrong offset!");

// Class Mordhau.GetGameServer
// 0x0050 (0x0080 - 0x0030)
class UGetGameServer final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(struct FPlayFabGameServer& Server)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FPlayFabGameServer& Server)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerId;                                          // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 IPV4Address;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Port;                                              // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGetGameServer* GetGameServer(const class FString& ServerId_0, const class FString& IPV4Address_0, int32 Port_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetGameServer">();
	}
	static class UGetGameServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetGameServer>();
	}
};
static_assert(alignof(UGetGameServer) == 0x000008, "Wrong alignment on UGetGameServer");
static_assert(sizeof(UGetGameServer) == 0x000080, "Wrong size on UGetGameServer");
static_assert(offsetof(UGetGameServer, onSuccess) == 0x000030, "Member 'UGetGameServer::onSuccess' has a wrong offset!");
static_assert(offsetof(UGetGameServer, onFailure) == 0x000040, "Member 'UGetGameServer::onFailure' has a wrong offset!");
static_assert(offsetof(UGetGameServer, ServerId) == 0x000058, "Member 'UGetGameServer::ServerId' has a wrong offset!");
static_assert(offsetof(UGetGameServer, IPV4Address) == 0x000068, "Member 'UGetGameServer::IPV4Address' has a wrong offset!");
static_assert(offsetof(UGetGameServer, Port) == 0x000078, "Member 'UGetGameServer::Port' has a wrong offset!");

// Class Mordhau.ReserveServerSlots
// 0x00A0 (0x00D0 - 0x0030)
class UReserveServerSlots final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFull;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              onFailure;                                         // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ConnectString;                                     // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMordhauBeaconClient*                   BeaconClient;                                      // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 World;                                             // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayFabServerDetails                  ServerDetails;                                     // 0x0088(0x0038)(NativeAccessSpecifierPrivate)
	TArray<struct FPlayFabMatchmakingPlayer>      Players;                                           // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UReserveServerSlots* ReserveServerSlots(class UObject* WorldContextObject, const struct FPlayFabServerDetails& ServerDetails_0, const TArray<struct FPlayFabMatchmakingPlayer>& Players_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReserveServerSlots">();
	}
	static class UReserveServerSlots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReserveServerSlots>();
	}
};
static_assert(alignof(UReserveServerSlots) == 0x000008, "Wrong alignment on UReserveServerSlots");
static_assert(sizeof(UReserveServerSlots) == 0x0000D0, "Wrong size on UReserveServerSlots");
static_assert(offsetof(UReserveServerSlots, onSuccess) == 0x000030, "Member 'UReserveServerSlots::onSuccess' has a wrong offset!");
static_assert(offsetof(UReserveServerSlots, OnFull) == 0x000040, "Member 'UReserveServerSlots::OnFull' has a wrong offset!");
static_assert(offsetof(UReserveServerSlots, onFailure) == 0x000050, "Member 'UReserveServerSlots::onFailure' has a wrong offset!");
static_assert(offsetof(UReserveServerSlots, ConnectString) == 0x000068, "Member 'UReserveServerSlots::ConnectString' has a wrong offset!");
static_assert(offsetof(UReserveServerSlots, BeaconClient) == 0x000078, "Member 'UReserveServerSlots::BeaconClient' has a wrong offset!");
static_assert(offsetof(UReserveServerSlots, World) == 0x000080, "Member 'UReserveServerSlots::World' has a wrong offset!");
static_assert(offsetof(UReserveServerSlots, ServerDetails) == 0x000088, "Member 'UReserveServerSlots::ServerDetails' has a wrong offset!");
static_assert(offsetof(UReserveServerSlots, Players) == 0x0000C0, "Member 'UReserveServerSlots::Players' has a wrong offset!");

// Class Mordhau.LeaveMatchmakingMatch
// 0x00E0 (0x0110 - 0x0030)
class ULeaveMatchmakingMatch final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(struct FPlayFabMatchmakingMatch& Match)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FPlayFabMatchmakingMatch& Match)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayFabMatchmakingMatch               Match;                                             // 0x0058(0x00B8)(NativeAccessSpecifierPrivate)

public:
	static class ULeaveMatchmakingMatch* LeaveMatchmakingMatch(const struct FPlayFabMatchmakingMatch& Match_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaveMatchmakingMatch">();
	}
	static class ULeaveMatchmakingMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULeaveMatchmakingMatch>();
	}
};
static_assert(alignof(ULeaveMatchmakingMatch) == 0x000008, "Wrong alignment on ULeaveMatchmakingMatch");
static_assert(sizeof(ULeaveMatchmakingMatch) == 0x000110, "Wrong size on ULeaveMatchmakingMatch");
static_assert(offsetof(ULeaveMatchmakingMatch, onSuccess) == 0x000030, "Member 'ULeaveMatchmakingMatch::onSuccess' has a wrong offset!");
static_assert(offsetof(ULeaveMatchmakingMatch, onFailure) == 0x000040, "Member 'ULeaveMatchmakingMatch::onFailure' has a wrong offset!");
static_assert(offsetof(ULeaveMatchmakingMatch, Match) == 0x000058, "Member 'ULeaveMatchmakingMatch::Match' has a wrong offset!");

// Class Mordhau.StartMatchmakingMatch
// 0x0170 (0x01A0 - 0x0030)
class UStartMatchmakingMatch final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(struct FPlayFabMatchmakingMatch& Match)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FPlayFabMatchmakingMatch& Match)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayFabMatchmakingMatch               Match;                                             // 0x0060(0x00B8)(NativeAccessSpecifierPrivate)
	class FString                                 GroupID;                                           // 0x0118(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 GroupName;                                         // 0x0128(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayFabGroup                          Group;                                             // 0x0138(0x0068)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UStartMatchmakingMatch* StartMatchmakingMatch(class UObject* WorldContextObject, const struct FPlayFabMatchmakingMatch& Match_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartMatchmakingMatch">();
	}
	static class UStartMatchmakingMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartMatchmakingMatch>();
	}
};
static_assert(alignof(UStartMatchmakingMatch) == 0x000008, "Wrong alignment on UStartMatchmakingMatch");
static_assert(sizeof(UStartMatchmakingMatch) == 0x0001A0, "Wrong size on UStartMatchmakingMatch");
static_assert(offsetof(UStartMatchmakingMatch, onSuccess) == 0x000030, "Member 'UStartMatchmakingMatch::onSuccess' has a wrong offset!");
static_assert(offsetof(UStartMatchmakingMatch, onFailure) == 0x000040, "Member 'UStartMatchmakingMatch::onFailure' has a wrong offset!");
static_assert(offsetof(UStartMatchmakingMatch, World) == 0x000058, "Member 'UStartMatchmakingMatch::World' has a wrong offset!");
static_assert(offsetof(UStartMatchmakingMatch, Match) == 0x000060, "Member 'UStartMatchmakingMatch::Match' has a wrong offset!");
static_assert(offsetof(UStartMatchmakingMatch, GroupID) == 0x000118, "Member 'UStartMatchmakingMatch::GroupID' has a wrong offset!");
static_assert(offsetof(UStartMatchmakingMatch, GroupName) == 0x000128, "Member 'UStartMatchmakingMatch::GroupName' has a wrong offset!");
static_assert(offsetof(UStartMatchmakingMatch, Group) == 0x000138, "Member 'UStartMatchmakingMatch::Group' has a wrong offset!");

// Class Mordhau.SetMatchmakingMatchServerDetails
// 0x0118 (0x0148 - 0x0030)
class USetMatchmakingMatchServerDetails final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(struct FPlayFabMatchmakingMatch& Match)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FPlayFabMatchmakingMatch& Match)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayFabMatchmakingMatch               Match;                                             // 0x0058(0x00B8)(NativeAccessSpecifierPrivate)
	struct FPlayFabServerDetails                  ServerDetails;                                     // 0x0110(0x0038)(NativeAccessSpecifierPrivate)

public:
	static class USetMatchmakingMatchServerDetails* SetMatchmakingMatchServerDetails(const struct FPlayFabMatchmakingMatch& Match_0, const struct FPlayFabServerDetails& ServerDetails_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetMatchmakingMatchServerDetails">();
	}
	static class USetMatchmakingMatchServerDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetMatchmakingMatchServerDetails>();
	}
};
static_assert(alignof(USetMatchmakingMatchServerDetails) == 0x000008, "Wrong alignment on USetMatchmakingMatchServerDetails");
static_assert(sizeof(USetMatchmakingMatchServerDetails) == 0x000148, "Wrong size on USetMatchmakingMatchServerDetails");
static_assert(offsetof(USetMatchmakingMatchServerDetails, onSuccess) == 0x000030, "Member 'USetMatchmakingMatchServerDetails::onSuccess' has a wrong offset!");
static_assert(offsetof(USetMatchmakingMatchServerDetails, onFailure) == 0x000040, "Member 'USetMatchmakingMatchServerDetails::onFailure' has a wrong offset!");
static_assert(offsetof(USetMatchmakingMatchServerDetails, Match) == 0x000058, "Member 'USetMatchmakingMatchServerDetails::Match' has a wrong offset!");
static_assert(offsetof(USetMatchmakingMatchServerDetails, ServerDetails) == 0x000110, "Member 'USetMatchmakingMatchServerDetails::ServerDetails' has a wrong offset!");

// Class Mordhau.GetMatchmakingPenalty
// 0x0068 (0x0098 - 0x0030)
class UGetMatchmakingPenalty final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(struct FPlayFabPlayerEntity& PlayerEntity, int32 LeaveCount, const struct FDateTime& LeaveTime, const struct FDateTime& BanEndTime)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FPlayFabPlayerEntity& PlayerEntity, int32 LeaveCount, const struct FDateTime& LeaveTime, const struct FDateTime& BanEndTime)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayFabPlayerEntity                   PlayerEntity;                                      // 0x0058(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 GroupName;                                         // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 GroupID;                                           // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGetMatchmakingPenalty* GetMatchmakingPenalty(const struct FPlayFabPlayerEntity& PlayerEntity_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetMatchmakingPenalty">();
	}
	static class UGetMatchmakingPenalty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetMatchmakingPenalty>();
	}
};
static_assert(alignof(UGetMatchmakingPenalty) == 0x000008, "Wrong alignment on UGetMatchmakingPenalty");
static_assert(sizeof(UGetMatchmakingPenalty) == 0x000098, "Wrong size on UGetMatchmakingPenalty");
static_assert(offsetof(UGetMatchmakingPenalty, onSuccess) == 0x000030, "Member 'UGetMatchmakingPenalty::onSuccess' has a wrong offset!");
static_assert(offsetof(UGetMatchmakingPenalty, onFailure) == 0x000040, "Member 'UGetMatchmakingPenalty::onFailure' has a wrong offset!");
static_assert(offsetof(UGetMatchmakingPenalty, PlayerEntity) == 0x000058, "Member 'UGetMatchmakingPenalty::PlayerEntity' has a wrong offset!");
static_assert(offsetof(UGetMatchmakingPenalty, GroupName) == 0x000078, "Member 'UGetMatchmakingPenalty::GroupName' has a wrong offset!");
static_assert(offsetof(UGetMatchmakingPenalty, GroupID) == 0x000088, "Member 'UGetMatchmakingPenalty::GroupID' has a wrong offset!");

// Class Mordhau.PenalizeForLeavingActiveMatch
// 0x0088 (0x00B8 - 0x0030)
class UPenalizeForLeavingActiveMatch final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(struct FPlayFabPlayerEntity& PlayerEntity)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FPlayFabPlayerEntity& PlayerEntity)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayFabPlayerEntity                   PlayerEntity;                                      // 0x0058(0x0020)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGetMatchmakingPenalty*                 GetMatchmakingPenalty;                             // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 GroupName;                                         // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 GroupID;                                           // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LeaveCount;                                        // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         LeaveTimestamp;                                    // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         BanEndTimestamp;                                   // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UPenalizeForLeavingActiveMatch* PenalizeForLeavingActiveMatch(const struct FPlayFabPlayerEntity& PlayerEntity_0);

	void OnGetMatchmakingPenaltyFailure(const struct FPlayFabPlayerEntity& InPlayerEntity, int32 InLeaveCount, const struct FDateTime& InLeaveTime, const struct FDateTime& InBanEndTime);
	void OnGetMatchmakingPenaltySuccess(const struct FPlayFabPlayerEntity& InPlayerEntity, int32 InLeaveCount, const struct FDateTime& InLeaveTime, const struct FDateTime& InBanEndTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PenalizeForLeavingActiveMatch">();
	}
	static class UPenalizeForLeavingActiveMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPenalizeForLeavingActiveMatch>();
	}
};
static_assert(alignof(UPenalizeForLeavingActiveMatch) == 0x000008, "Wrong alignment on UPenalizeForLeavingActiveMatch");
static_assert(sizeof(UPenalizeForLeavingActiveMatch) == 0x0000B8, "Wrong size on UPenalizeForLeavingActiveMatch");
static_assert(offsetof(UPenalizeForLeavingActiveMatch, onSuccess) == 0x000030, "Member 'UPenalizeForLeavingActiveMatch::onSuccess' has a wrong offset!");
static_assert(offsetof(UPenalizeForLeavingActiveMatch, onFailure) == 0x000040, "Member 'UPenalizeForLeavingActiveMatch::onFailure' has a wrong offset!");
static_assert(offsetof(UPenalizeForLeavingActiveMatch, PlayerEntity) == 0x000058, "Member 'UPenalizeForLeavingActiveMatch::PlayerEntity' has a wrong offset!");
static_assert(offsetof(UPenalizeForLeavingActiveMatch, GetMatchmakingPenalty) == 0x000078, "Member 'UPenalizeForLeavingActiveMatch::GetMatchmakingPenalty' has a wrong offset!");
static_assert(offsetof(UPenalizeForLeavingActiveMatch, GroupName) == 0x000080, "Member 'UPenalizeForLeavingActiveMatch::GroupName' has a wrong offset!");
static_assert(offsetof(UPenalizeForLeavingActiveMatch, GroupID) == 0x000090, "Member 'UPenalizeForLeavingActiveMatch::GroupID' has a wrong offset!");
static_assert(offsetof(UPenalizeForLeavingActiveMatch, LeaveCount) == 0x0000A0, "Member 'UPenalizeForLeavingActiveMatch::LeaveCount' has a wrong offset!");
static_assert(offsetof(UPenalizeForLeavingActiveMatch, LeaveTimestamp) == 0x0000A8, "Member 'UPenalizeForLeavingActiveMatch::LeaveTimestamp' has a wrong offset!");
static_assert(offsetof(UPenalizeForLeavingActiveMatch, BanEndTimestamp) == 0x0000B0, "Member 'UPenalizeForLeavingActiveMatch::BanEndTimestamp' has a wrong offset!");

// Class Mordhau.RequestPartyStats
// 0x0048 (0x0078 - 0x0030)
class URequestPartyStats final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         PlayFabIds;                                        // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bSuccess;                                          // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class URequestPartyStats* RequestPartyStats(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RequestPartyStats">();
	}
	static class URequestPartyStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<URequestPartyStats>();
	}
};
static_assert(alignof(URequestPartyStats) == 0x000008, "Wrong alignment on URequestPartyStats");
static_assert(sizeof(URequestPartyStats) == 0x000078, "Wrong size on URequestPartyStats");
static_assert(offsetof(URequestPartyStats, onSuccess) == 0x000030, "Member 'URequestPartyStats::onSuccess' has a wrong offset!");
static_assert(offsetof(URequestPartyStats, onFailure) == 0x000040, "Member 'URequestPartyStats::onFailure' has a wrong offset!");
static_assert(offsetof(URequestPartyStats, World) == 0x000058, "Member 'URequestPartyStats::World' has a wrong offset!");
static_assert(offsetof(URequestPartyStats, PlayFabIds) == 0x000060, "Member 'URequestPartyStats::PlayFabIds' has a wrong offset!");
static_assert(offsetof(URequestPartyStats, bSuccess) == 0x000070, "Member 'URequestPartyStats::bSuccess' has a wrong offset!");

// Class Mordhau.MeleeWeaponAnimationProfile
// 0x0098 (0x00C0 - 0x0028)
class UMeleeWeaponAnimationProfile : public UObject
{
public:
	TMap<EAttackMove, TSubclassOf<class UMordhauMotion>> Attacks;                                           // 0x0028(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UMordhauMotion>             ParryMotion;                                       // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RightStabBounce;                                   // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LeftStabBounce;                                    // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RightStabBounce1P;                                 // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LeftStabBounce1P;                                  // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RightStrikeBounce;                                 // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LeftStrikeBounce;                                  // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          RightStrikeBounce1P;                               // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LeftStrikeBounce1P;                                // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeleeWeaponAnimationProfile">();
	}
	static class UMeleeWeaponAnimationProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeleeWeaponAnimationProfile>();
	}
};
static_assert(alignof(UMeleeWeaponAnimationProfile) == 0x000008, "Wrong alignment on UMeleeWeaponAnimationProfile");
static_assert(sizeof(UMeleeWeaponAnimationProfile) == 0x0000C0, "Wrong size on UMeleeWeaponAnimationProfile");
static_assert(offsetof(UMeleeWeaponAnimationProfile, Attacks) == 0x000028, "Member 'UMeleeWeaponAnimationProfile::Attacks' has a wrong offset!");
static_assert(offsetof(UMeleeWeaponAnimationProfile, ParryMotion) == 0x000078, "Member 'UMeleeWeaponAnimationProfile::ParryMotion' has a wrong offset!");
static_assert(offsetof(UMeleeWeaponAnimationProfile, RightStabBounce) == 0x000080, "Member 'UMeleeWeaponAnimationProfile::RightStabBounce' has a wrong offset!");
static_assert(offsetof(UMeleeWeaponAnimationProfile, LeftStabBounce) == 0x000088, "Member 'UMeleeWeaponAnimationProfile::LeftStabBounce' has a wrong offset!");
static_assert(offsetof(UMeleeWeaponAnimationProfile, RightStabBounce1P) == 0x000090, "Member 'UMeleeWeaponAnimationProfile::RightStabBounce1P' has a wrong offset!");
static_assert(offsetof(UMeleeWeaponAnimationProfile, LeftStabBounce1P) == 0x000098, "Member 'UMeleeWeaponAnimationProfile::LeftStabBounce1P' has a wrong offset!");
static_assert(offsetof(UMeleeWeaponAnimationProfile, RightStrikeBounce) == 0x0000A0, "Member 'UMeleeWeaponAnimationProfile::RightStrikeBounce' has a wrong offset!");
static_assert(offsetof(UMeleeWeaponAnimationProfile, LeftStrikeBounce) == 0x0000A8, "Member 'UMeleeWeaponAnimationProfile::LeftStrikeBounce' has a wrong offset!");
static_assert(offsetof(UMeleeWeaponAnimationProfile, RightStrikeBounce1P) == 0x0000B0, "Member 'UMeleeWeaponAnimationProfile::RightStrikeBounce1P' has a wrong offset!");
static_assert(offsetof(UMeleeWeaponAnimationProfile, LeftStrikeBounce1P) == 0x0000B8, "Member 'UMeleeWeaponAnimationProfile::LeftStrikeBounce1P' has a wrong offset!");

// Class Mordhau.MeleeWeaponComponent
// 0x0000 (0x00B0 - 0x00B0)
class UMeleeWeaponComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeleeWeaponComponent">();
	}
	static class UMeleeWeaponComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeleeWeaponComponent>();
	}
};
static_assert(alignof(UMeleeWeaponComponent) == 0x000008, "Wrong alignment on UMeleeWeaponComponent");
static_assert(sizeof(UMeleeWeaponComponent) == 0x0000B0, "Wrong size on UMeleeWeaponComponent");

// Class Mordhau.Mods
// 0x0000 (0x0028 - 0x0028)
class UMods final : public UObject
{
public:
	static void CancelModDownload(int32 ModId);
	static TArray<struct FInstalledMod> GetAllInstalledMods();
	static struct FInstalledMod GetInstalledMod(int32 ModId);
	static TArray<struct FQueuedModDownload> GetModDownloadQueue();
	static bool IsModMounted(int32 ModId);
	static void MountAllInstalledMods();
	static int32 MountAllPaksInCustomPakFolder();
	static bool MountMod(int32 ModId);
	static void MountMods(const TArray<int32>& ModIds);
	static void Process();
	static bool UninstallMod(int32 ModId);
	static bool UnmountMod(int32 ModId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mods">();
	}
	static class UMods* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMods>();
	}
};
static_assert(alignof(UMods) == 0x000008, "Wrong alignment on UMods");
static_assert(sizeof(UMods) == 0x000028, "Wrong size on UMods");

// Class Mordhau.DownloadModfilesById
// 0x0030 (0x0060 - 0x0030)
class UDownloadModfilesById final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 ResponseCode, bool bModsAreUpdated)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 ResponseCode, bool bModsAreUpdated)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDownloadModfilesById* DownloadModfilesById(const TArray<int32>& ModIds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownloadModfilesById">();
	}
	static class UDownloadModfilesById* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownloadModfilesById>();
	}
};
static_assert(alignof(UDownloadModfilesById) == 0x000008, "Wrong alignment on UDownloadModfilesById");
static_assert(sizeof(UDownloadModfilesById) == 0x000060, "Wrong size on UDownloadModfilesById");
static_assert(offsetof(UDownloadModfilesById, onSuccess) == 0x000030, "Member 'UDownloadModfilesById::onSuccess' has a wrong offset!");
static_assert(offsetof(UDownloadModfilesById, onFailure) == 0x000040, "Member 'UDownloadModfilesById::onFailure' has a wrong offset!");

// Class Mordhau.Mordhau1DVehicle
// 0x0000 (0x0B90 - 0x0B90)
class AMordhau1DVehicle : public AMordhauVehicle
{
public:
	float                                         LastRequestedLeaveTime;                            // 0x0B88(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaveVehicleWhenTryingToStepOutsideLine;          // 0x0B8C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8D[0x3];                                      // 0x0B8D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStepChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mordhau1DVehicle">();
	}
	static class AMordhau1DVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhau1DVehicle>();
	}
};
static_assert(alignof(AMordhau1DVehicle) == 0x000010, "Wrong alignment on AMordhau1DVehicle");
static_assert(sizeof(AMordhau1DVehicle) == 0x000B90, "Wrong size on AMordhau1DVehicle");
static_assert(offsetof(AMordhau1DVehicle, LastRequestedLeaveTime) == 0x000B88, "Member 'AMordhau1DVehicle::LastRequestedLeaveTime' has a wrong offset!");
static_assert(offsetof(AMordhau1DVehicle, bLeaveVehicleWhenTryingToStepOutsideLine) == 0x000B8C, "Member 'AMordhau1DVehicle::bLeaveVehicleWhenTryingToStepOutsideLine' has a wrong offset!");

// Class Mordhau.MordhauAIController
// 0x02E0 (0x0608 - 0x0328)
class AMordhauAIController : public AAIController
{
public:
	uint8                                         Pad_328[0x14];                                     // 0x0328(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  FacingActor;                                       // 0x033C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class USkeletalMeshComponent>  FacingSkelMesh;                                    // 0x0344(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FacingBone;                                        // 0x034C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x24];                                     // 0x0354(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UAISenseConfig_Sight*                   SightConfig;                                       // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAISenseConfig_Hearing*                 HearingConfig;                                     // 0x0380(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAISenseConfig_Damage*                  DamageConfig;                                      // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x50];                                     // 0x0390(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               DesiredControlRotationOverride;                    // 0x03E0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauCharacter>       ReallyCloseEnemyCached;                            // 0x03EC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauCharacter>       LastClosestEnemy;                                  // 0x03F4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClosestEnemySaturated;                          // 0x03FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FD[0xB];                                      // 0x03FD(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AMordhauCharacter>       ClosestEnemyOverride;                              // 0x0408(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class AMordhauCharacter*>                ClosestEnemyIgnoreSet;                             // 0x0410(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bFirstRun;                                         // 0x0460(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_461[0x3];                                      // 0x0461(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LODDeltaTime;                                      // 0x0464(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomFloat;                                       // 0x0468(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBotProfile*                            BotProfile;                                        // 0x0470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBotProfile>                DefaultBotProfile;                                 // 0x0478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBotBehaviorProfile*                    BehaviorProfile;                                   // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_488[0xC];                                      // 0x0488(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationInterpolationTime;                         // 0x0494(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterProfile                      CharacterProfile;                                  // 0x0498(0x00B8)(NativeAccessSpecifierPublic)
	class ACustomizationReplicationActor*         CustomizationReplicationActor;                     // 0x0550(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePassedCustomizationReplicationActor;           // 0x0558(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_559[0x3];                                      // 0x0559(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnemyScanInterval;                                 // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyScanIntervalVariance;                         // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoRespawn;                                      // 0x0564(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsRespawn;                                     // 0x0565(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_566[0x2];                                      // 0x0566(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NextRespawnTime;                                   // 0x0568(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWants1DMovementBackwards;                         // 0x056C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56D[0x3];                                      // 0x056D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DesiredClimbTarget;                                // 0x0570(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAnticipateTurns;                            // 0x057C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableObstacleAvoidance;                          // 0x057D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSeparation;                                 // 0x057E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableOptimizeVisibility;                         // 0x057F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableOptimizeTopology;                           // 0x0580(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePathOffset;                                 // 0x0581(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSlowdownAtGoal;                             // 0x0582(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_583[0x1];                                      // 0x0583(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SeparationWeight;                                  // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionQueryRange;                               // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathOptimizationRange;                             // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceRangeMultiplier;                          // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrowdAvoidanceQuality                        AvoidanceQuality;                                  // 0x0594(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrowdSimulationState                         SimulationState;                                   // 0x0595(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_596[0x2];                                      // 0x0596(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     DefaultNavQueryFilter;                             // 0x0598(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     Team1NavQueryFilter;                               // 0x05A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     Team2NavQueryFilter;                               // 0x05A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     NoLadderNavQueryFilter;                            // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x48];                                     // 0x05B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MidPointAcceptanceRadius;                          // 0x0600(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_604[0x4];                                      // 0x0604(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyController();
	int32 GetAllyClearanceSides();
	class AMordhauCharacter* GetClosestAlly();
	class AMordhauCharacter* GetClosestEnemy();
	class AMordhauCharacter* GetClosestEnemyOverride();
	class AActor* GetCurrentlyFacingActor();
	class AMordhauCharacter* GetKthClosestOfThree(int32 Idx);
	float GetMotionBasedRandom();
	const TArray<class AMordhauCharacter*> GetPerceivedAllies();
	const TArray<class AMordhauCharacter*> GetPerceivedEnemies();
	int32 GetTeam();
	EPathFollowingRequestResult MoveToLocationWithRandomMidpoint(const struct FVector& Dest, float AcceptanceRadius, bool bStopOnOverlap, bool bUsePathfinding, bool bProjectDestinationToNavigation, bool bCanStrafe, TSubclassOf<class UNavigationQueryFilter> FilterClass, bool bAllowPartialPath);
	void OnAfterUnPossess();
	void OnCharacterDiedOrDestroyed(class AAdvancedCharacter* AdvancedCharacter);
	void OnPerceptionUpdated(const TArray<class AActor*>& InUpdatedActors);
	void OnStartedPerceivingCharacter(class AAdvancedCharacter* PerceivedCharacter, const struct FPerceptionInfo& PerceptionInfo);
	void OnStoppedPerceivingCharacter(class AAdvancedCharacter* PerceivedCharacter, const struct FPerceptionInfo& PerceptionInfo);
	void PauseLogic(const class FString& Reason);
	bool PerceivesAlly();
	bool PerceivesEnemy();
	void RefreshCharacterProfile();
	void RequestVoiceCommand(uint8 Command);
	void ResumeLogic(const class FString& Reason);
	void SetClosestEnemyOverride(class AMordhauCharacter* Override);
	void StartFacingActor(class AActor* Actor, float LocationUpOffset, const struct FVector2D& DegreeOffset);
	void StartFacingActor2D(class AActor* Actor, float LocationUpOffset);
	void StartFacingBone(class USkeletalMeshComponent* SkelMesh, class FName BoneToFace, float LocationUpOffset, const struct FVector2D& DegreeOffset);
	void StartFacingLocation(const struct FVector& WorldLocation);
	void StartFacingMovement(float LocationUpOffset);
	void StartInteract(class AActor* Target);
	void StopInteract();
	void UpdatePerceptionInfo(class AAdvancedCharacter* InCharacter, struct FPerceptionInfo* PerceptionInfo);

	bool CanInteract(class AActor* Target) const;
	bool CanSee(class AActor* Target, float Distance) const;
	EAIFacingMode GetCurrentFacingMode() const;
	struct FVector GetMoveMidpoint(const struct FVector& Goal, class ANavigationData* NavData, TSubclassOf<class UNavigationQueryFilter> FilterClass) const;
	bool IsMovePending() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauAIController">();
	}
	static class AMordhauAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauAIController>();
	}
};
static_assert(alignof(AMordhauAIController) == 0x000008, "Wrong alignment on AMordhauAIController");
static_assert(sizeof(AMordhauAIController) == 0x000608, "Wrong size on AMordhauAIController");
static_assert(offsetof(AMordhauAIController, FacingActor) == 0x00033C, "Member 'AMordhauAIController::FacingActor' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, FacingSkelMesh) == 0x000344, "Member 'AMordhauAIController::FacingSkelMesh' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, FacingBone) == 0x00034C, "Member 'AMordhauAIController::FacingBone' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, SightConfig) == 0x000378, "Member 'AMordhauAIController::SightConfig' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, HearingConfig) == 0x000380, "Member 'AMordhauAIController::HearingConfig' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, DamageConfig) == 0x000388, "Member 'AMordhauAIController::DamageConfig' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, DesiredControlRotationOverride) == 0x0003E0, "Member 'AMordhauAIController::DesiredControlRotationOverride' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, ReallyCloseEnemyCached) == 0x0003EC, "Member 'AMordhauAIController::ReallyCloseEnemyCached' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, LastClosestEnemy) == 0x0003F4, "Member 'AMordhauAIController::LastClosestEnemy' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, bIsClosestEnemySaturated) == 0x0003FC, "Member 'AMordhauAIController::bIsClosestEnemySaturated' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, ClosestEnemyOverride) == 0x000408, "Member 'AMordhauAIController::ClosestEnemyOverride' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, ClosestEnemyIgnoreSet) == 0x000410, "Member 'AMordhauAIController::ClosestEnemyIgnoreSet' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, bFirstRun) == 0x000460, "Member 'AMordhauAIController::bFirstRun' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, LODDeltaTime) == 0x000464, "Member 'AMordhauAIController::LODDeltaTime' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, RandomFloat) == 0x000468, "Member 'AMordhauAIController::RandomFloat' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, BotProfile) == 0x000470, "Member 'AMordhauAIController::BotProfile' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, DefaultBotProfile) == 0x000478, "Member 'AMordhauAIController::DefaultBotProfile' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, BehaviorProfile) == 0x000480, "Member 'AMordhauAIController::BehaviorProfile' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, RotationInterpolationTime) == 0x000494, "Member 'AMordhauAIController::RotationInterpolationTime' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, CharacterProfile) == 0x000498, "Member 'AMordhauAIController::CharacterProfile' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, CustomizationReplicationActor) == 0x000550, "Member 'AMordhauAIController::CustomizationReplicationActor' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, bUsePassedCustomizationReplicationActor) == 0x000558, "Member 'AMordhauAIController::bUsePassedCustomizationReplicationActor' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, EnemyScanInterval) == 0x00055C, "Member 'AMordhauAIController::EnemyScanInterval' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, EnemyScanIntervalVariance) == 0x000560, "Member 'AMordhauAIController::EnemyScanIntervalVariance' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, bAutoRespawn) == 0x000564, "Member 'AMordhauAIController::bAutoRespawn' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, bWantsRespawn) == 0x000565, "Member 'AMordhauAIController::bWantsRespawn' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, NextRespawnTime) == 0x000568, "Member 'AMordhauAIController::NextRespawnTime' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, bWants1DMovementBackwards) == 0x00056C, "Member 'AMordhauAIController::bWants1DMovementBackwards' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, DesiredClimbTarget) == 0x000570, "Member 'AMordhauAIController::DesiredClimbTarget' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, bEnableAnticipateTurns) == 0x00057C, "Member 'AMordhauAIController::bEnableAnticipateTurns' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, bEnableObstacleAvoidance) == 0x00057D, "Member 'AMordhauAIController::bEnableObstacleAvoidance' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, bEnableSeparation) == 0x00057E, "Member 'AMordhauAIController::bEnableSeparation' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, bEnableOptimizeVisibility) == 0x00057F, "Member 'AMordhauAIController::bEnableOptimizeVisibility' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, bEnableOptimizeTopology) == 0x000580, "Member 'AMordhauAIController::bEnableOptimizeTopology' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, bEnablePathOffset) == 0x000581, "Member 'AMordhauAIController::bEnablePathOffset' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, bEnableSlowdownAtGoal) == 0x000582, "Member 'AMordhauAIController::bEnableSlowdownAtGoal' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, SeparationWeight) == 0x000584, "Member 'AMordhauAIController::SeparationWeight' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, CollisionQueryRange) == 0x000588, "Member 'AMordhauAIController::CollisionQueryRange' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, PathOptimizationRange) == 0x00058C, "Member 'AMordhauAIController::PathOptimizationRange' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, AvoidanceRangeMultiplier) == 0x000590, "Member 'AMordhauAIController::AvoidanceRangeMultiplier' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, AvoidanceQuality) == 0x000594, "Member 'AMordhauAIController::AvoidanceQuality' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, SimulationState) == 0x000595, "Member 'AMordhauAIController::SimulationState' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, DefaultNavQueryFilter) == 0x000598, "Member 'AMordhauAIController::DefaultNavQueryFilter' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, Team1NavQueryFilter) == 0x0005A0, "Member 'AMordhauAIController::Team1NavQueryFilter' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, Team2NavQueryFilter) == 0x0005A8, "Member 'AMordhauAIController::Team2NavQueryFilter' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, NoLadderNavQueryFilter) == 0x0005B0, "Member 'AMordhauAIController::NoLadderNavQueryFilter' has a wrong offset!");
static_assert(offsetof(AMordhauAIController, MidPointAcceptanceRadius) == 0x000600, "Member 'AMordhauAIController::MidPointAcceptanceRadius' has a wrong offset!");

// Class Mordhau.MordhauAnimInstance
// 0x0AF0 (0x0EC0 - 0x03D0)
class UMordhauAnimInstance : public UCreatureAnimInstance
{
public:
	int32                                         CreatedFrame;                                      // 0x03D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastUpdateFrame;                                   // 0x03D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InternalScaledTimeSeconds;                         // 0x03D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshRelativeZScale;                                // 0x03DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimNodePackedFaceCustomization       FaceCustomization;                                 // 0x03E0(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAnimNodePackedDismemberment           Dismemberment;                                     // 0x0400(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauEquipment>       PreviousRightHandEquipment;                        // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauEquipment>       MainEquipmentPtr;                                  // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MainAnimationType;                                 // 0x0420(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasRagdollFalling;                                // 0x0428(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_429[0x3];                                      // 0x0429(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastRagdollFallingTime;                            // 0x042C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPerformInstantAnimSwitch;                   // 0x0430(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_431[0x1];                                      // 0x0431(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsGetUpFront;                                     // 0x0432(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_433[0x1];                                      // 0x0433(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GetUpAnimationDuration;                            // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               GetUpRotation;                                     // 0x0438(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         DeathSyncedRandom;                                 // 0x0444(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_445[0x3];                                      // 0x0445(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IsDedicatedServer;                                 // 0x0448(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimLOD0;                                          // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimLOD1;                                          // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecentlyRendered;                                  // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecentlyRenderedNonAuth;                           // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45C[0x8];                                      // 0x045C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimLOD0Distance;                                  // 0x0464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimLOD1Distance;                                  // 0x0468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsFemale;                                          // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_470[0x3];                                      // 0x0470(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsClimbingA;                                      // 0x0473(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClimbOffsetA;                                      // 0x0474(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClimbOffsetEndOffsetA;                             // 0x0480(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClimbLedgeOffsetA;                                 // 0x048C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsSlowClimbingA;                                   // 0x0498(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ClimbRotationA;                                    // 0x049C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsClimbingB;                                      // 0x04A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A9[0x3];                                      // 0x04A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ClimbOffsetB;                                      // 0x04AC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClimbOffsetEndOffsetB;                             // 0x04B8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClimbLedgeOffsetB;                                 // 0x04C4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ClimbRotationB;                                    // 0x04D0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IsSlowClimbingB;                                   // 0x04DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastSmoothedIsCrouching;                           // 0x04E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnclampedFastSmoothedIsCrouching;                  // 0x04E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatSpringState                      CrouchSpringState;                                 // 0x04E8(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         ServerCrouchSpeed;                                 // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CrouchSpringLimits;                                // 0x04F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchSpringStiffness;                             // 0x04FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UncrouchSpringStiffness;                           // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchSpringDamping;                               // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchSpringMass;                                  // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50C[0x4];                                      // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          VehicleTransitionAnimation;                        // 0x0510(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleTransitionBlendWeight;                      // 0x0518(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VehicleTransitionComponentLocation;                // 0x051C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               VehicleTransitionComponentRotation;                // 0x0528(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IsDrivingFloat;                                    // 0x0534(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_538[0x4];                                      // 0x0538(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LowerBodyRotationOffset;                           // 0x053C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_548[0x4];                                      // 0x0548(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Direction;                                         // 0x054C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MovementCorrectionHips;                            // 0x0550(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MovementCorrectionHipsInterpSpeed;                 // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementCorrectionAnimRate;                        // 0x0560(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionWithOffset;                               // 0x0564(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionOffset;                                   // 0x0568(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionOffsetSlowInterpSpeed;                    // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionOffsetSlow;                               // 0x0570(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_574[0x8];                                      // 0x0574(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Velocity;                                          // 0x057C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmoothedVelocity;                                  // 0x0580(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OneToZeroAtWalkSpeed;                              // 0x0584(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_588[0x4];                                      // 0x0588(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimRateFactor1PMaxSprint;                         // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeedScale;                                // 0x0590(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementAnimRate;                                  // 0x0594(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedWarping;                                      // 0x0598(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdPersonVelocity;                               // 0x059C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBackBlendSpace;                                // 0x05A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A1[0x3];                                      // 0x05A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               StopBounce;                                        // 0x05A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               StopBounceWorld;                                   // 0x05B0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StopBounceLimit;                                   // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BounceInterpSpeedIn;                               // 0x05C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BounceInterpSpeedOut;                              // 0x05C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BounceDuck;                                        // 0x05D0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceDuckLimit;                                   // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x18];                                     // 0x05E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlowVelocityLagTime;                               // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5FC[0x18];                                     // 0x05FC(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FastVelocityLagTime;                               // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTiltFactor;                                    // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopDuckFactor;                                    // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularVelocityInterpSpeed;                        // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularVelocity;                                   // 0x0624(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbsoluteAngularVelocityLowerBody;                  // 0x0628(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngularVelocityLowerBody;                          // 0x0630(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngularVelocityLowerBodyWindow;                    // 0x0638(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63C[0x4];                                      // 0x063C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AnimatedMovementDirectionInCompSpace;              // 0x0640(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularVelocityPitch;                              // 0x064C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpringPitchYawValue;                               // 0x0650(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatSpringState                      PitchSpringState;                                  // 0x0658(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatSpringState                      YawSpringState;                                    // 0x0660(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              SpringPitchYawStiffness;                           // 0x0668(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpringPitchYawDamping;                             // 0x0670(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpringPitchYawMass;                                // 0x0678(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandSpringWeight;                                  // 0x0680(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsFirstPerson;                                    // 0x0688(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_689[0x3];                                      // 0x0689(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IsFirstPersonFloat;                                // 0x068C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsNotFirstPersonFloat;                             // 0x0690(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraCollisionOffset;                             // 0x0694(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             RightWeaponBoneBaseTransform;                      // 0x06A0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                WeaponSlideVector;                                 // 0x06D0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WeaponSlideVectorInverse;                          // 0x06DC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E8[0x4];                                      // 0x06E8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponSlideCompensationWeight;                     // 0x06EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightShoulderOffset1P;                             // 0x06F0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftShoulderOffset1P;                              // 0x06FC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderOffset1PWeight;                            // 0x0708(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftShoulderIdleOffset1P;                          // 0x070C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIKOffset;                                 // 0x0718(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightHandIKOffsetWeight;                           // 0x0724(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffhandIKWeight;                                   // 0x0728(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72C[0x4];                                      // 0x072C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OffhandSlidingAxis;                                // 0x0730(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsOffhandFixedTarget;                             // 0x0760(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_761[0x3];                                      // 0x0761(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OffhandFixedTargetVector;                          // 0x0764(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftHandGripPosition;                              // 0x0770(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandGripPosition;                             // 0x077C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandGripRotation;                             // 0x0788(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         OffhandIsRightHand;                                // 0x0794(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          JumpAnimation;                                     // 0x0798(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FallingAnimation;                                  // 0x07A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LandAnimation;                                     // 0x07A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B0[0x18];                                     // 0x07B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BouncyMagnitudeOffset;                             // 0x07C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BouncySlowVelocityLagTime;                         // 0x07CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D0[0x18];                                     // 0x07D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BouncyFastVelocityLagTime;                         // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7EC[0x4];                                      // 0x07EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          SkinnyPose;                                        // 0x07F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FatPose;                                           // 0x07F8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StrongPose;                                        // 0x0800(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          NormalPose;                                        // 0x0808(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BouncyInterpSpeed;                                 // 0x0810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BouncyFactorBreasts;                               // 0x0814(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BouncyFactorArms;                                  // 0x0818(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BouncyFactorBelly;                                 // 0x081C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BouncyFactorLegs;                                  // 0x0820(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BreastsT;                                          // 0x0824(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LowerBackBellyT;                                   // 0x0830(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpineAdjustT;                                      // 0x083C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftArmAdjustT;                                    // 0x0848(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightArmAdjustT;                                   // 0x0854(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftUpLegAdjustT;                                  // 0x0860(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightUpLegAdjustT;                                 // 0x086C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsTankFloat;                                       // 0x0878(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsDwarfFloat;                                      // 0x087C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DwarfSlowerAnimSpeedFactor;                        // 0x0880(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fat;                                               // 0x0884(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Skinny;                                            // 0x0888(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strong;                                            // 0x088C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsHeadDismembered;                                 // 0x0890(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NeckDismemberedRotation;                           // 0x0894(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LeftShoulderDismemberedRotation;                   // 0x08A0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IsLeftArmDismembered;                              // 0x08AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightShoulderDismemberedRotation;                  // 0x08B0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IsRightArmDismembered;                             // 0x08BC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IsAnythingDismembered;                             // 0x08C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackingWeight;                                    // 0x08C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C8[0x4];                                      // 0x08C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LookingAtRotationNeck;                             // 0x08CC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LookingAtRotationHead;                             // 0x08D8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LookingAtRotationEyes;                             // 0x08E4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HideEars;                                          // 0x08F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideNose;                                          // 0x08F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BreathCurve;                                       // 0x08F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HealthToBreathDuration;                            // 0x0900(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Breath;                                            // 0x0908(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90C[0x10];                                     // 0x090C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CounterCompensateLookWeight;                       // 0x091C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_920[0xC];                                      // 0x0920(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CounterCompensateRotation;                         // 0x092C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LookUpValue;                                       // 0x0938(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightLegBendBlendWeight;                           // 0x093C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpineBendBlendWeight;                              // 0x0940(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpineArmsCompensationFactor;                       // 0x0944(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnValue;                                         // 0x0948(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftHandIsEmpty;                                   // 0x094C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtmosphericsWeight;                                // 0x0950(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Arms3PSyncWeight;                                  // 0x0954(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_958[0x8];                                      // 0x0958(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlockDirection;                                    // 0x0960(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisarmDirection;                                   // 0x0964(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpineSpaceAdditive                    SpineSpaceAdditive;                                // 0x0968(0x0084)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LeftTorsoBlendWeight;                              // 0x09EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          AttackBounce;                                      // 0x09F0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        RangedDrawnAdditive;                               // 0x09F8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SwayRotation;                                      // 0x0A00(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SwayWeight;                                        // 0x0A0C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        ParryAdditive;                                     // 0x0A10(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        ParryPushAdditive;                                 // 0x0A18(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        AltParryPushAdditive;                              // 0x0A20(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerBodyBlendSpaceBlendTime;                      // 0x0A28(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2C[0x4];                                      // 0x0A2C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        UpperBlendSpaceA;                                  // 0x0A30(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBlendSpaceABlendTime;                         // 0x0A38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3C[0x4];                                      // 0x0A3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          UpperAdditiveA;                                    // 0x0A40(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        UpperBlendSpaceB;                                  // 0x0A48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperBlendSpaceBBlendTime;                         // 0x0A50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A54[0x4];                                      // 0x0A54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          UpperAdditiveB;                                    // 0x0A58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurrentUpperA;                                  // 0x0A60(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A61[0x7];                                      // 0x0A61(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          LowerBodyAnimationA;                               // 0x0A68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LowerBodyAnimationB;                               // 0x0A70(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HorseUpperRearing;                                 // 0x0A78(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurrentLowerA;                                  // 0x0A80(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHorseRearing;                                   // 0x0A81(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A82[0x2];                                      // 0x0A82(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Couching;                                          // 0x0A84(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rearing;                                           // 0x0A88(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lean;                                              // 0x0A8C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleAnimTime;                                   // 0x0A90(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleAnimRate;                                   // 0x0A94(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VehicleLeftHandTarget;                             // 0x0A98(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VehicleRightHandTarget;                            // 0x0AA4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleTurn;                                       // 0x0AB0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleLookUp;                                     // 0x0AB4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VehicleLeftFootTarget;                             // 0x0AB8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VehicleRightFootTarget;                            // 0x0AC4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               VehicleLeftFootRotation;                           // 0x0AD0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               VehicleRightFootRotation;                          // 0x0ADC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         VehicleVelocity;                                   // 0x0AE8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleDirection;                                  // 0x0AEC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VehicleSeat;                                       // 0x0AF0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               VehicleActorRotation;                              // 0x0AFC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               VehicleRotationOffset;                             // 0x0B08(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               VehicleSeatRotation;                               // 0x0B14(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBallistaReloading;                                // 0x0B20(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B21[0x3];                                      // 0x0B21(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitEffectIKWeight;                                 // 0x0B24(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEffectLocationSlideSpeed;                       // 0x0B28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEffectDisableSpeed;                             // 0x0B2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitEffectIKLocation;                               // 0x0B30(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitEffectIKLocationStart;                          // 0x0B3C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HitEffectRotation;                                 // 0x0B48(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               HitEffectRotationStart;                            // 0x0B54(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B60[0x4];                                      // 0x0B60(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlinchFreezeBlendInDuration;                       // 0x0B64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchFreezeRotationBlendInSpeed;                  // 0x0B68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchFreezeTranslationBlendInSpeed;               // 0x0B6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchFreezeBlendInAlpha;                          // 0x0B70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchBlendInDuration;                             // 0x0B74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchRotationBlendInSpeed;                        // 0x0B78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchTranslationBlendInSpeed;                     // 0x0B7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchRotationBlendOutSpeed;                       // 0x0B80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchTranslationBlendOutSpeed;                    // 0x0B84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchRotationBlendOutSpeedFast;                   // 0x0B88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchTranslationBlendOutSpeedFast;                // 0x0B8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchPitchAmount;                                 // 0x0B90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchYawAmount;                                   // 0x0B94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchPitchYawFactor;                              // 0x0B98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchHipsZFactor;                                 // 0x0B9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponDirHipsZFactor;                              // 0x0BA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TranslationNonHipsFactor;                          // 0x0BA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FlinchRotationTarget;                              // 0x0BA8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                FlinchTranslationTarget;                           // 0x0BB4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FlinchHipsTranslationTarget;                       // 0x0BC0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FlinchHitSpineIdx;                                 // 0x0BCC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchStartTime;                                   // 0x0BD0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CurrentFlinchSpineRotationsCombined;               // 0x0BD4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               HipsFlinchRotation;                                // 0x0BE0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                HipsFlinchTranslation;                             // 0x0BEC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HipsFlinchTranslationInternal;                     // 0x0BF8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LowerBackFlinchRotation;                           // 0x0C04(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LowerBackFlinchTranslation;                        // 0x0C10(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpineFlinchRotation;                               // 0x0C1C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SpineFlinchTranslation;                            // 0x0C28(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Spine1FlinchRotation;                              // 0x0C34(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Spine1FlinchTranslation;                           // 0x0C40(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NeckFlinchRotation;                                // 0x0C4C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                NeckFlinchTranslation;                             // 0x0C58(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HeadFlinchRotation;                                // 0x0C64(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                HeadFlinchTranslation;                             // 0x0C70(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_WeaponSlideVectorIsNonzero;                 // 0x0C7C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_UBCrouchAlpha;                              // 0x0C80(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_LBCrouchAlpha;                              // 0x0C84(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_UBCrouchSpine;                              // 0x0C88(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_UBCrouchForearms;                           // 0x0C94(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_UBCrouchArms;                               // 0x0CA0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_UBCrouchHead;                               // 0x0CAC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_UBCrouchShoulder;                           // 0x0CB8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Helper_UBSpineArmsCompensationAlpha;               // 0x0CC4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_UBSpineArmsCompensationRotator;             // 0x0CC8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHelper_LBFootShuffling;                           // 0x0CD4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD5[0x3];                                      // 0x0CD5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Helper_LBFootShufflingPlayRate;                    // 0x0CD8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHelper_LBFootShufflingRight;                      // 0x0CDC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CDD[0x3];                                      // 0x0CDD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Helper_LBDirectionOffsetSlowRotator;               // 0x0CE0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_LBDirectionOffsetSlowRotatorInverse;        // 0x0CEC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Helper_LBDirectionOffsetSlowHipsZ;                 // 0x0CF8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Helper_LBDirectionOffsetSlowHipsZInverse;          // 0x0D04(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_LBDirectionOffsetSlowFootRotationOffset;    // 0x0D10(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Helper_UBVelocity;                                 // 0x0D1C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHelper_LBVelocityIsZero;                          // 0x0D20(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D21[0x3];                                      // 0x0D21(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Helper_LBCrouchOffset;                             // 0x0D24(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Helper_LBCrouchOffsetInverse;                      // 0x0D30(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_LBHipsZOverrideAlpha;                       // 0x0D3C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_TrackingWeightAlpha;                        // 0x0D40(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_BreathAlpha;                                // 0x0D44(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_IsNotDrivingFloat;                          // 0x0D48(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_IsAnyFlinchValueNonZero;                    // 0x0D4C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Helper_HipsFlinchTranslationInverse;               // 0x0D50(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_HipsFlinchRotationInverse;                  // 0x0D5C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_ArmsShoulderFlinchInverse;                  // 0x0D68(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Helper_FirstPersonNotDead;                         // 0x0D74(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Helper_FirstPersonZoomOffsetAndCollision;          // 0x0D78(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Helper_CameraCollisionOffsetWithNot3PArmsSync;     // 0x0D84(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_FirstPersonNotDeadWith3PArmsSync;           // 0x0D90(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_IsNotFemale;                                // 0x0D94(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_SpineBendBlendWeightHalf;                   // 0x0D98(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_SpineBendBlendWeightThird;                  // 0x0D9C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_GroundingRightFootRotationOffset;           // 0x0DA0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_GroundingLeftFootRotationOffset;            // 0x0DAC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Helper_GroundingRightFootTranslationOffset;        // 0x0DB8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Helper_GroundingLeftFootTranslationOffset;         // 0x0DC4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_GroundingWeightWithFirstPerson;             // 0x0DD0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_GroundingWeightWithNotFirstPerson;          // 0x0DD4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotFirstPersonWithAtmospherics;                    // 0x0DD8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NotFirstPersonWithAtmosphericsAndAnimLOD1;         // 0x0DDC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_FaceUpperLids;                              // 0x0DE0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Helper_LeftHandIKWeight;                           // 0x0DEC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_RightHandIKWeight;                          // 0x0DF0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_RootRotationOffsetInverse;                  // 0x0DF4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Helper_StopBounceMediumWeight;                     // 0x0E00(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_StopBounceLightWeight;                      // 0x0E04(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_StopBounceInverse;                          // 0x0E08(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_StopBounceInverseHead;                      // 0x0E14(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_StopBounceHips;                             // 0x0E20(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Helper_BounceDuckWithBounceWeight;                 // 0x0E2C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Helper_BounceDuckWithBounceWeightInverse;          // 0x0E38(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_SpineBendRotation;                          // 0x0E44(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_HipsBendRotation;                           // 0x0E50(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Helper_SpineBendRotationAlpha;                     // 0x0E5C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_RightLegBendRotation;                       // 0x0E60(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_ArmsBendRotation;                           // 0x0E6C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AtmosphericsWeightWithAnimLOD0;                    // 0x0E78(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_LowerBodyRotationOffsetInverse;             // 0x0E7C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Helper_RightWeaponBoneBaseTranslation;             // 0x0E88(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_RightWeaponBoneBaseRotation;                // 0x0E94(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Helper_SpringPitchYawValueRotator;                 // 0x0EA0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Helper_HandSpringWeight;                           // 0x0EAC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Helper_ShoulderOffset1PWith1PWeight;               // 0x0EB0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EB4[0xC];                                      // 0x0EB4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauAnimInstance">();
	}
	static class UMordhauAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauAnimInstance>();
	}
};
static_assert(alignof(UMordhauAnimInstance) == 0x000010, "Wrong alignment on UMordhauAnimInstance");
static_assert(sizeof(UMordhauAnimInstance) == 0x000EC0, "Wrong size on UMordhauAnimInstance");
static_assert(offsetof(UMordhauAnimInstance, CreatedFrame) == 0x0003D0, "Member 'UMordhauAnimInstance::CreatedFrame' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LastUpdateFrame) == 0x0003D4, "Member 'UMordhauAnimInstance::LastUpdateFrame' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, InternalScaledTimeSeconds) == 0x0003D8, "Member 'UMordhauAnimInstance::InternalScaledTimeSeconds' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, MeshRelativeZScale) == 0x0003DC, "Member 'UMordhauAnimInstance::MeshRelativeZScale' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FaceCustomization) == 0x0003E0, "Member 'UMordhauAnimInstance::FaceCustomization' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Dismemberment) == 0x000400, "Member 'UMordhauAnimInstance::Dismemberment' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, PreviousRightHandEquipment) == 0x000410, "Member 'UMordhauAnimInstance::PreviousRightHandEquipment' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, MainEquipmentPtr) == 0x000418, "Member 'UMordhauAnimInstance::MainEquipmentPtr' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, MainAnimationType) == 0x000420, "Member 'UMordhauAnimInstance::MainAnimationType' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bWasRagdollFalling) == 0x000428, "Member 'UMordhauAnimInstance::bWasRagdollFalling' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LastRagdollFallingTime) == 0x00042C, "Member 'UMordhauAnimInstance::LastRagdollFallingTime' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bShouldPerformInstantAnimSwitch) == 0x000430, "Member 'UMordhauAnimInstance::bShouldPerformInstantAnimSwitch' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bIsGetUpFront) == 0x000432, "Member 'UMordhauAnimInstance::bIsGetUpFront' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, GetUpAnimationDuration) == 0x000434, "Member 'UMordhauAnimInstance::GetUpAnimationDuration' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, GetUpRotation) == 0x000438, "Member 'UMordhauAnimInstance::GetUpRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, DeathSyncedRandom) == 0x000444, "Member 'UMordhauAnimInstance::DeathSyncedRandom' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, IsDedicatedServer) == 0x000448, "Member 'UMordhauAnimInstance::IsDedicatedServer' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AnimLOD0) == 0x00044C, "Member 'UMordhauAnimInstance::AnimLOD0' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AnimLOD1) == 0x000450, "Member 'UMordhauAnimInstance::AnimLOD1' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, RecentlyRendered) == 0x000454, "Member 'UMordhauAnimInstance::RecentlyRendered' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, RecentlyRenderedNonAuth) == 0x000458, "Member 'UMordhauAnimInstance::RecentlyRenderedNonAuth' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AnimLOD0Distance) == 0x000464, "Member 'UMordhauAnimInstance::AnimLOD0Distance' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AnimLOD1Distance) == 0x000468, "Member 'UMordhauAnimInstance::AnimLOD1Distance' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, IsFemale) == 0x00046C, "Member 'UMordhauAnimInstance::IsFemale' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bIsClimbingA) == 0x000473, "Member 'UMordhauAnimInstance::bIsClimbingA' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, ClimbOffsetA) == 0x000474, "Member 'UMordhauAnimInstance::ClimbOffsetA' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, ClimbOffsetEndOffsetA) == 0x000480, "Member 'UMordhauAnimInstance::ClimbOffsetEndOffsetA' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, ClimbLedgeOffsetA) == 0x00048C, "Member 'UMordhauAnimInstance::ClimbLedgeOffsetA' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, IsSlowClimbingA) == 0x000498, "Member 'UMordhauAnimInstance::IsSlowClimbingA' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, ClimbRotationA) == 0x00049C, "Member 'UMordhauAnimInstance::ClimbRotationA' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bIsClimbingB) == 0x0004A8, "Member 'UMordhauAnimInstance::bIsClimbingB' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, ClimbOffsetB) == 0x0004AC, "Member 'UMordhauAnimInstance::ClimbOffsetB' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, ClimbOffsetEndOffsetB) == 0x0004B8, "Member 'UMordhauAnimInstance::ClimbOffsetEndOffsetB' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, ClimbLedgeOffsetB) == 0x0004C4, "Member 'UMordhauAnimInstance::ClimbLedgeOffsetB' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, ClimbRotationB) == 0x0004D0, "Member 'UMordhauAnimInstance::ClimbRotationB' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, IsSlowClimbingB) == 0x0004DC, "Member 'UMordhauAnimInstance::IsSlowClimbingB' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FastSmoothedIsCrouching) == 0x0004E0, "Member 'UMordhauAnimInstance::FastSmoothedIsCrouching' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, UnclampedFastSmoothedIsCrouching) == 0x0004E4, "Member 'UMordhauAnimInstance::UnclampedFastSmoothedIsCrouching' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, CrouchSpringState) == 0x0004E8, "Member 'UMordhauAnimInstance::CrouchSpringState' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, ServerCrouchSpeed) == 0x0004F0, "Member 'UMordhauAnimInstance::ServerCrouchSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, CrouchSpringLimits) == 0x0004F4, "Member 'UMordhauAnimInstance::CrouchSpringLimits' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, CrouchSpringStiffness) == 0x0004FC, "Member 'UMordhauAnimInstance::CrouchSpringStiffness' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, UncrouchSpringStiffness) == 0x000500, "Member 'UMordhauAnimInstance::UncrouchSpringStiffness' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, CrouchSpringDamping) == 0x000504, "Member 'UMordhauAnimInstance::CrouchSpringDamping' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, CrouchSpringMass) == 0x000508, "Member 'UMordhauAnimInstance::CrouchSpringMass' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleTransitionAnimation) == 0x000510, "Member 'UMordhauAnimInstance::VehicleTransitionAnimation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleTransitionBlendWeight) == 0x000518, "Member 'UMordhauAnimInstance::VehicleTransitionBlendWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleTransitionComponentLocation) == 0x00051C, "Member 'UMordhauAnimInstance::VehicleTransitionComponentLocation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleTransitionComponentRotation) == 0x000528, "Member 'UMordhauAnimInstance::VehicleTransitionComponentRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, IsDrivingFloat) == 0x000534, "Member 'UMordhauAnimInstance::IsDrivingFloat' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LowerBodyRotationOffset) == 0x00053C, "Member 'UMordhauAnimInstance::LowerBodyRotationOffset' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Direction) == 0x00054C, "Member 'UMordhauAnimInstance::Direction' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, MovementCorrectionHips) == 0x000550, "Member 'UMordhauAnimInstance::MovementCorrectionHips' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, MovementCorrectionHipsInterpSpeed) == 0x00055C, "Member 'UMordhauAnimInstance::MovementCorrectionHipsInterpSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, MovementCorrectionAnimRate) == 0x000560, "Member 'UMordhauAnimInstance::MovementCorrectionAnimRate' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, DirectionWithOffset) == 0x000564, "Member 'UMordhauAnimInstance::DirectionWithOffset' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, DirectionOffset) == 0x000568, "Member 'UMordhauAnimInstance::DirectionOffset' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, DirectionOffsetSlowInterpSpeed) == 0x00056C, "Member 'UMordhauAnimInstance::DirectionOffsetSlowInterpSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, DirectionOffsetSlow) == 0x000570, "Member 'UMordhauAnimInstance::DirectionOffsetSlow' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Velocity) == 0x00057C, "Member 'UMordhauAnimInstance::Velocity' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SmoothedVelocity) == 0x000580, "Member 'UMordhauAnimInstance::SmoothedVelocity' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, OneToZeroAtWalkSpeed) == 0x000584, "Member 'UMordhauAnimInstance::OneToZeroAtWalkSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AnimRateFactor1PMaxSprint) == 0x00058C, "Member 'UMordhauAnimInstance::AnimRateFactor1PMaxSprint' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, MovementSpeedScale) == 0x000590, "Member 'UMordhauAnimInstance::MovementSpeedScale' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, MovementAnimRate) == 0x000594, "Member 'UMordhauAnimInstance::MovementAnimRate' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SpeedWarping) == 0x000598, "Member 'UMordhauAnimInstance::SpeedWarping' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, ThirdPersonVelocity) == 0x00059C, "Member 'UMordhauAnimInstance::ThirdPersonVelocity' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bUseBackBlendSpace) == 0x0005A0, "Member 'UMordhauAnimInstance::bUseBackBlendSpace' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, StopBounce) == 0x0005A4, "Member 'UMordhauAnimInstance::StopBounce' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, StopBounceWorld) == 0x0005B0, "Member 'UMordhauAnimInstance::StopBounceWorld' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, StopBounceLimit) == 0x0005BC, "Member 'UMordhauAnimInstance::StopBounceLimit' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BounceInterpSpeedIn) == 0x0005C0, "Member 'UMordhauAnimInstance::BounceInterpSpeedIn' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BounceInterpSpeedOut) == 0x0005C8, "Member 'UMordhauAnimInstance::BounceInterpSpeedOut' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BounceDuck) == 0x0005D0, "Member 'UMordhauAnimInstance::BounceDuck' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BounceDuckLimit) == 0x0005DC, "Member 'UMordhauAnimInstance::BounceDuckLimit' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SlowVelocityLagTime) == 0x0005F8, "Member 'UMordhauAnimInstance::SlowVelocityLagTime' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FastVelocityLagTime) == 0x000614, "Member 'UMordhauAnimInstance::FastVelocityLagTime' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, StopTiltFactor) == 0x000618, "Member 'UMordhauAnimInstance::StopTiltFactor' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, StopDuckFactor) == 0x00061C, "Member 'UMordhauAnimInstance::StopDuckFactor' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AngularVelocityInterpSpeed) == 0x000620, "Member 'UMordhauAnimInstance::AngularVelocityInterpSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AngularVelocity) == 0x000624, "Member 'UMordhauAnimInstance::AngularVelocity' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AbsoluteAngularVelocityLowerBody) == 0x000628, "Member 'UMordhauAnimInstance::AbsoluteAngularVelocityLowerBody' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AngularVelocityLowerBody) == 0x000630, "Member 'UMordhauAnimInstance::AngularVelocityLowerBody' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AngularVelocityLowerBodyWindow) == 0x000638, "Member 'UMordhauAnimInstance::AngularVelocityLowerBodyWindow' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AnimatedMovementDirectionInCompSpace) == 0x000640, "Member 'UMordhauAnimInstance::AnimatedMovementDirectionInCompSpace' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AngularVelocityPitch) == 0x00064C, "Member 'UMordhauAnimInstance::AngularVelocityPitch' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SpringPitchYawValue) == 0x000650, "Member 'UMordhauAnimInstance::SpringPitchYawValue' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, PitchSpringState) == 0x000658, "Member 'UMordhauAnimInstance::PitchSpringState' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, YawSpringState) == 0x000660, "Member 'UMordhauAnimInstance::YawSpringState' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SpringPitchYawStiffness) == 0x000668, "Member 'UMordhauAnimInstance::SpringPitchYawStiffness' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SpringPitchYawDamping) == 0x000670, "Member 'UMordhauAnimInstance::SpringPitchYawDamping' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SpringPitchYawMass) == 0x000678, "Member 'UMordhauAnimInstance::SpringPitchYawMass' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HandSpringWeight) == 0x000680, "Member 'UMordhauAnimInstance::HandSpringWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bIsFirstPerson) == 0x000688, "Member 'UMordhauAnimInstance::bIsFirstPerson' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, IsFirstPersonFloat) == 0x00068C, "Member 'UMordhauAnimInstance::IsFirstPersonFloat' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, IsNotFirstPersonFloat) == 0x000690, "Member 'UMordhauAnimInstance::IsNotFirstPersonFloat' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, CameraCollisionOffset) == 0x000694, "Member 'UMordhauAnimInstance::CameraCollisionOffset' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, RightWeaponBoneBaseTransform) == 0x0006A0, "Member 'UMordhauAnimInstance::RightWeaponBoneBaseTransform' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, WeaponSlideVector) == 0x0006D0, "Member 'UMordhauAnimInstance::WeaponSlideVector' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, WeaponSlideVectorInverse) == 0x0006DC, "Member 'UMordhauAnimInstance::WeaponSlideVectorInverse' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, WeaponSlideCompensationWeight) == 0x0006EC, "Member 'UMordhauAnimInstance::WeaponSlideCompensationWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, RightShoulderOffset1P) == 0x0006F0, "Member 'UMordhauAnimInstance::RightShoulderOffset1P' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LeftShoulderOffset1P) == 0x0006FC, "Member 'UMordhauAnimInstance::LeftShoulderOffset1P' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, ShoulderOffset1PWeight) == 0x000708, "Member 'UMordhauAnimInstance::ShoulderOffset1PWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LeftShoulderIdleOffset1P) == 0x00070C, "Member 'UMordhauAnimInstance::LeftShoulderIdleOffset1P' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, RightHandIKOffset) == 0x000718, "Member 'UMordhauAnimInstance::RightHandIKOffset' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, RightHandIKOffsetWeight) == 0x000724, "Member 'UMordhauAnimInstance::RightHandIKOffsetWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, OffhandIKWeight) == 0x000728, "Member 'UMordhauAnimInstance::OffhandIKWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, OffhandSlidingAxis) == 0x000730, "Member 'UMordhauAnimInstance::OffhandSlidingAxis' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bIsOffhandFixedTarget) == 0x000760, "Member 'UMordhauAnimInstance::bIsOffhandFixedTarget' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, OffhandFixedTargetVector) == 0x000764, "Member 'UMordhauAnimInstance::OffhandFixedTargetVector' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LeftHandGripPosition) == 0x000770, "Member 'UMordhauAnimInstance::LeftHandGripPosition' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, RightHandGripPosition) == 0x00077C, "Member 'UMordhauAnimInstance::RightHandGripPosition' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, RightHandGripRotation) == 0x000788, "Member 'UMordhauAnimInstance::RightHandGripRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, OffhandIsRightHand) == 0x000794, "Member 'UMordhauAnimInstance::OffhandIsRightHand' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, JumpAnimation) == 0x000798, "Member 'UMordhauAnimInstance::JumpAnimation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FallingAnimation) == 0x0007A0, "Member 'UMordhauAnimInstance::FallingAnimation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LandAnimation) == 0x0007A8, "Member 'UMordhauAnimInstance::LandAnimation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BouncyMagnitudeOffset) == 0x0007C8, "Member 'UMordhauAnimInstance::BouncyMagnitudeOffset' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BouncySlowVelocityLagTime) == 0x0007CC, "Member 'UMordhauAnimInstance::BouncySlowVelocityLagTime' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BouncyFastVelocityLagTime) == 0x0007E8, "Member 'UMordhauAnimInstance::BouncyFastVelocityLagTime' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SkinnyPose) == 0x0007F0, "Member 'UMordhauAnimInstance::SkinnyPose' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FatPose) == 0x0007F8, "Member 'UMordhauAnimInstance::FatPose' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, StrongPose) == 0x000800, "Member 'UMordhauAnimInstance::StrongPose' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, NormalPose) == 0x000808, "Member 'UMordhauAnimInstance::NormalPose' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BouncyInterpSpeed) == 0x000810, "Member 'UMordhauAnimInstance::BouncyInterpSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BouncyFactorBreasts) == 0x000814, "Member 'UMordhauAnimInstance::BouncyFactorBreasts' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BouncyFactorArms) == 0x000818, "Member 'UMordhauAnimInstance::BouncyFactorArms' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BouncyFactorBelly) == 0x00081C, "Member 'UMordhauAnimInstance::BouncyFactorBelly' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BouncyFactorLegs) == 0x000820, "Member 'UMordhauAnimInstance::BouncyFactorLegs' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BreastsT) == 0x000824, "Member 'UMordhauAnimInstance::BreastsT' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LowerBackBellyT) == 0x000830, "Member 'UMordhauAnimInstance::LowerBackBellyT' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SpineAdjustT) == 0x00083C, "Member 'UMordhauAnimInstance::SpineAdjustT' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LeftArmAdjustT) == 0x000848, "Member 'UMordhauAnimInstance::LeftArmAdjustT' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, RightArmAdjustT) == 0x000854, "Member 'UMordhauAnimInstance::RightArmAdjustT' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LeftUpLegAdjustT) == 0x000860, "Member 'UMordhauAnimInstance::LeftUpLegAdjustT' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, RightUpLegAdjustT) == 0x00086C, "Member 'UMordhauAnimInstance::RightUpLegAdjustT' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, IsTankFloat) == 0x000878, "Member 'UMordhauAnimInstance::IsTankFloat' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, IsDwarfFloat) == 0x00087C, "Member 'UMordhauAnimInstance::IsDwarfFloat' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, DwarfSlowerAnimSpeedFactor) == 0x000880, "Member 'UMordhauAnimInstance::DwarfSlowerAnimSpeedFactor' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Fat) == 0x000884, "Member 'UMordhauAnimInstance::Fat' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Skinny) == 0x000888, "Member 'UMordhauAnimInstance::Skinny' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Strong) == 0x00088C, "Member 'UMordhauAnimInstance::Strong' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, IsHeadDismembered) == 0x000890, "Member 'UMordhauAnimInstance::IsHeadDismembered' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, NeckDismemberedRotation) == 0x000894, "Member 'UMordhauAnimInstance::NeckDismemberedRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LeftShoulderDismemberedRotation) == 0x0008A0, "Member 'UMordhauAnimInstance::LeftShoulderDismemberedRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, IsLeftArmDismembered) == 0x0008AC, "Member 'UMordhauAnimInstance::IsLeftArmDismembered' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, RightShoulderDismemberedRotation) == 0x0008B0, "Member 'UMordhauAnimInstance::RightShoulderDismemberedRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, IsRightArmDismembered) == 0x0008BC, "Member 'UMordhauAnimInstance::IsRightArmDismembered' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, IsAnythingDismembered) == 0x0008C0, "Member 'UMordhauAnimInstance::IsAnythingDismembered' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, TrackingWeight) == 0x0008C4, "Member 'UMordhauAnimInstance::TrackingWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LookingAtRotationNeck) == 0x0008CC, "Member 'UMordhauAnimInstance::LookingAtRotationNeck' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LookingAtRotationHead) == 0x0008D8, "Member 'UMordhauAnimInstance::LookingAtRotationHead' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LookingAtRotationEyes) == 0x0008E4, "Member 'UMordhauAnimInstance::LookingAtRotationEyes' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HideEars) == 0x0008F0, "Member 'UMordhauAnimInstance::HideEars' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HideNose) == 0x0008F4, "Member 'UMordhauAnimInstance::HideNose' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BreathCurve) == 0x0008F8, "Member 'UMordhauAnimInstance::BreathCurve' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HealthToBreathDuration) == 0x000900, "Member 'UMordhauAnimInstance::HealthToBreathDuration' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Breath) == 0x000908, "Member 'UMordhauAnimInstance::Breath' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, CounterCompensateLookWeight) == 0x00091C, "Member 'UMordhauAnimInstance::CounterCompensateLookWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, CounterCompensateRotation) == 0x00092C, "Member 'UMordhauAnimInstance::CounterCompensateRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LookUpValue) == 0x000938, "Member 'UMordhauAnimInstance::LookUpValue' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, RightLegBendBlendWeight) == 0x00093C, "Member 'UMordhauAnimInstance::RightLegBendBlendWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SpineBendBlendWeight) == 0x000940, "Member 'UMordhauAnimInstance::SpineBendBlendWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SpineArmsCompensationFactor) == 0x000944, "Member 'UMordhauAnimInstance::SpineArmsCompensationFactor' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, TurnValue) == 0x000948, "Member 'UMordhauAnimInstance::TurnValue' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LeftHandIsEmpty) == 0x00094C, "Member 'UMordhauAnimInstance::LeftHandIsEmpty' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AtmosphericsWeight) == 0x000950, "Member 'UMordhauAnimInstance::AtmosphericsWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Arms3PSyncWeight) == 0x000954, "Member 'UMordhauAnimInstance::Arms3PSyncWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, BlockDirection) == 0x000960, "Member 'UMordhauAnimInstance::BlockDirection' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, DisarmDirection) == 0x000964, "Member 'UMordhauAnimInstance::DisarmDirection' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SpineSpaceAdditive) == 0x000968, "Member 'UMordhauAnimInstance::SpineSpaceAdditive' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LeftTorsoBlendWeight) == 0x0009EC, "Member 'UMordhauAnimInstance::LeftTorsoBlendWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AttackBounce) == 0x0009F0, "Member 'UMordhauAnimInstance::AttackBounce' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, RangedDrawnAdditive) == 0x0009F8, "Member 'UMordhauAnimInstance::RangedDrawnAdditive' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SwayRotation) == 0x000A00, "Member 'UMordhauAnimInstance::SwayRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SwayWeight) == 0x000A0C, "Member 'UMordhauAnimInstance::SwayWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, ParryAdditive) == 0x000A10, "Member 'UMordhauAnimInstance::ParryAdditive' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, ParryPushAdditive) == 0x000A18, "Member 'UMordhauAnimInstance::ParryPushAdditive' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AltParryPushAdditive) == 0x000A20, "Member 'UMordhauAnimInstance::AltParryPushAdditive' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LowerBodyBlendSpaceBlendTime) == 0x000A28, "Member 'UMordhauAnimInstance::LowerBodyBlendSpaceBlendTime' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, UpperBlendSpaceA) == 0x000A30, "Member 'UMordhauAnimInstance::UpperBlendSpaceA' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, UpperBlendSpaceABlendTime) == 0x000A38, "Member 'UMordhauAnimInstance::UpperBlendSpaceABlendTime' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, UpperAdditiveA) == 0x000A40, "Member 'UMordhauAnimInstance::UpperAdditiveA' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, UpperBlendSpaceB) == 0x000A48, "Member 'UMordhauAnimInstance::UpperBlendSpaceB' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, UpperBlendSpaceBBlendTime) == 0x000A50, "Member 'UMordhauAnimInstance::UpperBlendSpaceBBlendTime' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, UpperAdditiveB) == 0x000A58, "Member 'UMordhauAnimInstance::UpperAdditiveB' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bIsCurrentUpperA) == 0x000A60, "Member 'UMordhauAnimInstance::bIsCurrentUpperA' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LowerBodyAnimationA) == 0x000A68, "Member 'UMordhauAnimInstance::LowerBodyAnimationA' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LowerBodyAnimationB) == 0x000A70, "Member 'UMordhauAnimInstance::LowerBodyAnimationB' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HorseUpperRearing) == 0x000A78, "Member 'UMordhauAnimInstance::HorseUpperRearing' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bIsCurrentLowerA) == 0x000A80, "Member 'UMordhauAnimInstance::bIsCurrentLowerA' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bIsHorseRearing) == 0x000A81, "Member 'UMordhauAnimInstance::bIsHorseRearing' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Couching) == 0x000A84, "Member 'UMordhauAnimInstance::Couching' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Rearing) == 0x000A88, "Member 'UMordhauAnimInstance::Rearing' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Lean) == 0x000A8C, "Member 'UMordhauAnimInstance::Lean' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleAnimTime) == 0x000A90, "Member 'UMordhauAnimInstance::VehicleAnimTime' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleAnimRate) == 0x000A94, "Member 'UMordhauAnimInstance::VehicleAnimRate' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleLeftHandTarget) == 0x000A98, "Member 'UMordhauAnimInstance::VehicleLeftHandTarget' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleRightHandTarget) == 0x000AA4, "Member 'UMordhauAnimInstance::VehicleRightHandTarget' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleTurn) == 0x000AB0, "Member 'UMordhauAnimInstance::VehicleTurn' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleLookUp) == 0x000AB4, "Member 'UMordhauAnimInstance::VehicleLookUp' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleLeftFootTarget) == 0x000AB8, "Member 'UMordhauAnimInstance::VehicleLeftFootTarget' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleRightFootTarget) == 0x000AC4, "Member 'UMordhauAnimInstance::VehicleRightFootTarget' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleLeftFootRotation) == 0x000AD0, "Member 'UMordhauAnimInstance::VehicleLeftFootRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleRightFootRotation) == 0x000ADC, "Member 'UMordhauAnimInstance::VehicleRightFootRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleVelocity) == 0x000AE8, "Member 'UMordhauAnimInstance::VehicleVelocity' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleDirection) == 0x000AEC, "Member 'UMordhauAnimInstance::VehicleDirection' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleSeat) == 0x000AF0, "Member 'UMordhauAnimInstance::VehicleSeat' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleActorRotation) == 0x000AFC, "Member 'UMordhauAnimInstance::VehicleActorRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleRotationOffset) == 0x000B08, "Member 'UMordhauAnimInstance::VehicleRotationOffset' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, VehicleSeatRotation) == 0x000B14, "Member 'UMordhauAnimInstance::VehicleSeatRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bBallistaReloading) == 0x000B20, "Member 'UMordhauAnimInstance::bBallistaReloading' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HitEffectIKWeight) == 0x000B24, "Member 'UMordhauAnimInstance::HitEffectIKWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HitEffectLocationSlideSpeed) == 0x000B28, "Member 'UMordhauAnimInstance::HitEffectLocationSlideSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HitEffectDisableSpeed) == 0x000B2C, "Member 'UMordhauAnimInstance::HitEffectDisableSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HitEffectIKLocation) == 0x000B30, "Member 'UMordhauAnimInstance::HitEffectIKLocation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HitEffectIKLocationStart) == 0x000B3C, "Member 'UMordhauAnimInstance::HitEffectIKLocationStart' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HitEffectRotation) == 0x000B48, "Member 'UMordhauAnimInstance::HitEffectRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HitEffectRotationStart) == 0x000B54, "Member 'UMordhauAnimInstance::HitEffectRotationStart' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchFreezeBlendInDuration) == 0x000B64, "Member 'UMordhauAnimInstance::FlinchFreezeBlendInDuration' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchFreezeRotationBlendInSpeed) == 0x000B68, "Member 'UMordhauAnimInstance::FlinchFreezeRotationBlendInSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchFreezeTranslationBlendInSpeed) == 0x000B6C, "Member 'UMordhauAnimInstance::FlinchFreezeTranslationBlendInSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchFreezeBlendInAlpha) == 0x000B70, "Member 'UMordhauAnimInstance::FlinchFreezeBlendInAlpha' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchBlendInDuration) == 0x000B74, "Member 'UMordhauAnimInstance::FlinchBlendInDuration' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchRotationBlendInSpeed) == 0x000B78, "Member 'UMordhauAnimInstance::FlinchRotationBlendInSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchTranslationBlendInSpeed) == 0x000B7C, "Member 'UMordhauAnimInstance::FlinchTranslationBlendInSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchRotationBlendOutSpeed) == 0x000B80, "Member 'UMordhauAnimInstance::FlinchRotationBlendOutSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchTranslationBlendOutSpeed) == 0x000B84, "Member 'UMordhauAnimInstance::FlinchTranslationBlendOutSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchRotationBlendOutSpeedFast) == 0x000B88, "Member 'UMordhauAnimInstance::FlinchRotationBlendOutSpeedFast' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchTranslationBlendOutSpeedFast) == 0x000B8C, "Member 'UMordhauAnimInstance::FlinchTranslationBlendOutSpeedFast' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchPitchAmount) == 0x000B90, "Member 'UMordhauAnimInstance::FlinchPitchAmount' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchYawAmount) == 0x000B94, "Member 'UMordhauAnimInstance::FlinchYawAmount' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchPitchYawFactor) == 0x000B98, "Member 'UMordhauAnimInstance::FlinchPitchYawFactor' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchHipsZFactor) == 0x000B9C, "Member 'UMordhauAnimInstance::FlinchHipsZFactor' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, WeaponDirHipsZFactor) == 0x000BA0, "Member 'UMordhauAnimInstance::WeaponDirHipsZFactor' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, TranslationNonHipsFactor) == 0x000BA4, "Member 'UMordhauAnimInstance::TranslationNonHipsFactor' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchRotationTarget) == 0x000BA8, "Member 'UMordhauAnimInstance::FlinchRotationTarget' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchTranslationTarget) == 0x000BB4, "Member 'UMordhauAnimInstance::FlinchTranslationTarget' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchHipsTranslationTarget) == 0x000BC0, "Member 'UMordhauAnimInstance::FlinchHipsTranslationTarget' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchHitSpineIdx) == 0x000BCC, "Member 'UMordhauAnimInstance::FlinchHitSpineIdx' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, FlinchStartTime) == 0x000BD0, "Member 'UMordhauAnimInstance::FlinchStartTime' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, CurrentFlinchSpineRotationsCombined) == 0x000BD4, "Member 'UMordhauAnimInstance::CurrentFlinchSpineRotationsCombined' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HipsFlinchRotation) == 0x000BE0, "Member 'UMordhauAnimInstance::HipsFlinchRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HipsFlinchTranslation) == 0x000BEC, "Member 'UMordhauAnimInstance::HipsFlinchTranslation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HipsFlinchTranslationInternal) == 0x000BF8, "Member 'UMordhauAnimInstance::HipsFlinchTranslationInternal' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LowerBackFlinchRotation) == 0x000C04, "Member 'UMordhauAnimInstance::LowerBackFlinchRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, LowerBackFlinchTranslation) == 0x000C10, "Member 'UMordhauAnimInstance::LowerBackFlinchTranslation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SpineFlinchRotation) == 0x000C1C, "Member 'UMordhauAnimInstance::SpineFlinchRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, SpineFlinchTranslation) == 0x000C28, "Member 'UMordhauAnimInstance::SpineFlinchTranslation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Spine1FlinchRotation) == 0x000C34, "Member 'UMordhauAnimInstance::Spine1FlinchRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Spine1FlinchTranslation) == 0x000C40, "Member 'UMordhauAnimInstance::Spine1FlinchTranslation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, NeckFlinchRotation) == 0x000C4C, "Member 'UMordhauAnimInstance::NeckFlinchRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, NeckFlinchTranslation) == 0x000C58, "Member 'UMordhauAnimInstance::NeckFlinchTranslation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HeadFlinchRotation) == 0x000C64, "Member 'UMordhauAnimInstance::HeadFlinchRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, HeadFlinchTranslation) == 0x000C70, "Member 'UMordhauAnimInstance::HeadFlinchTranslation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_WeaponSlideVectorIsNonzero) == 0x000C7C, "Member 'UMordhauAnimInstance::Helper_WeaponSlideVectorIsNonzero' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_UBCrouchAlpha) == 0x000C80, "Member 'UMordhauAnimInstance::Helper_UBCrouchAlpha' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_LBCrouchAlpha) == 0x000C84, "Member 'UMordhauAnimInstance::Helper_LBCrouchAlpha' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_UBCrouchSpine) == 0x000C88, "Member 'UMordhauAnimInstance::Helper_UBCrouchSpine' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_UBCrouchForearms) == 0x000C94, "Member 'UMordhauAnimInstance::Helper_UBCrouchForearms' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_UBCrouchArms) == 0x000CA0, "Member 'UMordhauAnimInstance::Helper_UBCrouchArms' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_UBCrouchHead) == 0x000CAC, "Member 'UMordhauAnimInstance::Helper_UBCrouchHead' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_UBCrouchShoulder) == 0x000CB8, "Member 'UMordhauAnimInstance::Helper_UBCrouchShoulder' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_UBSpineArmsCompensationAlpha) == 0x000CC4, "Member 'UMordhauAnimInstance::Helper_UBSpineArmsCompensationAlpha' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_UBSpineArmsCompensationRotator) == 0x000CC8, "Member 'UMordhauAnimInstance::Helper_UBSpineArmsCompensationRotator' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bHelper_LBFootShuffling) == 0x000CD4, "Member 'UMordhauAnimInstance::bHelper_LBFootShuffling' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_LBFootShufflingPlayRate) == 0x000CD8, "Member 'UMordhauAnimInstance::Helper_LBFootShufflingPlayRate' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bHelper_LBFootShufflingRight) == 0x000CDC, "Member 'UMordhauAnimInstance::bHelper_LBFootShufflingRight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_LBDirectionOffsetSlowRotator) == 0x000CE0, "Member 'UMordhauAnimInstance::Helper_LBDirectionOffsetSlowRotator' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_LBDirectionOffsetSlowRotatorInverse) == 0x000CEC, "Member 'UMordhauAnimInstance::Helper_LBDirectionOffsetSlowRotatorInverse' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_LBDirectionOffsetSlowHipsZ) == 0x000CF8, "Member 'UMordhauAnimInstance::Helper_LBDirectionOffsetSlowHipsZ' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_LBDirectionOffsetSlowHipsZInverse) == 0x000D04, "Member 'UMordhauAnimInstance::Helper_LBDirectionOffsetSlowHipsZInverse' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_LBDirectionOffsetSlowFootRotationOffset) == 0x000D10, "Member 'UMordhauAnimInstance::Helper_LBDirectionOffsetSlowFootRotationOffset' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_UBVelocity) == 0x000D1C, "Member 'UMordhauAnimInstance::Helper_UBVelocity' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, bHelper_LBVelocityIsZero) == 0x000D20, "Member 'UMordhauAnimInstance::bHelper_LBVelocityIsZero' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_LBCrouchOffset) == 0x000D24, "Member 'UMordhauAnimInstance::Helper_LBCrouchOffset' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_LBCrouchOffsetInverse) == 0x000D30, "Member 'UMordhauAnimInstance::Helper_LBCrouchOffsetInverse' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_LBHipsZOverrideAlpha) == 0x000D3C, "Member 'UMordhauAnimInstance::Helper_LBHipsZOverrideAlpha' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_TrackingWeightAlpha) == 0x000D40, "Member 'UMordhauAnimInstance::Helper_TrackingWeightAlpha' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_BreathAlpha) == 0x000D44, "Member 'UMordhauAnimInstance::Helper_BreathAlpha' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_IsNotDrivingFloat) == 0x000D48, "Member 'UMordhauAnimInstance::Helper_IsNotDrivingFloat' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_IsAnyFlinchValueNonZero) == 0x000D4C, "Member 'UMordhauAnimInstance::Helper_IsAnyFlinchValueNonZero' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_HipsFlinchTranslationInverse) == 0x000D50, "Member 'UMordhauAnimInstance::Helper_HipsFlinchTranslationInverse' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_HipsFlinchRotationInverse) == 0x000D5C, "Member 'UMordhauAnimInstance::Helper_HipsFlinchRotationInverse' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_ArmsShoulderFlinchInverse) == 0x000D68, "Member 'UMordhauAnimInstance::Helper_ArmsShoulderFlinchInverse' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_FirstPersonNotDead) == 0x000D74, "Member 'UMordhauAnimInstance::Helper_FirstPersonNotDead' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_FirstPersonZoomOffsetAndCollision) == 0x000D78, "Member 'UMordhauAnimInstance::Helper_FirstPersonZoomOffsetAndCollision' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_CameraCollisionOffsetWithNot3PArmsSync) == 0x000D84, "Member 'UMordhauAnimInstance::Helper_CameraCollisionOffsetWithNot3PArmsSync' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_FirstPersonNotDeadWith3PArmsSync) == 0x000D90, "Member 'UMordhauAnimInstance::Helper_FirstPersonNotDeadWith3PArmsSync' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_IsNotFemale) == 0x000D94, "Member 'UMordhauAnimInstance::Helper_IsNotFemale' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_SpineBendBlendWeightHalf) == 0x000D98, "Member 'UMordhauAnimInstance::Helper_SpineBendBlendWeightHalf' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_SpineBendBlendWeightThird) == 0x000D9C, "Member 'UMordhauAnimInstance::Helper_SpineBendBlendWeightThird' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_GroundingRightFootRotationOffset) == 0x000DA0, "Member 'UMordhauAnimInstance::Helper_GroundingRightFootRotationOffset' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_GroundingLeftFootRotationOffset) == 0x000DAC, "Member 'UMordhauAnimInstance::Helper_GroundingLeftFootRotationOffset' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_GroundingRightFootTranslationOffset) == 0x000DB8, "Member 'UMordhauAnimInstance::Helper_GroundingRightFootTranslationOffset' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_GroundingLeftFootTranslationOffset) == 0x000DC4, "Member 'UMordhauAnimInstance::Helper_GroundingLeftFootTranslationOffset' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_GroundingWeightWithFirstPerson) == 0x000DD0, "Member 'UMordhauAnimInstance::Helper_GroundingWeightWithFirstPerson' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_GroundingWeightWithNotFirstPerson) == 0x000DD4, "Member 'UMordhauAnimInstance::Helper_GroundingWeightWithNotFirstPerson' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, NotFirstPersonWithAtmospherics) == 0x000DD8, "Member 'UMordhauAnimInstance::NotFirstPersonWithAtmospherics' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, NotFirstPersonWithAtmosphericsAndAnimLOD1) == 0x000DDC, "Member 'UMordhauAnimInstance::NotFirstPersonWithAtmosphericsAndAnimLOD1' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_FaceUpperLids) == 0x000DE0, "Member 'UMordhauAnimInstance::Helper_FaceUpperLids' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_LeftHandIKWeight) == 0x000DEC, "Member 'UMordhauAnimInstance::Helper_LeftHandIKWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_RightHandIKWeight) == 0x000DF0, "Member 'UMordhauAnimInstance::Helper_RightHandIKWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_RootRotationOffsetInverse) == 0x000DF4, "Member 'UMordhauAnimInstance::Helper_RootRotationOffsetInverse' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_StopBounceMediumWeight) == 0x000E00, "Member 'UMordhauAnimInstance::Helper_StopBounceMediumWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_StopBounceLightWeight) == 0x000E04, "Member 'UMordhauAnimInstance::Helper_StopBounceLightWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_StopBounceInverse) == 0x000E08, "Member 'UMordhauAnimInstance::Helper_StopBounceInverse' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_StopBounceInverseHead) == 0x000E14, "Member 'UMordhauAnimInstance::Helper_StopBounceInverseHead' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_StopBounceHips) == 0x000E20, "Member 'UMordhauAnimInstance::Helper_StopBounceHips' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_BounceDuckWithBounceWeight) == 0x000E2C, "Member 'UMordhauAnimInstance::Helper_BounceDuckWithBounceWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_BounceDuckWithBounceWeightInverse) == 0x000E38, "Member 'UMordhauAnimInstance::Helper_BounceDuckWithBounceWeightInverse' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_SpineBendRotation) == 0x000E44, "Member 'UMordhauAnimInstance::Helper_SpineBendRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_HipsBendRotation) == 0x000E50, "Member 'UMordhauAnimInstance::Helper_HipsBendRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_SpineBendRotationAlpha) == 0x000E5C, "Member 'UMordhauAnimInstance::Helper_SpineBendRotationAlpha' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_RightLegBendRotation) == 0x000E60, "Member 'UMordhauAnimInstance::Helper_RightLegBendRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_ArmsBendRotation) == 0x000E6C, "Member 'UMordhauAnimInstance::Helper_ArmsBendRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, AtmosphericsWeightWithAnimLOD0) == 0x000E78, "Member 'UMordhauAnimInstance::AtmosphericsWeightWithAnimLOD0' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_LowerBodyRotationOffsetInverse) == 0x000E7C, "Member 'UMordhauAnimInstance::Helper_LowerBodyRotationOffsetInverse' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_RightWeaponBoneBaseTranslation) == 0x000E88, "Member 'UMordhauAnimInstance::Helper_RightWeaponBoneBaseTranslation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_RightWeaponBoneBaseRotation) == 0x000E94, "Member 'UMordhauAnimInstance::Helper_RightWeaponBoneBaseRotation' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_SpringPitchYawValueRotator) == 0x000EA0, "Member 'UMordhauAnimInstance::Helper_SpringPitchYawValueRotator' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_HandSpringWeight) == 0x000EAC, "Member 'UMordhauAnimInstance::Helper_HandSpringWeight' has a wrong offset!");
static_assert(offsetof(UMordhauAnimInstance, Helper_ShoulderOffset1PWith1PWeight) == 0x000EB0, "Member 'UMordhauAnimInstance::Helper_ShoulderOffset1PWith1PWeight' has a wrong offset!");

// Class Mordhau.MordhauBeaconClient
// 0x0040 (0x02F0 - 0x02B0)
class AMordhauBeaconClient final : public AOnlineBeaconClient
{
public:
	EBeaconRequest                                Request;                                           // 0x02B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        PingStartTime;                                     // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPlayFabPlayerEntity>           PlayerEntities;                                    // 0x02C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x20];                                     // 0x02D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientNotifyReservationStatus(int32 OpenSlots, EReservationStatus ReservationStatus);
	void ClientPong();
	bool Ping(struct FURL* ConnectURL);
	bool ReserveSlots(struct FURL* ConnectURL, const TArray<struct FPlayFabPlayerEntity>& InPlayerEntites);
	void ServerPing();
	void ServerReserveSlots(const TArray<struct FPlayFabPlayerEntity>& InPlayerEntities);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauBeaconClient">();
	}
	static class AMordhauBeaconClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauBeaconClient>();
	}
};
static_assert(alignof(AMordhauBeaconClient) == 0x000008, "Wrong alignment on AMordhauBeaconClient");
static_assert(sizeof(AMordhauBeaconClient) == 0x0002F0, "Wrong size on AMordhauBeaconClient");
static_assert(offsetof(AMordhauBeaconClient, Request) == 0x0002B0, "Member 'AMordhauBeaconClient::Request' has a wrong offset!");
static_assert(offsetof(AMordhauBeaconClient, PingStartTime) == 0x0002B8, "Member 'AMordhauBeaconClient::PingStartTime' has a wrong offset!");
static_assert(offsetof(AMordhauBeaconClient, PlayerEntities) == 0x0002C0, "Member 'AMordhauBeaconClient::PlayerEntities' has a wrong offset!");

// Class Mordhau.MordhauBeaconHost
// 0x0000 (0x0248 - 0x0248)
class AMordhauBeaconHost final : public AOnlineBeaconHostObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauBeaconHost">();
	}
	static class AMordhauBeaconHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauBeaconHost>();
	}
};
static_assert(alignof(AMordhauBeaconHost) == 0x000008, "Wrong alignment on AMordhauBeaconHost");
static_assert(sizeof(AMordhauBeaconHost) == 0x000248, "Wrong size on AMordhauBeaconHost");

// Class Mordhau.MordhauCharacter
// 0x07A0 (0x12B0 - 0x0B10)
class AMordhauCharacter : public AAdvancedCharacter
{
public:
	class UMordhauMotion*                         Motion;                                            // 0x0B08(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B10[0x8];                                      // 0x0B10(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UMordhauWearable*>    WearableProtectionCoverageMap;                     // 0x0B18(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_B68[0x10];                                     // 0x0B68(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMordhauCameraComponent*                MordhauCamera;                                     // 0x0B78(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFaceCustomizationComponent*            FaceCustomizationComponent;                        // 0x0B80(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextAllowedVoiceCommandTime;                       // 0x0B88(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsClimb;                                       // 0x0B8C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCannotChamber;                                    // 0x0B8D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDrop;                                        // 0x0B8E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowClimbing;                                    // 0x0B8F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowVehicles;                                    // 0x0B90(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowEquipmentRotate;                             // 0x0B91(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B92[0x2];                                      // 0x0B92(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InTeamAreaSince;                                   // 0x0B94(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideIsInEnemyTeamArea;                        // 0x0B98(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHoldingBlock;                                   // 0x0B99(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHoldingModeSwitch;                              // 0x0B9A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9B[0x1];                                      // 0x0B9B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldingModeSwitchTime;                             // 0x0B9C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToHoldModeSwitchForOtherHand;                  // 0x0BA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpineSpaceAdditive                    OverrideSpineSpaceAdditive;                        // 0x0BA4(0x0084)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseOverrideSpineSpaceAdditive;                    // 0x0C28(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C29[0x3];                                      // 0x0C29(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpineSpaceAdditive                    SpineSpaceAdditiveTarget;                          // 0x0C2C(0x0084)(NoDestructor, NativeAccessSpecifierPublic)
	struct FSpineSpaceAdditive                    SpineSpaceAdditiveFrom;                            // 0x0CB0(0x0084)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D34[0xC];                                      // 0x0D34(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsLeftArmDisabled;                                // 0x0D40(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRightArmDisabled;                               // 0x0D41(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeftLegDisabled;                                // 0x0D42(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRightLegDisabled;                               // 0x0D43(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D44[0x4];                                      // 0x0D44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFacialBoneSetup>               FaceCustomizationSetup;                            // 0x0D48(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bDoNotAnimateBreathing;                            // 0x0D58(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotUseGrounding;                                // 0x0D59(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSoundDisabled;                                  // 0x0D5A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotLookAtOthers;                                // 0x0D5B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedDodge;                                   // 0x0D5C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedKnockback;                               // 0x0D5D(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedVoiceCommand;                            // 0x0D5E(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5F[0x1];                                      // 0x0D5F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ACustomizationReplicationActor> ReplicatedCustomizationReplicationActor;           // 0x0D60(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     FaceCustomizationBonesTransforms;                  // 0x0D68(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D78[0x8];                                      // 0x0D78(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AControlPoint*                          CurrentCapturePoint;                               // 0x0D80(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentCapturePointTime;                           // 0x0D88(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceColorOverrides;                              // 0x0D8C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8D[0x3];                                      // 0x0D8D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorAOverride;                                    // 0x0D90(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorBOverride;                                    // 0x0DA0(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentForcedLOD;                                  // 0x0DB0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DB4[0x4];                                      // 0x0DB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          ActorsThatDestroyWithUs;                           // 0x0DB8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UParticleSystemComponent> CurrentBleedOutParticles;                          // 0x0DC8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  LastMovementFrontalHitActor;                       // 0x0DD0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD8[0xC];                                      // 0x0DD8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWantsCrouch;                                      // 0x0DE4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE5[0x3];                                      // 0x0DE5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrouchCooldown;                                    // 0x0DE8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintingMoveBlockedByFractionToTrigger;           // 0x0DEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveBlockedBySlowMinInterval;                      // 0x0DF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DF4[0x4];                                      // 0x0DF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ClimbTargetLocation;                               // 0x0DF8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastNoticeableLookChange;                          // 0x0E04(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PreviousLookValues;                                // 0x0E08(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoticeableLookChangeMinRate;                       // 0x0E10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E14[0x4];                                      // 0x0E14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDamageRecord>                  DamageHistory;                                     // 0x0E18(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E28[0x10];                                     // 0x0E28(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StructureDamageModifier;                           // 0x0E38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StructureRepairModifier;                           // 0x0E3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtraStaminaOnHit;                                 // 0x0E40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaminaCostModifier;                               // 0x0E44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeWindupModifier;                               // 0x0E48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeComboExtraWindupModifier;                     // 0x0E4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeReleaseModifier;                              // 0x0E50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeMissRecoveryModifier;                         // 0x0E54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LegDamageBonusModifierAirborne;                    // 0x0E58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUnflinchable;                                   // 0x0E5C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5D[0x3];                                      // 0x0E5D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnflinchableDamageThreshold;                       // 0x0E60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHitStopOnTeamHitsDisabled;                      // 0x0E64(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableProjectileRangedDrawFlinch;                // 0x0E65(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDodge;                                         // 0x0E66(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Stamina;                                           // 0x0E67(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedStamina;                                 // 0x0E68(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StaminaRegenPerTick;                               // 0x0E69(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E6A[0x2];                                      // 0x0E6A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaminaRegenDelay;                                 // 0x0E6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StaminaOnKill;                                     // 0x0E70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HealthOnKill;                                      // 0x0E74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaminaRegenTickRate;                              // 0x0E78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpStaminaCost;                                   // 0x0E7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastEnemyKilledTimeWithMeleeOrRanged;              // 0x0E80(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackParry;                                    // 0x0E84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackWorld;                                    // 0x0E88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackClash;                                    // 0x0E8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E90[0x4];                                      // 0x0E90(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EasyParryUntilTime;                                // 0x0E94(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingTime;                                       // 0x0E98(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingTimeToRagdoll;                              // 0x0E9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastDodgeTime;                                     // 0x0EA0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeDuration;                                     // 0x0EA4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgeCooldown;                                     // 0x0EA8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DodgeStaminaCost;                                  // 0x0EAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasDodgeCanceled;                                 // 0x0EB0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EB1[0x3];                                      // 0x0EB1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DodgeDirection;                                    // 0x0EB4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DodgeDirectionLocal;                               // 0x0EC0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalChaseTime;                                    // 0x0ECC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastChaseTime;                                     // 0x0ED0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalChasedTime;                                   // 0x0ED4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastChasedTime;                                    // 0x0ED8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EDC[0x4];                                      // 0x0EDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          SkinnyPose;                                        // 0x0EE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FatPose;                                           // 0x0EE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StrongPose;                                        // 0x0EF0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseReducedBodyPoses;                              // 0x0EF8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoresTeamColors;                                // 0x0EF9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasHitAfterDeath;                                 // 0x0EFA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EFB[0x1];                                      // 0x0EFB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  CurrentlyTracking;                                 // 0x0EFC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastTrackingUpdate;                                // 0x0F04(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFirstPerson;                                    // 0x0F08(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CameraStyle;                                       // 0x0F09(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0A[0x2];                                      // 0x0F0A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentSpeedFOVOffset;                             // 0x0F0C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSprintFOVOffset;                                // 0x0F10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSprintFOVOffsetInterpSpeed;                     // 0x0F14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraLocation1P;                                  // 0x0F18(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraLocation1PCosmeticOffset;                    // 0x0F24(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotation1P;                                  // 0x0F30(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotation1PMeshSpace;                         // 0x0F3C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EllipseBubbleLength;                               // 0x0F48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EllipseBubbleRadius;                               // 0x0F4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EllipseBubbleMaxHeightDiff;                        // 0x0F50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BlockColliderForwardParryDistance;                 // 0x0F54(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5C[0x4];                                      // 0x0F5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          BlockCollider;                                     // 0x0F60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F68[0x8];                                      // 0x0F68(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LowBlockColliderRelativeOffset;                    // 0x0F70(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             HighBlockColliderRelativeOffset;                   // 0x0FA0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             OriginalBlockColliderRelativeOffset;               // 0x0FD0(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1000[0x10];                                    // 0x1000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LastRequestedFireOrigin;                           // 0x1010(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LastRequestedFireRotation;                         // 0x101C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bWantsFire;                                        // 0x1028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsBlock;                                       // 0x1029(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsFeintOrBlock;                                // 0x102A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102B[0x5];                                     // 0x102B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleSystem*>                SprintFootstepParticles;                           // 0x1030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     BloodHitEffect;                                    // 0x1040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     BloodMetalHitEffect;                               // 0x1048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        BleedingOutParticleEffect;                         // 0x1050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        DodgeParticleEffect;                               // 0x1058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        DodgeCameraShake;                                  // 0x1060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        FallDamageCameraShake;                             // 0x1068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        RunLeftHeadBobShake;                               // 0x1070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        RunRightHeadBobShake;                              // 0x1078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        WalkLeftHeadBobShake;                              // 0x1080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        WalkRightHeadBobShake;                             // 0x1088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        BlockShakeEffect;                                  // 0x1090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        BlockedShakeEffect;                                // 0x1098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        FlinchShakeEffect;                                 // 0x10A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNetBlock                              NetBlock;                                          // 0x10A8(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B8[0x8];                                     // 0x10B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMordhauVehicleComponent*               CurrentVehicle;                                    // 0x10C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DeathSyncedRandom;                                 // 0x10C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNetMotion                             ReplicatedNetMotion;                               // 0x10C9(0x0006)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10CF[0x1];                                     // 0x10CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UMordhauMotion>>     Motions;                                           // 0x10D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UEmoteMotion>>       EmoteMotions;                                      // 0x10E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FEmoteEntry>                    CharacterEmotes;                                   // 0x10F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEmoteEntry>                    UnarmedEmotes;                                     // 0x1100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bWantsCharacterRebuild;                            // 0x1110(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1111[0x7];                                     // 0x1111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMordhauWearable*>               WearableObjectInstances;                           // 0x1118(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCharacterProfile                      Profile;                                           // 0x1128(0x00B8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bDestroyEquipmentOnDeath;                          // 0x11E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EquipmentInventorySize;                            // 0x11E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E2[0x6];                                     // 0x11E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AMordhauEquipment*>              Equipment;                                         // 0x11E8(0x0010)(BlueprintVisible, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	class AMordhauEquipment*                      RightHandEquipment;                                // 0x11F8(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMordhauEquipment*                      LeftHandEquipment;                                 // 0x1200(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UQuiver>                    Quiver;                                            // 0x1208(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AKickWeapon*                            KickWeapon;                                        // 0x1210(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanJumpKick;                                      // 0x1218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysStunInsteadOfDisarm;                        // 0x1219(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121A[0x2];                                     // 0x121A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallingTimeToScream;                               // 0x121C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DodgeSound;                                        // 0x1220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              DodgeSoundLocalPlayer;                             // 0x1228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SnappyArmorFoley;                                  // 0x1230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              NonSnappyArmorFoley;                               // 0x1238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              CrouchStartSound;                                  // 0x1240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              CrouchEndSound;                                    // 0x1248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ReleaseFoley;                                      // 0x1250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         LastArmorFoley;                                    // 0x1258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AMordhauCharacter* Character)> OnPreBeginPlay;                                    // 0x1260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AMordhauCharacter* Character)> OnVehicleChanged;                                  // 0x1270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AMordhauCharacter* Character)> OnCameraStyleChanged;                              // 0x1280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1290[0x8];                                     // 0x1290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AMordhauCharacter* Character)> OnCharacterBuilt;                                  // 0x1298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A8[0x8];                                     // 0x12A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AppendBodySet(TSet<class FName>* Outset);
	static void AppendHeadSet(TSet<class FName>* Outset);
	static void AppendLeftArmSet(TSet<class FName>* Outset);
	static void AppendLeftLegSet(TSet<class FName>* Outset);
	static void AppendRightArmSet(TSet<class FName>* Outset);
	static void AppendRightLegSet(TSet<class FName>* Outset);
	static bool IsArm(const class FName& bone);
	static bool IsBody(const class FName& bone);
	static bool IsHead(const class FName& bone);
	static bool IsLeftArm(const class FName& bone);
	static bool IsLeftLeg(const class FName& bone);
	static bool IsLeg(const class FName& bone);
	static bool IsRightArm(const class FName& bone);
	static bool IsRightLeg(const class FName& bone);

	void AssignNetBlock(const struct FBlockResult& BlockResult, EAttackMove BlockedMove, class AActor* Weapon);
	void AssignNetMotionSimple(uint8 MotionType, uint8 Param0, uint8 Param1, uint8 Param2);
	void AssignProfile(const struct FCharacterProfile& NewProfile);
	void BakeFaceCustomizationTransforms(bool bDeferBake);
	void BlockPressed();
	void BlockReleased();
	void BuildCharacter();
	void CalculateLedgeOffsetAndNormal(class UClimbingMotion* ClimbingMotion, struct FVector* OutOffset, struct FVector* OutNormal);
	bool CanAccomodate(TSubclassOf<class AMordhauEquipment> EquipmentToTest);
	bool CanDismember(const class FName& bone);
	bool CanInitiateMotion(TSubclassOf<class UMordhauMotion> NewMotion, bool bAttemptCancel);
	bool CanPerformAttack(EAttackMove Move);
	void ClientSetNetMotion(const struct FNetMotion& NewMotion, float ServerStartTime);
	void CrouchPressed();
	void CrouchReleased();
	void CycleCamera();
	void DisableBlockCollider();
	void DisableLimb(class FName BoneName);
	class ASeparatedBodyPart* Dismember(struct FDismemberedBoneData* InDismemberedBoneData);
	void DoCameraShakeIfViewTarget(TSubclassOf<class UMatineeCameraShake> Shake, float Scale, ECameraShakePlaySpace PlaySpace, const struct FRotator& UserPlaySpaceRot, ECameraShakeType ShakeType);
	class AMordhauEquipment* DropEquipment(class AMordhauEquipment* ToDrop, bool bForce);
	class AMordhauEquipment* DropSlot(uint8 Index_0, bool bForce);
	void EmptyHands();
	void EnableBlockCollider();
	void EnteredTeamArea(int32 OwningTeam);
	bool EquipSlot(uint8 Index_0, bool bDisplayEquipmentList);
	void EquipSlot1();
	void EquipSlot2();
	void EquipSlot3();
	void EquipSlot4();
	void EquipSlot5();
	void EquipSlot6();
	void EquipSlot7();
	void EquipSlot8();
	void EquipSlot9();
	void ExplodeLimbs(const struct FVector& Force, class AActor* DamageCauser, class AController* InstigatedByController);
	void FeintOrBlockPressed();
	void FeintOrBlockReleased();
	class AController* FindBestKiller(float CutOffTime);
	class AMordhauEquipment* FindEquipmentToRestock(const TArray<TSubclassOf<class AMordhauEquipment>>& ValidEquipment);
	void FirePressed();
	void FireReleased();
	void FlipAttackSidePressed();
	void FlipAttackSideReleased();
	void ForceUpdateMeshVisibility();
	void FreeHandsForEquipment(class AMordhauEquipment* EquipmentInstigator);
	TArray<class FName> GetAllFaceSelectionChildBonesRecursive(class FName ParentBone);
	class ACustomizationReplicationActor* GetCustomizationReplicationActor();
	int32 GetFaceCustomizationBoneIdx(class FName BoneName);
	struct FVector GetFaceCustomizationRotate(class FName BoneName);
	struct FVector GetFaceCustomizationScale(class FName BoneName);
	struct FTransform GetFaceCustomizationTransform(class FName BoneName);
	struct FVector GetFaceCustomizationTranslate(class FName BoneName);
	class AActor* GetLastMovementFrontalHitActor(float MaxAgeSeconds);
	float GetLastVehicleTime();
	class UAudioComponent* GetLastVoiceCommand();
	bool HasEquipmentHeSpawnedWith();
	void Holster(class AMordhauEquipment* ToHolster);
	bool IsBoneDismembered(class FName bone);
	bool IsHoldingBlock();
	bool IsInKnockback();
	void JumpPressed();
	void JumpReleased();
	void LeftTeamArea(int32 OwningTeam);
	void ListenForStab360();
	void ListenForStrike360();
	bool ModifyParryResult(bool InResult, const struct FHitResult& HitResult, class AMordhauCharacter* Attacker);
	void MoveBlockedBySlow(const struct FHitResult& Impact);
	void NextEquipment();
	void NextEquipmentPressed();
	void NextEquipmentReleased();
	void NextShieldEquipment();
	void OffsetStamina(int32 Amount, bool bReplicate);
	void OnActionFailed(class FName Reason);
	void OnAttackStarted();
	void OnBlockedMelee(const struct FHitResult& HitResult, class AMordhauCharacter* Attacker);
	void OnDropped(class AMordhauEquipment* Eq);
	void OnModifyAttackInfo();
	void OnPickedUp(class AMordhauEquipment* Eq);
	void OnPostDismember(class FName bone, class ASeparatedBodyPart* SeparatedPart, class AActor* Agent);
	void OnPostProfileAssigned();
	void OnRep_Equipment();
	void OnRep_LeftHandEquipment();
	void OnRep_NetBlock();
	void OnRep_Quiver();
	void OnRep_ReplicatedCustomizationReplicationActor();
	void OnRep_ReplicatedDodge();
	void OnRep_ReplicatedKnockback();
	void OnRep_ReplicatedNetMotion();
	void OnRep_ReplicatedStamina();
	void OnRep_ReplicatedVoiceCommand();
	void OnRep_RightHandEquipment();
	bool PerformVoiceCommand(uint8 PackedVoiceCommand);
	bool PickUp(class AMordhauEquipment* ToEquip, int32 PreferredSlot);
	bool PickUpToSlot(class AMordhauEquipment* ToEquip, uint8 Slot);
	void PlayAttackYell();
	void PlayDeathYell(bool bIsLongYell);
	void PlayHurtYell();
	class UAudioComponent* PlayMouthSound(class USoundBase* Sound, float VolumeMultiplier);
	class UAudioComponent* PlayNonSnappyArmorFoley();
	class UAudioComponent* PlaySnappyArmorFoley();
	void PreviousEquipment();
	void PreviousEquipmentPressed();
	void PreviousEquipmentReleased();
	void PreviousShieldEquipment();
	bool QueueDismember(class FName bone, bool bIsDismemberPartial, bool bIsBluntForce, const struct FVector& Force, class AActor* Agent);
	void RequestAttack(EAttackMove Move, float Angle);
	void RequestBash();
	void RequestClimb(const struct FVector& TargetLocation, bool bIsSlowClimb);
	void RequestCouchedAttack();
	void RequestDrop();
	void RequestEmote(uint8 EmoteId);
	void RequestFeint();
	void RequestFire();
	void RequestHolster(uint8 Mode);
	void RequestJump();
	void RequestKick();
	void RequestLeftLowerStrike();
	void RequestLeftStab();
	void RequestLeftStrike();
	void RequestLeftUpperStrike();
	bool RequestParry(EBlockType BlockType, bool bAllowFTP);
	void RequestRangedCancel();
	void RequestRightLowerStrike();
	void RequestRightStab();
	void RequestRightStrike();
	void RequestRightUpperStrike();
	void RequestStab360();
	void RequestStrike360();
	void RequestToggleWeaponMode();
	void RequestUse();
	void RequestVoiceCommand(uint8 CommandType, bool bAllowQueue);
	TArray<class AMordhauEquipment*> RestockDefaultEquipment(int32 MaxSlotsToRestock);
	bool RestockEquipmentFromAmmoBox();
	void ServerAssignFireAim(const struct FVector& Orig, const struct FRotator& Rot);
	void ServerAssignNetMotion(const struct FNetMotion& NewNetMotion, uint8 LastAuthObserved);
	void ServerDropParry(uint8 MotionID);
	void ServerFinishInteraction(uint8 Result);
	void ServerQueueAttack(EAttackMove Move, uint8 Angle, uint8 MotionID);
	void ServerRequestDodge(uint8 PackedWorldYaw);
	void ServerRequestPassiveInteraction(class AActor* Target);
	void ServerRequestVoiceCommand(uint8 VoiceRequest);
	void ServerSetInteractionTarget(class AActor* Target);
	void ServerSuggestHitDetection(class AAdvancedCharacter* OtherCharacter, const struct FVector_NetQuantize& HitLocation, uint8 BoneId);
	void SetCameraStyle(uint8 NewStyle, bool bBlendCamera);
	void SetCurrentlyTracking(class AActor* NewTrackingTarget);
	void SetCustomizationReplicationActor(class ACustomizationReplicationActor* CRA);
	void SetFaceCustomizationRotate(class FName BoneName, const struct FVector& Vector);
	void SetFaceCustomizationScale(class FName BoneName, const struct FVector& Vector);
	void SetFaceCustomizationTranslate(class FName BoneName, const struct FVector& Vector);
	void SetQuiver(TSubclassOf<class UQuiver> NewQuiver);
	void ShowEquipmentIfViewTarget();
	void SprintingMoveBlockedBy(class AActor* BlockedBy);
	void SprintPressed();
	void SprintReleased();
	void StartCrouching();
	void StartScreaming();
	void StartSprinting();
	void StartSupersprint();
	void StopAttackYell();
	void StopCrouching();
	void StopCurrentVoiceCommand();
	void StopListenForStab360();
	void StopListenForStrike360();
	void StopScreaming();
	void StopSprinting();
	void StopStaminaRegen(float ExtraTime);
	void StopSupersprint();
	void SwitchEquipment(class AMordhauEquipment* ToSwitch);
	void SwitchEquipmentByIndex(uint8 Index_0);
	void SwitchModeAndReAttach(class AMordhauEquipment* ToSwitch);
	void SwitchToFists();
	void SwitchToNextAvailableEquipment();
	void ToggleWeaponModePressed();
	void ToggleWeaponModeReleased();
	bool TryClimbing();
	bool TryDismember(class FName bone, const struct FVector& Point, class AMordhauWeapon* Weapon, EAttackMove Move, bool bIsRagdollDismember);
	void UpdateAllSkeletalMeshComponentMaterials();
	void UpdateFPCamera(float DeltaSeconds, float InLookUpValue, bool bOnlyUpdateRotation, const struct FRotator& Offset);
	void UpdateLOD(float DeltaTime);
	void UpdateWearableInstanceColorsAndPatterns();
	void UsePressed();
	void UseReleased();
	bool ValidateInteractionTarget(class AActor* TargetActor);

	bool CanEasyParry() const;
	bool CanEmote() const;
	bool CheckCanEquip(class AMordhauEquipment* Equip) const;
	bool CheckCanEquipAlt(class AMordhauEquipment* Equip) const;
	class ULODSkeletalMeshComponent* GetClothMesh() const;
	struct FNetMotion GetCurrentNetMotion() const;
	bool GetEquipmentIndex(const class AMordhauEquipment* Equip, uint8* OutIndex) const;
	class UMordhauVehicleComponent* GetLastUsedVehicle(float MaximumTimeDiscrepancy) const;
	EMovementRestriction GetMovementRestriction() const;
	bool HasPerk(uint8 PerkId) const;
	bool IsInAnyTeamArea() const;
	bool IsInEnemyTeamArea() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauCharacter">();
	}
	static class AMordhauCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauCharacter>();
	}
};
static_assert(alignof(AMordhauCharacter) == 0x000010, "Wrong alignment on AMordhauCharacter");
static_assert(sizeof(AMordhauCharacter) == 0x0012B0, "Wrong size on AMordhauCharacter");
static_assert(offsetof(AMordhauCharacter, Motion) == 0x000B08, "Member 'AMordhauCharacter::Motion' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, WearableProtectionCoverageMap) == 0x000B18, "Member 'AMordhauCharacter::WearableProtectionCoverageMap' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, MordhauCamera) == 0x000B78, "Member 'AMordhauCharacter::MordhauCamera' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, FaceCustomizationComponent) == 0x000B80, "Member 'AMordhauCharacter::FaceCustomizationComponent' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, NextAllowedVoiceCommandTime) == 0x000B88, "Member 'AMordhauCharacter::NextAllowedVoiceCommandTime' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bWantsClimb) == 0x000B8C, "Member 'AMordhauCharacter::bWantsClimb' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bCannotChamber) == 0x000B8D, "Member 'AMordhauCharacter::bCannotChamber' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bAllowDrop) == 0x000B8E, "Member 'AMordhauCharacter::bAllowDrop' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bAllowClimbing) == 0x000B8F, "Member 'AMordhauCharacter::bAllowClimbing' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bAllowVehicles) == 0x000B90, "Member 'AMordhauCharacter::bAllowVehicles' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bAllowEquipmentRotate) == 0x000B91, "Member 'AMordhauCharacter::bAllowEquipmentRotate' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, InTeamAreaSince) == 0x000B94, "Member 'AMordhauCharacter::InTeamAreaSince' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bOverrideIsInEnemyTeamArea) == 0x000B98, "Member 'AMordhauCharacter::bOverrideIsInEnemyTeamArea' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bIsHoldingBlock) == 0x000B99, "Member 'AMordhauCharacter::bIsHoldingBlock' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bIsHoldingModeSwitch) == 0x000B9A, "Member 'AMordhauCharacter::bIsHoldingModeSwitch' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, HoldingModeSwitchTime) == 0x000B9C, "Member 'AMordhauCharacter::HoldingModeSwitchTime' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, TimeToHoldModeSwitchForOtherHand) == 0x000BA0, "Member 'AMordhauCharacter::TimeToHoldModeSwitchForOtherHand' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, OverrideSpineSpaceAdditive) == 0x000BA4, "Member 'AMordhauCharacter::OverrideSpineSpaceAdditive' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bUseOverrideSpineSpaceAdditive) == 0x000C28, "Member 'AMordhauCharacter::bUseOverrideSpineSpaceAdditive' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, SpineSpaceAdditiveTarget) == 0x000C2C, "Member 'AMordhauCharacter::SpineSpaceAdditiveTarget' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, SpineSpaceAdditiveFrom) == 0x000CB0, "Member 'AMordhauCharacter::SpineSpaceAdditiveFrom' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bIsLeftArmDisabled) == 0x000D40, "Member 'AMordhauCharacter::bIsLeftArmDisabled' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bIsRightArmDisabled) == 0x000D41, "Member 'AMordhauCharacter::bIsRightArmDisabled' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bIsLeftLegDisabled) == 0x000D42, "Member 'AMordhauCharacter::bIsLeftLegDisabled' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bIsRightLegDisabled) == 0x000D43, "Member 'AMordhauCharacter::bIsRightLegDisabled' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, FaceCustomizationSetup) == 0x000D48, "Member 'AMordhauCharacter::FaceCustomizationSetup' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bDoNotAnimateBreathing) == 0x000D58, "Member 'AMordhauCharacter::bDoNotAnimateBreathing' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bDoNotUseGrounding) == 0x000D59, "Member 'AMordhauCharacter::bDoNotUseGrounding' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bIsSoundDisabled) == 0x000D5A, "Member 'AMordhauCharacter::bIsSoundDisabled' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bDoNotLookAtOthers) == 0x000D5B, "Member 'AMordhauCharacter::bDoNotLookAtOthers' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, ReplicatedDodge) == 0x000D5C, "Member 'AMordhauCharacter::ReplicatedDodge' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, ReplicatedKnockback) == 0x000D5D, "Member 'AMordhauCharacter::ReplicatedKnockback' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, ReplicatedVoiceCommand) == 0x000D5E, "Member 'AMordhauCharacter::ReplicatedVoiceCommand' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, ReplicatedCustomizationReplicationActor) == 0x000D60, "Member 'AMordhauCharacter::ReplicatedCustomizationReplicationActor' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, FaceCustomizationBonesTransforms) == 0x000D68, "Member 'AMordhauCharacter::FaceCustomizationBonesTransforms' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CurrentCapturePoint) == 0x000D80, "Member 'AMordhauCharacter::CurrentCapturePoint' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CurrentCapturePointTime) == 0x000D88, "Member 'AMordhauCharacter::CurrentCapturePointTime' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bForceColorOverrides) == 0x000D8C, "Member 'AMordhauCharacter::bForceColorOverrides' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, ColorAOverride) == 0x000D90, "Member 'AMordhauCharacter::ColorAOverride' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, ColorBOverride) == 0x000DA0, "Member 'AMordhauCharacter::ColorBOverride' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CurrentForcedLOD) == 0x000DB0, "Member 'AMordhauCharacter::CurrentForcedLOD' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, ActorsThatDestroyWithUs) == 0x000DB8, "Member 'AMordhauCharacter::ActorsThatDestroyWithUs' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CurrentBleedOutParticles) == 0x000DC8, "Member 'AMordhauCharacter::CurrentBleedOutParticles' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, LastMovementFrontalHitActor) == 0x000DD0, "Member 'AMordhauCharacter::LastMovementFrontalHitActor' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bWantsCrouch) == 0x000DE4, "Member 'AMordhauCharacter::bWantsCrouch' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CrouchCooldown) == 0x000DE8, "Member 'AMordhauCharacter::CrouchCooldown' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, SprintingMoveBlockedByFractionToTrigger) == 0x000DEC, "Member 'AMordhauCharacter::SprintingMoveBlockedByFractionToTrigger' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, MoveBlockedBySlowMinInterval) == 0x000DF0, "Member 'AMordhauCharacter::MoveBlockedBySlowMinInterval' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, ClimbTargetLocation) == 0x000DF8, "Member 'AMordhauCharacter::ClimbTargetLocation' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, LastNoticeableLookChange) == 0x000E04, "Member 'AMordhauCharacter::LastNoticeableLookChange' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, PreviousLookValues) == 0x000E08, "Member 'AMordhauCharacter::PreviousLookValues' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, NoticeableLookChangeMinRate) == 0x000E10, "Member 'AMordhauCharacter::NoticeableLookChangeMinRate' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, DamageHistory) == 0x000E18, "Member 'AMordhauCharacter::DamageHistory' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, StructureDamageModifier) == 0x000E38, "Member 'AMordhauCharacter::StructureDamageModifier' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, StructureRepairModifier) == 0x000E3C, "Member 'AMordhauCharacter::StructureRepairModifier' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, ExtraStaminaOnHit) == 0x000E40, "Member 'AMordhauCharacter::ExtraStaminaOnHit' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, StaminaCostModifier) == 0x000E44, "Member 'AMordhauCharacter::StaminaCostModifier' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, MeleeWindupModifier) == 0x000E48, "Member 'AMordhauCharacter::MeleeWindupModifier' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, MeleeComboExtraWindupModifier) == 0x000E4C, "Member 'AMordhauCharacter::MeleeComboExtraWindupModifier' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, MeleeReleaseModifier) == 0x000E50, "Member 'AMordhauCharacter::MeleeReleaseModifier' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, MeleeMissRecoveryModifier) == 0x000E54, "Member 'AMordhauCharacter::MeleeMissRecoveryModifier' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, LegDamageBonusModifierAirborne) == 0x000E58, "Member 'AMordhauCharacter::LegDamageBonusModifierAirborne' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bIsUnflinchable) == 0x000E5C, "Member 'AMordhauCharacter::bIsUnflinchable' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, UnflinchableDamageThreshold) == 0x000E60, "Member 'AMordhauCharacter::UnflinchableDamageThreshold' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bIsHitStopOnTeamHitsDisabled) == 0x000E64, "Member 'AMordhauCharacter::bIsHitStopOnTeamHitsDisabled' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bDisableProjectileRangedDrawFlinch) == 0x000E65, "Member 'AMordhauCharacter::bDisableProjectileRangedDrawFlinch' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bCanDodge) == 0x000E66, "Member 'AMordhauCharacter::bCanDodge' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, Stamina) == 0x000E67, "Member 'AMordhauCharacter::Stamina' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, ReplicatedStamina) == 0x000E68, "Member 'AMordhauCharacter::ReplicatedStamina' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, StaminaRegenPerTick) == 0x000E69, "Member 'AMordhauCharacter::StaminaRegenPerTick' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, StaminaRegenDelay) == 0x000E6C, "Member 'AMordhauCharacter::StaminaRegenDelay' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, StaminaOnKill) == 0x000E70, "Member 'AMordhauCharacter::StaminaOnKill' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, HealthOnKill) == 0x000E74, "Member 'AMordhauCharacter::HealthOnKill' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, StaminaRegenTickRate) == 0x000E78, "Member 'AMordhauCharacter::StaminaRegenTickRate' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, JumpStaminaCost) == 0x000E7C, "Member 'AMordhauCharacter::JumpStaminaCost' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, LastEnemyKilledTimeWithMeleeOrRanged) == 0x000E80, "Member 'AMordhauCharacter::LastEnemyKilledTimeWithMeleeOrRanged' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, KnockbackParry) == 0x000E84, "Member 'AMordhauCharacter::KnockbackParry' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, KnockbackWorld) == 0x000E88, "Member 'AMordhauCharacter::KnockbackWorld' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, KnockbackClash) == 0x000E8C, "Member 'AMordhauCharacter::KnockbackClash' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, EasyParryUntilTime) == 0x000E94, "Member 'AMordhauCharacter::EasyParryUntilTime' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, FallingTime) == 0x000E98, "Member 'AMordhauCharacter::FallingTime' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, FallingTimeToRagdoll) == 0x000E9C, "Member 'AMordhauCharacter::FallingTimeToRagdoll' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, LastDodgeTime) == 0x000EA0, "Member 'AMordhauCharacter::LastDodgeTime' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, DodgeDuration) == 0x000EA4, "Member 'AMordhauCharacter::DodgeDuration' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, DodgeCooldown) == 0x000EA8, "Member 'AMordhauCharacter::DodgeCooldown' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, DodgeStaminaCost) == 0x000EAC, "Member 'AMordhauCharacter::DodgeStaminaCost' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bWasDodgeCanceled) == 0x000EB0, "Member 'AMordhauCharacter::bWasDodgeCanceled' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, DodgeDirection) == 0x000EB4, "Member 'AMordhauCharacter::DodgeDirection' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, DodgeDirectionLocal) == 0x000EC0, "Member 'AMordhauCharacter::DodgeDirectionLocal' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, TotalChaseTime) == 0x000ECC, "Member 'AMordhauCharacter::TotalChaseTime' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, LastChaseTime) == 0x000ED0, "Member 'AMordhauCharacter::LastChaseTime' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, TotalChasedTime) == 0x000ED4, "Member 'AMordhauCharacter::TotalChasedTime' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, LastChasedTime) == 0x000ED8, "Member 'AMordhauCharacter::LastChasedTime' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, SkinnyPose) == 0x000EE0, "Member 'AMordhauCharacter::SkinnyPose' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, FatPose) == 0x000EE8, "Member 'AMordhauCharacter::FatPose' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, StrongPose) == 0x000EF0, "Member 'AMordhauCharacter::StrongPose' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bUseReducedBodyPoses) == 0x000EF8, "Member 'AMordhauCharacter::bUseReducedBodyPoses' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bIgnoresTeamColors) == 0x000EF9, "Member 'AMordhauCharacter::bIgnoresTeamColors' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bWasHitAfterDeath) == 0x000EFA, "Member 'AMordhauCharacter::bWasHitAfterDeath' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CurrentlyTracking) == 0x000EFC, "Member 'AMordhauCharacter::CurrentlyTracking' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, LastTrackingUpdate) == 0x000F04, "Member 'AMordhauCharacter::LastTrackingUpdate' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bIsFirstPerson) == 0x000F08, "Member 'AMordhauCharacter::bIsFirstPerson' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CameraStyle) == 0x000F09, "Member 'AMordhauCharacter::CameraStyle' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CurrentSpeedFOVOffset) == 0x000F0C, "Member 'AMordhauCharacter::CurrentSpeedFOVOffset' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, MaxSprintFOVOffset) == 0x000F10, "Member 'AMordhauCharacter::MaxSprintFOVOffset' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, MaxSprintFOVOffsetInterpSpeed) == 0x000F14, "Member 'AMordhauCharacter::MaxSprintFOVOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CameraLocation1P) == 0x000F18, "Member 'AMordhauCharacter::CameraLocation1P' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CameraLocation1PCosmeticOffset) == 0x000F24, "Member 'AMordhauCharacter::CameraLocation1PCosmeticOffset' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CameraRotation1P) == 0x000F30, "Member 'AMordhauCharacter::CameraRotation1P' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CameraRotation1PMeshSpace) == 0x000F3C, "Member 'AMordhauCharacter::CameraRotation1PMeshSpace' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, EllipseBubbleLength) == 0x000F48, "Member 'AMordhauCharacter::EllipseBubbleLength' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, EllipseBubbleRadius) == 0x000F4C, "Member 'AMordhauCharacter::EllipseBubbleRadius' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, EllipseBubbleMaxHeightDiff) == 0x000F50, "Member 'AMordhauCharacter::EllipseBubbleMaxHeightDiff' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, BlockColliderForwardParryDistance) == 0x000F54, "Member 'AMordhauCharacter::BlockColliderForwardParryDistance' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, BlockCollider) == 0x000F60, "Member 'AMordhauCharacter::BlockCollider' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, LowBlockColliderRelativeOffset) == 0x000F70, "Member 'AMordhauCharacter::LowBlockColliderRelativeOffset' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, HighBlockColliderRelativeOffset) == 0x000FA0, "Member 'AMordhauCharacter::HighBlockColliderRelativeOffset' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, OriginalBlockColliderRelativeOffset) == 0x000FD0, "Member 'AMordhauCharacter::OriginalBlockColliderRelativeOffset' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, LastRequestedFireOrigin) == 0x001010, "Member 'AMordhauCharacter::LastRequestedFireOrigin' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, LastRequestedFireRotation) == 0x00101C, "Member 'AMordhauCharacter::LastRequestedFireRotation' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bWantsFire) == 0x001028, "Member 'AMordhauCharacter::bWantsFire' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bWantsBlock) == 0x001029, "Member 'AMordhauCharacter::bWantsBlock' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bWantsFeintOrBlock) == 0x00102A, "Member 'AMordhauCharacter::bWantsFeintOrBlock' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, SprintFootstepParticles) == 0x001030, "Member 'AMordhauCharacter::SprintFootstepParticles' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, BloodHitEffect) == 0x001040, "Member 'AMordhauCharacter::BloodHitEffect' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, BloodMetalHitEffect) == 0x001048, "Member 'AMordhauCharacter::BloodMetalHitEffect' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, BleedingOutParticleEffect) == 0x001050, "Member 'AMordhauCharacter::BleedingOutParticleEffect' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, DodgeParticleEffect) == 0x001058, "Member 'AMordhauCharacter::DodgeParticleEffect' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, DodgeCameraShake) == 0x001060, "Member 'AMordhauCharacter::DodgeCameraShake' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, FallDamageCameraShake) == 0x001068, "Member 'AMordhauCharacter::FallDamageCameraShake' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, RunLeftHeadBobShake) == 0x001070, "Member 'AMordhauCharacter::RunLeftHeadBobShake' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, RunRightHeadBobShake) == 0x001078, "Member 'AMordhauCharacter::RunRightHeadBobShake' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, WalkLeftHeadBobShake) == 0x001080, "Member 'AMordhauCharacter::WalkLeftHeadBobShake' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, WalkRightHeadBobShake) == 0x001088, "Member 'AMordhauCharacter::WalkRightHeadBobShake' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, BlockShakeEffect) == 0x001090, "Member 'AMordhauCharacter::BlockShakeEffect' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, BlockedShakeEffect) == 0x001098, "Member 'AMordhauCharacter::BlockedShakeEffect' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, FlinchShakeEffect) == 0x0010A0, "Member 'AMordhauCharacter::FlinchShakeEffect' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, NetBlock) == 0x0010A8, "Member 'AMordhauCharacter::NetBlock' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CurrentVehicle) == 0x0010C0, "Member 'AMordhauCharacter::CurrentVehicle' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, DeathSyncedRandom) == 0x0010C8, "Member 'AMordhauCharacter::DeathSyncedRandom' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, ReplicatedNetMotion) == 0x0010C9, "Member 'AMordhauCharacter::ReplicatedNetMotion' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, Motions) == 0x0010D0, "Member 'AMordhauCharacter::Motions' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, EmoteMotions) == 0x0010E0, "Member 'AMordhauCharacter::EmoteMotions' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CharacterEmotes) == 0x0010F0, "Member 'AMordhauCharacter::CharacterEmotes' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, UnarmedEmotes) == 0x001100, "Member 'AMordhauCharacter::UnarmedEmotes' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bWantsCharacterRebuild) == 0x001110, "Member 'AMordhauCharacter::bWantsCharacterRebuild' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, WearableObjectInstances) == 0x001118, "Member 'AMordhauCharacter::WearableObjectInstances' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, Profile) == 0x001128, "Member 'AMordhauCharacter::Profile' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bDestroyEquipmentOnDeath) == 0x0011E0, "Member 'AMordhauCharacter::bDestroyEquipmentOnDeath' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, EquipmentInventorySize) == 0x0011E1, "Member 'AMordhauCharacter::EquipmentInventorySize' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, Equipment) == 0x0011E8, "Member 'AMordhauCharacter::Equipment' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, RightHandEquipment) == 0x0011F8, "Member 'AMordhauCharacter::RightHandEquipment' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, LeftHandEquipment) == 0x001200, "Member 'AMordhauCharacter::LeftHandEquipment' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, Quiver) == 0x001208, "Member 'AMordhauCharacter::Quiver' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, KickWeapon) == 0x001210, "Member 'AMordhauCharacter::KickWeapon' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bCanJumpKick) == 0x001218, "Member 'AMordhauCharacter::bCanJumpKick' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, bAlwaysStunInsteadOfDisarm) == 0x001219, "Member 'AMordhauCharacter::bAlwaysStunInsteadOfDisarm' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, FallingTimeToScream) == 0x00121C, "Member 'AMordhauCharacter::FallingTimeToScream' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, DodgeSound) == 0x001220, "Member 'AMordhauCharacter::DodgeSound' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, DodgeSoundLocalPlayer) == 0x001228, "Member 'AMordhauCharacter::DodgeSoundLocalPlayer' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, SnappyArmorFoley) == 0x001230, "Member 'AMordhauCharacter::SnappyArmorFoley' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, NonSnappyArmorFoley) == 0x001238, "Member 'AMordhauCharacter::NonSnappyArmorFoley' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CrouchStartSound) == 0x001240, "Member 'AMordhauCharacter::CrouchStartSound' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, CrouchEndSound) == 0x001248, "Member 'AMordhauCharacter::CrouchEndSound' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, ReleaseFoley) == 0x001250, "Member 'AMordhauCharacter::ReleaseFoley' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, LastArmorFoley) == 0x001258, "Member 'AMordhauCharacter::LastArmorFoley' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, OnPreBeginPlay) == 0x001260, "Member 'AMordhauCharacter::OnPreBeginPlay' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, OnVehicleChanged) == 0x001270, "Member 'AMordhauCharacter::OnVehicleChanged' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, OnCameraStyleChanged) == 0x001280, "Member 'AMordhauCharacter::OnCameraStyleChanged' has a wrong offset!");
static_assert(offsetof(AMordhauCharacter, OnCharacterBuilt) == 0x001298, "Member 'AMordhauCharacter::OnCharacterBuilt' has a wrong offset!");

// Class Mordhau.MordhauCheatManager
// 0x0000 (0x0078 - 0x0078)
class UMordhauCheatManager final : public UCheatManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauCheatManager">();
	}
	static class UMordhauCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauCheatManager>();
	}
};
static_assert(alignof(UMordhauCheatManager) == 0x000008, "Wrong alignment on UMordhauCheatManager");
static_assert(sizeof(UMordhauCheatManager) == 0x000078, "Wrong size on UMordhauCheatManager");

// Class Mordhau.MordhauCompoundVehicle
// 0x0000 (0x0B90 - 0x0B90)
#pragma pack(push, 0x1)
class alignas(0x10) AMordhauCompoundVehicle : public AMordhauVehicle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauCompoundVehicle">();
	}
	static class AMordhauCompoundVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauCompoundVehicle>();
	}
};
#pragma pack(pop)
static_assert(alignof(AMordhauCompoundVehicle) == 0x000010, "Wrong alignment on AMordhauCompoundVehicle");
static_assert(sizeof(AMordhauCompoundVehicle) == 0x000B90, "Wrong size on AMordhauCompoundVehicle");

// Class Mordhau.MordhauCrowdFollowingComponent
// 0x0010 (0x02A8 - 0x0298)
class UMordhauCrowdFollowingComponent final : public UCrowdFollowingComponent
{
public:
	float                                         PheromoneDepositAmount;                            // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PheromoneDepositInterval;                          // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauCrowdFollowingComponent">();
	}
	static class UMordhauCrowdFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauCrowdFollowingComponent>();
	}
};
static_assert(alignof(UMordhauCrowdFollowingComponent) == 0x000008, "Wrong alignment on UMordhauCrowdFollowingComponent");
static_assert(sizeof(UMordhauCrowdFollowingComponent) == 0x0002A8, "Wrong size on UMordhauCrowdFollowingComponent");
static_assert(offsetof(UMordhauCrowdFollowingComponent, PheromoneDepositAmount) == 0x000298, "Member 'UMordhauCrowdFollowingComponent::PheromoneDepositAmount' has a wrong offset!");
static_assert(offsetof(UMordhauCrowdFollowingComponent, PheromoneDepositInterval) == 0x00029C, "Member 'UMordhauCrowdFollowingComponent::PheromoneDepositInterval' has a wrong offset!");

// Class Mordhau.MordhauEquipmentPart
// 0x0028 (0x0088 - 0x0060)
class UMordhauEquipmentPart : public UMordhauInventoryItem
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          AuxiliarySkeletalMesh;                             // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          SkinOverrideShadowPhysicsAsset;                    // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrailFactor;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondTrailFactor;                                 // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasColor1;                                        // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasColor2;                                        // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasColor3;                                        // 0x0082(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83[0x5];                                       // 0x0083(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauEquipmentPart">();
	}
	static class UMordhauEquipmentPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauEquipmentPart>();
	}
};
static_assert(alignof(UMordhauEquipmentPart) == 0x000008, "Wrong alignment on UMordhauEquipmentPart");
static_assert(sizeof(UMordhauEquipmentPart) == 0x000088, "Wrong size on UMordhauEquipmentPart");
static_assert(offsetof(UMordhauEquipmentPart, SkeletalMesh) == 0x000060, "Member 'UMordhauEquipmentPart::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UMordhauEquipmentPart, AuxiliarySkeletalMesh) == 0x000068, "Member 'UMordhauEquipmentPart::AuxiliarySkeletalMesh' has a wrong offset!");
static_assert(offsetof(UMordhauEquipmentPart, SkinOverrideShadowPhysicsAsset) == 0x000070, "Member 'UMordhauEquipmentPart::SkinOverrideShadowPhysicsAsset' has a wrong offset!");
static_assert(offsetof(UMordhauEquipmentPart, TrailFactor) == 0x000078, "Member 'UMordhauEquipmentPart::TrailFactor' has a wrong offset!");
static_assert(offsetof(UMordhauEquipmentPart, SecondTrailFactor) == 0x00007C, "Member 'UMordhauEquipmentPart::SecondTrailFactor' has a wrong offset!");
static_assert(offsetof(UMordhauEquipmentPart, bHasColor1) == 0x000080, "Member 'UMordhauEquipmentPart::bHasColor1' has a wrong offset!");
static_assert(offsetof(UMordhauEquipmentPart, bHasColor2) == 0x000081, "Member 'UMordhauEquipmentPart::bHasColor2' has a wrong offset!");
static_assert(offsetof(UMordhauEquipmentPart, bHasColor3) == 0x000082, "Member 'UMordhauEquipmentPart::bHasColor3' has a wrong offset!");

// Class Mordhau.MordhauEquipmentRemapper
// 0x00F8 (0x0318 - 0x0220)
class AMordhauEquipmentRemapper final : public AInfo
{
public:
	TMap<TSoftClassPtr<class UClass>, TSoftClassPtr<class UClass>> RemappedEquipmentClasses;                          // 0x0220(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UMordhauMotion>, TSubclassOf<class UMordhauMotion>> RemappedMotions;                                   // 0x0270(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class APawn>, TSubclassOf<class APawn>> RemappedPawns;                                     // 0x02C0(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bGMCasualTracking;                                 // 0x0310(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSubclassOf<class APawn> RemapPawn(TSubclassOf<class APawn> InCharacterClass);

	TSoftClassPtr<class UClass> RemapEquipment(TSoftClassPtr<class UClass> InEquipmentClass) const;
	TSubclassOf<class UMordhauMotion> RemapMotion(TSubclassOf<class UMordhauMotion> InMotionClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauEquipmentRemapper">();
	}
	static class AMordhauEquipmentRemapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauEquipmentRemapper>();
	}
};
static_assert(alignof(AMordhauEquipmentRemapper) == 0x000008, "Wrong alignment on AMordhauEquipmentRemapper");
static_assert(sizeof(AMordhauEquipmentRemapper) == 0x000318, "Wrong size on AMordhauEquipmentRemapper");
static_assert(offsetof(AMordhauEquipmentRemapper, RemappedEquipmentClasses) == 0x000220, "Member 'AMordhauEquipmentRemapper::RemappedEquipmentClasses' has a wrong offset!");
static_assert(offsetof(AMordhauEquipmentRemapper, RemappedMotions) == 0x000270, "Member 'AMordhauEquipmentRemapper::RemappedMotions' has a wrong offset!");
static_assert(offsetof(AMordhauEquipmentRemapper, RemappedPawns) == 0x0002C0, "Member 'AMordhauEquipmentRemapper::RemappedPawns' has a wrong offset!");
static_assert(offsetof(AMordhauEquipmentRemapper, bGMCasualTracking) == 0x000310, "Member 'AMordhauEquipmentRemapper::bGMCasualTracking' has a wrong offset!");

// Class Mordhau.GetFriendsList
// 0x0028 (0x0058 - 0x0030)
class UGetFriendsList final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(TArray<struct FMordhauFriend>& Friends)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<struct FMordhauFriend>& Friends)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGetFriendsList* GetFriendsList(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetFriendsList">();
	}
	static class UGetFriendsList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetFriendsList>();
	}
};
static_assert(alignof(UGetFriendsList) == 0x000008, "Wrong alignment on UGetFriendsList");
static_assert(sizeof(UGetFriendsList) == 0x000058, "Wrong size on UGetFriendsList");
static_assert(offsetof(UGetFriendsList, onSuccess) == 0x000030, "Member 'UGetFriendsList::onSuccess' has a wrong offset!");
static_assert(offsetof(UGetFriendsList, onFailure) == 0x000040, "Member 'UGetFriendsList::onFailure' has a wrong offset!");
static_assert(offsetof(UGetFriendsList, World) == 0x000050, "Member 'UGetFriendsList::World' has a wrong offset!");

// Class Mordhau.FindPlayerByEntityId
// 0x0038 (0x0068 - 0x0030)
class UFindPlayerByEntityId final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(struct FPlayFabPlayer& Player)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FPlayFabPlayer& Player)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 EntityId;                                          // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFindPlayerByEntityId* FindPlayerByEntityId(const class FString& EntityId_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FindPlayerByEntityId">();
	}
	static class UFindPlayerByEntityId* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFindPlayerByEntityId>();
	}
};
static_assert(alignof(UFindPlayerByEntityId) == 0x000008, "Wrong alignment on UFindPlayerByEntityId");
static_assert(sizeof(UFindPlayerByEntityId) == 0x000068, "Wrong size on UFindPlayerByEntityId");
static_assert(offsetof(UFindPlayerByEntityId, onSuccess) == 0x000030, "Member 'UFindPlayerByEntityId::onSuccess' has a wrong offset!");
static_assert(offsetof(UFindPlayerByEntityId, onFailure) == 0x000040, "Member 'UFindPlayerByEntityId::onFailure' has a wrong offset!");
static_assert(offsetof(UFindPlayerByEntityId, EntityId) == 0x000050, "Member 'UFindPlayerByEntityId::EntityId' has a wrong offset!");

// Class Mordhau.GetFriendRequests
// 0x0028 (0x0058 - 0x0030)
class UGetFriendRequests final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(TArray<struct FPlayFabPlayer>& Players)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<struct FPlayFabPlayer>& Players)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGetFriendRequests* GetFriendRequests();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetFriendRequests">();
	}
	static class UGetFriendRequests* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetFriendRequests>();
	}
};
static_assert(alignof(UGetFriendRequests) == 0x000008, "Wrong alignment on UGetFriendRequests");
static_assert(sizeof(UGetFriendRequests) == 0x000058, "Wrong size on UGetFriendRequests");
static_assert(offsetof(UGetFriendRequests, onSuccess) == 0x000030, "Member 'UGetFriendRequests::onSuccess' has a wrong offset!");
static_assert(offsetof(UGetFriendRequests, onFailure) == 0x000040, "Member 'UGetFriendRequests::onFailure' has a wrong offset!");

// Class Mordhau.DeclineFriendRequest
// 0x0090 (0x00C0 - 0x0030)
class UDeclineFriendRequest final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FPlayFabPlayer                         Player;                                            // 0x0050(0x0060)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 GroupName;                                         // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UDeclineFriendRequest* DeclineFriendRequest(const struct FPlayFabPlayer& Player_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeclineFriendRequest">();
	}
	static class UDeclineFriendRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeclineFriendRequest>();
	}
};
static_assert(alignof(UDeclineFriendRequest) == 0x000008, "Wrong alignment on UDeclineFriendRequest");
static_assert(sizeof(UDeclineFriendRequest) == 0x0000C0, "Wrong size on UDeclineFriendRequest");
static_assert(offsetof(UDeclineFriendRequest, onSuccess) == 0x000030, "Member 'UDeclineFriendRequest::onSuccess' has a wrong offset!");
static_assert(offsetof(UDeclineFriendRequest, onFailure) == 0x000040, "Member 'UDeclineFriendRequest::onFailure' has a wrong offset!");
static_assert(offsetof(UDeclineFriendRequest, Player) == 0x000050, "Member 'UDeclineFriendRequest::Player' has a wrong offset!");
static_assert(offsetof(UDeclineFriendRequest, GroupName) == 0x0000B0, "Member 'UDeclineFriendRequest::GroupName' has a wrong offset!");

// Class Mordhau.RemoveFriend
// 0x0088 (0x00B8 - 0x0030)
class URemoveFriend final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayFabPlayer                         Player;                                            // 0x0058(0x0060)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class URemoveFriend* RemoveFriend(class UObject* WorldContextObject, const struct FPlayFabPlayer& Player_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveFriend">();
	}
	static class URemoveFriend* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveFriend>();
	}
};
static_assert(alignof(URemoveFriend) == 0x000008, "Wrong alignment on URemoveFriend");
static_assert(sizeof(URemoveFriend) == 0x0000B8, "Wrong size on URemoveFriend");
static_assert(offsetof(URemoveFriend, onSuccess) == 0x000030, "Member 'URemoveFriend::onSuccess' has a wrong offset!");
static_assert(offsetof(URemoveFriend, onFailure) == 0x000040, "Member 'URemoveFriend::onFailure' has a wrong offset!");
static_assert(offsetof(URemoveFriend, World) == 0x000050, "Member 'URemoveFriend::World' has a wrong offset!");
static_assert(offsetof(URemoveFriend, Player) == 0x000058, "Member 'URemoveFriend::Player' has a wrong offset!");

// Class Mordhau.GetBlockedPlayers
// 0x0028 (0x0058 - 0x0030)
class UGetBlockedPlayers final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(TArray<struct FPlayFabPlayer>& Players)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<struct FPlayFabPlayer>& Players)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGetBlockedPlayers* GetBlockedPlayers(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetBlockedPlayers">();
	}
	static class UGetBlockedPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetBlockedPlayers>();
	}
};
static_assert(alignof(UGetBlockedPlayers) == 0x000008, "Wrong alignment on UGetBlockedPlayers");
static_assert(sizeof(UGetBlockedPlayers) == 0x000058, "Wrong size on UGetBlockedPlayers");
static_assert(offsetof(UGetBlockedPlayers, onSuccess) == 0x000030, "Member 'UGetBlockedPlayers::onSuccess' has a wrong offset!");
static_assert(offsetof(UGetBlockedPlayers, onFailure) == 0x000040, "Member 'UGetBlockedPlayers::onFailure' has a wrong offset!");
static_assert(offsetof(UGetBlockedPlayers, World) == 0x000050, "Member 'UGetBlockedPlayers::World' has a wrong offset!");

// Class Mordhau.UnblockPlayer
// 0x0088 (0x00B8 - 0x0030)
class UUnblockPlayer final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayFabPlayer                         Player;                                            // 0x0058(0x0060)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UUnblockPlayer* UnblockPlayer(class UObject* WorldContextObject, const struct FPlayFabPlayer& Player_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnblockPlayer">();
	}
	static class UUnblockPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnblockPlayer>();
	}
};
static_assert(alignof(UUnblockPlayer) == 0x000008, "Wrong alignment on UUnblockPlayer");
static_assert(sizeof(UUnblockPlayer) == 0x0000B8, "Wrong size on UUnblockPlayer");
static_assert(offsetof(UUnblockPlayer, onSuccess) == 0x000030, "Member 'UUnblockPlayer::onSuccess' has a wrong offset!");
static_assert(offsetof(UUnblockPlayer, onFailure) == 0x000040, "Member 'UUnblockPlayer::onFailure' has a wrong offset!");
static_assert(offsetof(UUnblockPlayer, World) == 0x000050, "Member 'UUnblockPlayer::World' has a wrong offset!");
static_assert(offsetof(UUnblockPlayer, Player) == 0x000058, "Member 'UUnblockPlayer::Player' has a wrong offset!");

// Class Mordhau.MordhauGameMode
// 0x02B0 (0x05B8 - 0x0308)
class AMordhauGameMode : public AGameMode
{
public:
	TArray<struct FGameModeName>                  MapPrefixes;                                       // 0x0308(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         MapRotation;                                       // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            MapGameModeOverrides;                              // 0x0328(0x0050)(Edit, BlueprintVisible, Config, GlobalConfig, NativeAccessSpecifierPublic)
	class FString                                 MOTDURL;                                           // 0x0378(0x0010)(BlueprintVisible, ZeroConstructor, Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsThirdPersonCameraDisabled;                      // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_389[0x3];                                      // 0x0389(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConstrainAspectRatio;                              // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHitStopOnTeamHitsDisabled;                      // 0x0390(0x0001)(BlueprintVisible, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableClientMods;                                // 0x0391(0x0001)(BlueprintVisible, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_392[0x6];                                      // 0x0392(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         SpawnServerActorsOnMapLoad;                        // 0x0398(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, GlobalConfig, NativeAccessSpecifierPublic)
	bool                                          bLogKillfeed;                                      // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogChat;                                          // 0x03A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogScore;                                         // 0x03AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSpawningServerActorsOnMapLoad;               // 0x03AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowAdminChat;                                   // 0x03AC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowWhisperChat;                                 // 0x03AD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AE[0x2];                                      // 0x03AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AController>>     SpawnQueue;                                        // 0x03B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AController>             CurrentlySpawningController;                       // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 CurrentlySpawningPlayerStart;                      // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentlySpawningStage;                            // 0x03D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchTimeRanOut;                                  // 0x03D4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D5[0x3];                                      // 0x03D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerRespawnTime;                                 // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesSlowPlayerSpawning;                           // 0x03DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCasualTracking;                                   // 0x03DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DE[0x2];                                      // 0x03DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AutoKickOnTeamKillAmount;                          // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayersSpawnInWaves;                              // 0x03E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayersDropAllGearOnDeath;                        // 0x03E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipmentDoesNotDespawn;                          // 0x03E6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E7[0x1];                                      // 0x03E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideEquipmentDespawnTime;                      // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BallistaRespawnTime;                               // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CatapultRespawnTime;                               // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorseRespawnTime;                                  // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         MapVoteMaps;                                       // 0x03F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EOfficialServerVisibility                     OfficialServerVisibility;                          // 0x0408(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_409[0x3];                                      // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageFactor;                                      // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeamDamageFactor;                                  // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamDamageFlinch;                                  // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnProtectionDuration;                           // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableDamage;                                    // 0x041C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableStamina;                                   // 0x041D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsScoringDisabled;                                // 0x041E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41F[0x1];                                      // 0x041F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AssistScoreFactor;                                 // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AssistDamageToCountAsKill;                         // 0x0424(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_425[0x3];                                      // 0x0425(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillScoreChange;                                   // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillTeamScoreChange;                               // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeamKillScoreChange;                               // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeamKillTeamScoreChange;                           // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeamKillsDecrementKillerKills;                    // 0x0438(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeamKillsIncrementKilledDeaths;                   // 0x0439(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuicideDecrementsKills;                           // 0x043A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43B[0x5];                                      // 0x043B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ChatMessages;                                      // 0x0440(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            MessageTypeMap;                                    // 0x0450(0x0050)(BlueprintVisible, Config, NativeAccessSpecifierPublic)
	TMap<class FString, struct FPlayerChatMessagesContainer> PlayerMessagesMap;                                 // 0x04A0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Payload, int32 ClientId)> OnRconStringCommand;                               // 0x04F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FRconEventStruct>               RconEvents;                                        // 0x0500(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Sender, const class FString& Msg, class FName Type)> OnMessageBroadcasted;                              // 0x0510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APlayerController* NewPlayer)> OnAfterLogin;                                      // 0x0520(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AController* Exiting)> OnBeforeLogout;                                    // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLevelChange;                                     // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FChatCommandStruct>             ChatCommands;                                      // 0x0550(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_560[0x50];                                     // 0x0560(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanEquipmentDrop;                                 // 0x05B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnDefaultEquipment;                            // 0x05B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSuicideAllowed;                                   // 0x05B2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B3[0x5];                                      // 0x05B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBots(int32 Amount, int32 Team);
	void AddTeamScore(int32 Team, float Amount);
	void Broadcast(class AActor* Sender, const class FString& Msg, class FName Type);
	bool CanChamber(class APawn* Source, class APawn* Target);
	bool CanClash(class APawn* Source, class APawn* Target);
	bool CanDealDamage(class AActor* DamageSource, class AActor* DamageTarget);
	bool ChangeLevel(const class FString& LevelName);
	bool ControllerCanRestart(class AController* Controller);
	float GetDamageFactor(class AActor* DamageSource, class AActor* DamageTarget);
	TArray<uint8> GetMapVoteCounts();
	TArray<class FString> GetMapVoteMaps();
	class FString GetNextMap();
	TArray<class FString> GetNextMaps(int32 Count, bool bAllowCurrentMap);
	float GetSpawnpointPreference(class APlayerStart* PlayerStart, class AController* Player);
	bool IsSpawnpointAllowed(class APlayerStart* PlayerStart, class AController* Player);
	bool IsSpawnQueueEmpty();
	void MatchTimeRanOut();
	void OnAssistsChanged(class APlayerState* State, int32 OldValue);
	void OnDeathsChanged(class APlayerState* State, int32 OldValue);
	void OnKilled(class AController* Killer, class AController* KilledPlayer, class APawn* KilledPawn, EMordhauDamageType Type, uint8 SubType, class AActor* DamageSource, class AActor* DamageAgent);
	void OnKillsChanged(class APlayerState* State, int32 OldValue);
	void OnMatchStateChanged(const class FName& OldState, const class FName& NewState);
	void OnScoreChanged(class APlayerState* State, float OldValue);
	void OnTeamScoreChanged(int32 Team, float OldValue);
	void OverrideEquipment(class AMordhauCharacter* Character, TSoftClassPtr<class UClass> EquipmentClass);
	void RemoveBots(int32 Amount, int32 Team);
	void RequestedAssignTeam(class AController* Controller, int32 Team);
	bool SetRconEvent(struct FRconEventStruct* InStruct, const TDelegate<void()>& InEvent, bool bOverrideExisting);
	void SetTeamScore(int32 Team, float Amount);
	bool VoteLevel(class APlayerController* Player, const class FString& LevelName);

	bool GetSuicideAllowed() const;
	bool IsConsoleServer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauGameMode">();
	}
	static class AMordhauGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauGameMode>();
	}
};
static_assert(alignof(AMordhauGameMode) == 0x000008, "Wrong alignment on AMordhauGameMode");
static_assert(sizeof(AMordhauGameMode) == 0x0005B8, "Wrong size on AMordhauGameMode");
static_assert(offsetof(AMordhauGameMode, MapPrefixes) == 0x000308, "Member 'AMordhauGameMode::MapPrefixes' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, MapRotation) == 0x000318, "Member 'AMordhauGameMode::MapRotation' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, MapGameModeOverrides) == 0x000328, "Member 'AMordhauGameMode::MapGameModeOverrides' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, MOTDURL) == 0x000378, "Member 'AMordhauGameMode::MOTDURL' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bIsThirdPersonCameraDisabled) == 0x000388, "Member 'AMordhauGameMode::bIsThirdPersonCameraDisabled' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, ConstrainAspectRatio) == 0x00038C, "Member 'AMordhauGameMode::ConstrainAspectRatio' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bIsHitStopOnTeamHitsDisabled) == 0x000390, "Member 'AMordhauGameMode::bIsHitStopOnTeamHitsDisabled' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bDisableClientMods) == 0x000391, "Member 'AMordhauGameMode::bDisableClientMods' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, SpawnServerActorsOnMapLoad) == 0x000398, "Member 'AMordhauGameMode::SpawnServerActorsOnMapLoad' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bLogKillfeed) == 0x0003A8, "Member 'AMordhauGameMode::bLogKillfeed' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bLogChat) == 0x0003A9, "Member 'AMordhauGameMode::bLogChat' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bLogScore) == 0x0003AA, "Member 'AMordhauGameMode::bLogScore' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bAllowSpawningServerActorsOnMapLoad) == 0x0003AB, "Member 'AMordhauGameMode::bAllowSpawningServerActorsOnMapLoad' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bAllowAdminChat) == 0x0003AC, "Member 'AMordhauGameMode::bAllowAdminChat' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bAllowWhisperChat) == 0x0003AD, "Member 'AMordhauGameMode::bAllowWhisperChat' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, SpawnQueue) == 0x0003B0, "Member 'AMordhauGameMode::SpawnQueue' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, CurrentlySpawningController) == 0x0003C0, "Member 'AMordhauGameMode::CurrentlySpawningController' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, CurrentlySpawningPlayerStart) == 0x0003C8, "Member 'AMordhauGameMode::CurrentlySpawningPlayerStart' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, CurrentlySpawningStage) == 0x0003D0, "Member 'AMordhauGameMode::CurrentlySpawningStage' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bMatchTimeRanOut) == 0x0003D4, "Member 'AMordhauGameMode::bMatchTimeRanOut' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, PlayerRespawnTime) == 0x0003D8, "Member 'AMordhauGameMode::PlayerRespawnTime' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bUsesSlowPlayerSpawning) == 0x0003DC, "Member 'AMordhauGameMode::bUsesSlowPlayerSpawning' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bCasualTracking) == 0x0003DD, "Member 'AMordhauGameMode::bCasualTracking' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, AutoKickOnTeamKillAmount) == 0x0003E0, "Member 'AMordhauGameMode::AutoKickOnTeamKillAmount' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bPlayersSpawnInWaves) == 0x0003E4, "Member 'AMordhauGameMode::bPlayersSpawnInWaves' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bPlayersDropAllGearOnDeath) == 0x0003E5, "Member 'AMordhauGameMode::bPlayersDropAllGearOnDeath' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bEquipmentDoesNotDespawn) == 0x0003E6, "Member 'AMordhauGameMode::bEquipmentDoesNotDespawn' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, OverrideEquipmentDespawnTime) == 0x0003E8, "Member 'AMordhauGameMode::OverrideEquipmentDespawnTime' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, BallistaRespawnTime) == 0x0003EC, "Member 'AMordhauGameMode::BallistaRespawnTime' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, CatapultRespawnTime) == 0x0003F0, "Member 'AMordhauGameMode::CatapultRespawnTime' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, HorseRespawnTime) == 0x0003F4, "Member 'AMordhauGameMode::HorseRespawnTime' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, MapVoteMaps) == 0x0003F8, "Member 'AMordhauGameMode::MapVoteMaps' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, OfficialServerVisibility) == 0x000408, "Member 'AMordhauGameMode::OfficialServerVisibility' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, DamageFactor) == 0x00040C, "Member 'AMordhauGameMode::DamageFactor' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, TeamDamageFactor) == 0x000410, "Member 'AMordhauGameMode::TeamDamageFactor' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, TeamDamageFlinch) == 0x000414, "Member 'AMordhauGameMode::TeamDamageFlinch' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, SpawnProtectionDuration) == 0x000418, "Member 'AMordhauGameMode::SpawnProtectionDuration' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bDisableDamage) == 0x00041C, "Member 'AMordhauGameMode::bDisableDamage' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bDisableStamina) == 0x00041D, "Member 'AMordhauGameMode::bDisableStamina' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bIsScoringDisabled) == 0x00041E, "Member 'AMordhauGameMode::bIsScoringDisabled' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, AssistScoreFactor) == 0x000420, "Member 'AMordhauGameMode::AssistScoreFactor' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, AssistDamageToCountAsKill) == 0x000424, "Member 'AMordhauGameMode::AssistDamageToCountAsKill' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, KillScoreChange) == 0x000428, "Member 'AMordhauGameMode::KillScoreChange' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, KillTeamScoreChange) == 0x00042C, "Member 'AMordhauGameMode::KillTeamScoreChange' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, TeamKillScoreChange) == 0x000430, "Member 'AMordhauGameMode::TeamKillScoreChange' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, TeamKillTeamScoreChange) == 0x000434, "Member 'AMordhauGameMode::TeamKillTeamScoreChange' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bTeamKillsDecrementKillerKills) == 0x000438, "Member 'AMordhauGameMode::bTeamKillsDecrementKillerKills' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bTeamKillsIncrementKilledDeaths) == 0x000439, "Member 'AMordhauGameMode::bTeamKillsIncrementKilledDeaths' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bSuicideDecrementsKills) == 0x00043A, "Member 'AMordhauGameMode::bSuicideDecrementsKills' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, ChatMessages) == 0x000440, "Member 'AMordhauGameMode::ChatMessages' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, MessageTypeMap) == 0x000450, "Member 'AMordhauGameMode::MessageTypeMap' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, PlayerMessagesMap) == 0x0004A0, "Member 'AMordhauGameMode::PlayerMessagesMap' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, OnRconStringCommand) == 0x0004F0, "Member 'AMordhauGameMode::OnRconStringCommand' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, RconEvents) == 0x000500, "Member 'AMordhauGameMode::RconEvents' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, OnMessageBroadcasted) == 0x000510, "Member 'AMordhauGameMode::OnMessageBroadcasted' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, OnAfterLogin) == 0x000520, "Member 'AMordhauGameMode::OnAfterLogin' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, OnBeforeLogout) == 0x000530, "Member 'AMordhauGameMode::OnBeforeLogout' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, OnLevelChange) == 0x000540, "Member 'AMordhauGameMode::OnLevelChange' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, ChatCommands) == 0x000550, "Member 'AMordhauGameMode::ChatCommands' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bCanEquipmentDrop) == 0x0005B0, "Member 'AMordhauGameMode::bCanEquipmentDrop' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bSpawnDefaultEquipment) == 0x0005B1, "Member 'AMordhauGameMode::bSpawnDefaultEquipment' has a wrong offset!");
static_assert(offsetof(AMordhauGameMode, bSuicideAllowed) == 0x0005B2, "Member 'AMordhauGameMode::bSuicideAllowed' has a wrong offset!");

// Class Mordhau.MordhauGameSession
// 0x0940 (0x0B78 - 0x0238)
class AMordhauGameSession final : public AGameSession
{
public:
	uint8                                         Pad_238[0x340];                                    // 0x0238(0x0340)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxSlots;                                          // 0x0578(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerName;                                        // 0x0580(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_590[0x8];                                      // 0x0590(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerPassword;                                    // 0x0598(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Mods;                                              // 0x05A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	class FString                                 AdminPassword;                                     // 0x05B8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RconPassword;                                      // 0x05C8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerKey;                                         // 0x05D8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RconTimeout;                                       // 0x05E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RconPort;                                          // 0x05EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRconTieredAdmins;                                 // 0x05F0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowHttpRequests;                                // 0x05F1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F2[0x2];                                      // 0x05F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNetSkip;                                        // 0x05F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FriendlyNetSkipOffset;                             // 0x05F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Admins;                                            // 0x0600(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<class FString, int64>                    BannedPlayers;                                     // 0x0610(0x0050)(Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_660[0xA0];                                     // 0x0660(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, int64>                    MutedPlayers;                                      // 0x0700(0x0050)(Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_750[0xA0];                                     // 0x0750(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint64>                                LegacyAdmins;                                      // 0x07F0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMap<uint64, int64>                           LegacyBannedPlayers;                               // 0x0800(0x0050)(Config, NativeAccessSpecifierPublic)
	TMap<uint64, int64>                           LegacyMutedPlayers;                                // 0x0850(0x0050)(Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A0[0x50];                                     // 0x08A0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAdvertiseServerViaSteam;                          // 0x08F0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLegacyPakMounting;                             // 0x08F1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOfficialBanList;                               // 0x08F2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOfficialMuteList;                              // 0x08F3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F4[0x4];                                      // 0x08F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bBanResult, const class FString& CallerPlayfabID, const class FString& TargetPlayfabID, int32 BanDuration, class FText& BanReason)> OnRequestBan;                                      // 0x08F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bUnbanResult, const class FString& PlayFabId)> OnRequestUnban;                                    // 0x0908(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bMuteResult, const class FString& CallerPlayfabID, const class FString& TargetPlayfabID, int32 MuteDuration)> OnRequestMute;                                     // 0x0918(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bUnmuteResult, const class FString& PlayFabId)> OnRequestUnmute;                                   // 0x0928(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bKickResult, const class FString& CallerPlayfabID, const class FString& TargetPlayfabID, class FText& KickReason)> OnRequestKick;                                     // 0x0938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& NewMatchState)> OnMatchStateChanged;                               // 0x0948(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAllowJsonForRconClients;                          // 0x0958(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_959[0x3];                                      // 0x0959(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxRconPacketSize;                                 // 0x095C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAdminTierSystem;                               // 0x0960(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_961[0x7];                                      // 0x0961(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AdminActionWebhookURL;                             // 0x0968(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AdminActionChatColor;                              // 0x0978(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AdminPunishmentWebhookURL;                         // 0x0988(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AdminPunishmentColor;                              // 0x0998(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AdminChatCommandWebhookURL;                        // 0x09A8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AdminChatCommandColor;                             // 0x09B8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerLagReportsWebhookURL;                        // 0x09C8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerLagReportColor;                              // 0x09D8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerLagReportColor2;                             // 0x09E8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChatFeedWebhookURL;                                // 0x09F8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChatFeedColor;                                     // 0x0A08(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URconCommand*>                   RconCommands;                                      // 0x0A18(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, struct FRconFlag>         RconFlags;                                         // 0x0A28(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_A78[0x100];                                    // 0x0A78(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAdmin(class APlayerController* AdminPlayer);
	void AddTieredAdmin(class APlayerController* AdminPlayer, const class FString& Tier);
	void AllowJoin(bool bInAllowJoin);
	bool AllowsJoin();
	bool BanPlayer(class APlayerController* BannedPlayer, const class FText& BanReason);
	bool BanPlayerWithDuration(class APlayerController* BannedPlayer, const int32 BanDuration, const class FText& BanReason);
	int32 GetPlayerBanDuration(const class FString& PlayFabId);
	int32 GetPlayerMuteDuration(const class FString& PlayFabId);
	bool IsPlayerBanned(const class FString& PlayFabId);
	bool IsPlayerMuted(const class FString& PlayFabId);
	bool KickPlayer(class APlayerController* KickedPlayer, const class FText& KickReason);
	bool MutePlayer(class APlayerController* MutedPlayer);
	bool MutePlayerWithDuration(class APlayerController* MutedPlayer, const int32 MuteDuration);
	void RemoveAdmin(class APlayerController* AdminPlayer);
	bool ReportPlayer(const class FString& ReporteePlayFabID, const class FString& ReporterPlayFabID, const class FString& ReportType, const class FString& ScreenshotFilename);
	void ReportTimeLeft(const TArray<float>& TimeLeft);
	void TriggerRewardDrop();
	void TriggerRewardDropForPlayer(class APlayerController* Player);
	bool UnbanPlayer(const class FString& PlayFabId, const bool bExpired);
	bool UnmutePlayer(const class FString& PlayFabId, const bool bExpired);
	void UploadAdminActionDataToWebhook(const class FString& Command, const struct FPlayFabPlayer& Sender, const class FString& Details);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauGameSession">();
	}
	static class AMordhauGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauGameSession>();
	}
};
static_assert(alignof(AMordhauGameSession) == 0x000008, "Wrong alignment on AMordhauGameSession");
static_assert(sizeof(AMordhauGameSession) == 0x000B78, "Wrong size on AMordhauGameSession");
static_assert(offsetof(AMordhauGameSession, MaxSlots) == 0x000578, "Member 'AMordhauGameSession::MaxSlots' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, ServerName) == 0x000580, "Member 'AMordhauGameSession::ServerName' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, ServerPassword) == 0x000598, "Member 'AMordhauGameSession::ServerPassword' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, Mods) == 0x0005A8, "Member 'AMordhauGameSession::Mods' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, AdminPassword) == 0x0005B8, "Member 'AMordhauGameSession::AdminPassword' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, RconPassword) == 0x0005C8, "Member 'AMordhauGameSession::RconPassword' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, ServerKey) == 0x0005D8, "Member 'AMordhauGameSession::ServerKey' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, RconTimeout) == 0x0005E8, "Member 'AMordhauGameSession::RconTimeout' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, RconPort) == 0x0005EC, "Member 'AMordhauGameSession::RconPort' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, bRconTieredAdmins) == 0x0005F0, "Member 'AMordhauGameSession::bRconTieredAdmins' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, bAllowHttpRequests) == 0x0005F1, "Member 'AMordhauGameSession::bAllowHttpRequests' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, MaxNetSkip) == 0x0005F4, "Member 'AMordhauGameSession::MaxNetSkip' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, FriendlyNetSkipOffset) == 0x0005F8, "Member 'AMordhauGameSession::FriendlyNetSkipOffset' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, Admins) == 0x000600, "Member 'AMordhauGameSession::Admins' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, BannedPlayers) == 0x000610, "Member 'AMordhauGameSession::BannedPlayers' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, MutedPlayers) == 0x000700, "Member 'AMordhauGameSession::MutedPlayers' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, LegacyAdmins) == 0x0007F0, "Member 'AMordhauGameSession::LegacyAdmins' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, LegacyBannedPlayers) == 0x000800, "Member 'AMordhauGameSession::LegacyBannedPlayers' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, LegacyMutedPlayers) == 0x000850, "Member 'AMordhauGameSession::LegacyMutedPlayers' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, bAdvertiseServerViaSteam) == 0x0008F0, "Member 'AMordhauGameSession::bAdvertiseServerViaSteam' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, bUseLegacyPakMounting) == 0x0008F1, "Member 'AMordhauGameSession::bUseLegacyPakMounting' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, bUseOfficialBanList) == 0x0008F2, "Member 'AMordhauGameSession::bUseOfficialBanList' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, bUseOfficialMuteList) == 0x0008F3, "Member 'AMordhauGameSession::bUseOfficialMuteList' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, OnRequestBan) == 0x0008F8, "Member 'AMordhauGameSession::OnRequestBan' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, OnRequestUnban) == 0x000908, "Member 'AMordhauGameSession::OnRequestUnban' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, OnRequestMute) == 0x000918, "Member 'AMordhauGameSession::OnRequestMute' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, OnRequestUnmute) == 0x000928, "Member 'AMordhauGameSession::OnRequestUnmute' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, OnRequestKick) == 0x000938, "Member 'AMordhauGameSession::OnRequestKick' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, OnMatchStateChanged) == 0x000948, "Member 'AMordhauGameSession::OnMatchStateChanged' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, bAllowJsonForRconClients) == 0x000958, "Member 'AMordhauGameSession::bAllowJsonForRconClients' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, MaxRconPacketSize) == 0x00095C, "Member 'AMordhauGameSession::MaxRconPacketSize' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, bUseAdminTierSystem) == 0x000960, "Member 'AMordhauGameSession::bUseAdminTierSystem' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, AdminActionWebhookURL) == 0x000968, "Member 'AMordhauGameSession::AdminActionWebhookURL' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, AdminActionChatColor) == 0x000978, "Member 'AMordhauGameSession::AdminActionChatColor' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, AdminPunishmentWebhookURL) == 0x000988, "Member 'AMordhauGameSession::AdminPunishmentWebhookURL' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, AdminPunishmentColor) == 0x000998, "Member 'AMordhauGameSession::AdminPunishmentColor' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, AdminChatCommandWebhookURL) == 0x0009A8, "Member 'AMordhauGameSession::AdminChatCommandWebhookURL' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, AdminChatCommandColor) == 0x0009B8, "Member 'AMordhauGameSession::AdminChatCommandColor' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, ServerLagReportsWebhookURL) == 0x0009C8, "Member 'AMordhauGameSession::ServerLagReportsWebhookURL' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, ServerLagReportColor) == 0x0009D8, "Member 'AMordhauGameSession::ServerLagReportColor' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, ServerLagReportColor2) == 0x0009E8, "Member 'AMordhauGameSession::ServerLagReportColor2' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, ChatFeedWebhookURL) == 0x0009F8, "Member 'AMordhauGameSession::ChatFeedWebhookURL' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, ChatFeedColor) == 0x000A08, "Member 'AMordhauGameSession::ChatFeedColor' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, RconCommands) == 0x000A18, "Member 'AMordhauGameSession::RconCommands' has a wrong offset!");
static_assert(offsetof(AMordhauGameSession, RconFlags) == 0x000A28, "Member 'AMordhauGameSession::RconFlags' has a wrong offset!");

// Class Mordhau.MordhauGameState
// 0x0520 (0x07B0 - 0x0290)
class AMordhauGameState : public AGameState
{
public:
	struct FGameStateLastDemotableTickFunction    LastDemotableTickFunction;                         // 0x0290(0x0030)(NativeAccessSpecifierPrivate)
	struct FGameStatePostPhysicsTickFunction      PostPhysicsTickFunction;                           // 0x02C0(0x0030)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x80];                                     // 0x02F0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AAdvancedCharacter>> CharacterTemporaryArrayCached;                     // 0x0370(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<float>                                 NextBudgetTime;                                    // 0x0380(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AParticleSystemActor*>           ParticleSystemActors;                              // 0x0398(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AAdvancedCharacter*>             CharacterDistanceArray;                            // 0x03B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class AAdvancedCharacter*, int32>        CharacterToDistanceArray;                          // 0x03C0(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class AAdvancedCharacter*>               CharacterPendingForDistanceArray;                  // 0x0410(0x0050)(NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AAdvancedCharacter>> RagdollDistanceArray;                              // 0x0460(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<int64, class USkeletalMesh*>             EquipmentMeshCacheMap;                             // 0x0470(0x0050)(NativeAccessSpecifierPrivate)
	class APreSkinnedPoseOracle*                  PreSkinnedPoseOracle;                              // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        NextLoginTime;                                     // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        LoginAttemptInterval;                              // 0x04D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LoginAttempts;                                     // 0x04D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxLoginAttempts;                                  // 0x04DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        NextTokenRefreshTime;                              // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        TokenRefreshInterval;                              // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MatchmakingTicketID;                               // 0x04F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 MatchmakingMatchID;                                // 0x0500(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAreStatsAvailable;                                // 0x0510(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInventoryAvailable;                             // 0x0511(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_512[0x6];                                      // 0x0512(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AAdvancedCharacter*>             ImmutableLivingCharacterArray;                     // 0x0518(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_528[0x8];                                      // 0x0528(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLineTraceMemoryEntry>          AttackTracesMemory;                                // 0x0530(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameModeMetadata>          MetaData;                                          // 0x0540(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableClientStats;                               // 0x0548(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableChat;                                      // 0x0549(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableScoreboard;                                // 0x054A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowHealthRegen;                                 // 0x054B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotLimitPlaceables;                             // 0x054C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideArmorSpeedAndAccelerationFactor;          // 0x054D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54E[0x2];                                      // 0x054E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideArmorSpeedFactor;                          // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideArmorAccelerationFactor;                   // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllPlayersHaveMarkers;                            // 0x0558(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_559[0x7];                                      // 0x0559(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class AMordhauEquipment>>    BannedEquipment;                                   // 0x0560(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<EPerk>                                   BannedPerks;                                       // 0x05B0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 MOTDURL;                                           // 0x0600(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsThirdPersonCameraDisabled;                      // 0x0610(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_611[0x3];                                      // 0x0611(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConstrainAspectRatio;                              // 0x0614(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableClientMods;                                // 0x0618(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_619[0x3];                                      // 0x0619(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MatchDurationMax;                                  // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReplicatedMatchDurationMax;                        // 0x0620(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_624[0x4];                                      // 0x0624(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class AMapCameraActor*>           MapCameraActors;                                   // 0x0628(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         DefaultEndMatchMapChangeTime;                      // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndMatchMapChangeEnd;                              // 0x067C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostMatchScreenDelay;                              // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultWarmupTime;                                 // 0x0684(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipWarmupInDevBuild;                             // 0x0688(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockInputInWarmup;                               // 0x0689(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68A[0x2];                                      // 0x068A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinPlayersToStart;                                 // 0x068C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarmupEnd;                                         // 0x0690(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotGoToNextMapOnMatchEnd;                       // 0x0694(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotShowPostMatchScreen;                         // 0x0695(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSpawning;                                    // 0x0696(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowVoteKick;                                    // 0x0697(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicatedAllowVoteKick;                          // 0x0698(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesAutoAssign;                                   // 0x0699(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamCount;                                         // 0x069A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69B[0x5];                                      // 0x069B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 TeamScores;                                        // 0x06A0(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsTeamMode;                                       // 0x06B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnforceTeamColors;                                // 0x06B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B2[0x6];                                      // 0x06B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   TeamColors;                                        // 0x06B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         TeamNames;                                         // 0x06C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   SecondaryTeamColors;                               // 0x06D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AControlPoint*>                  AllCapturePoints;                                  // 0x06E8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Team1CapturePoints;                                // 0x06F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Team2CapturePoints;                                // 0x06FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePushTopologicalProgress;                       // 0x0700(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PushTopologicalProgressAttackingTeam;              // 0x0701(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_702[0x2];                                      // 0x0702(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Team1TopologicalProgress;                          // 0x0704(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Team2TopologicalProgress;                          // 0x0708(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70C[0x4];                                      // 0x070C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCapturePointGroup>             CapturePointTopologicalOrdering;                   // 0x0710(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGroupSoundGroup>    SoundGroups;                                       // 0x0720(0x0050)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         LastBotVoiceCommandTime;                           // 0x0770(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastBotEmoteTime;                                  // 0x0774(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastBotClimbTime;                                  // 0x0778(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77C[0x4];                                      // 0x077C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UDecalComponent>> BloodDecalsArray;                                  // 0x0780(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_790[0x8];                                      // 0x0790(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnSingletonReset;                                  // 0x0798(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AMordhauEquipmentRemapper*              EquipmentRemapper;                                 // 0x07A8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CanImmediatelyChangeProfile(class AController* Controller);
	bool CanPlayerJoinTeam(class AMordhauPlayerState* Player, int32 Team);
	class AMapCameraActor* GetAppropriateMapCameraActor(class APlayerController* Controller);
	struct FTransform GetBindPoseTransform(class USkeletalMesh* Mesh, class FName SocketName);
	class AAdvancedCharacter* GetCharacterByDistanceRank(int32 DistanceRank);
	int32 GetCurrentFrame();
	int64 GetEquipmentCacheHash(int32 ID, uint8 Skin, uint8 Part1, uint8 Part2, uint8 Part3, bool bUseAuxiliaryMesh);
	class USkeletalMesh* GetEquipmentMeshFromCache(int32 ID, uint8 Skin, uint8 Part1, uint8 Part2, uint8 Part3, bool bUseAuxiliaryMesh);
	TArray<int32> GetPlayerCountsPerTeam(bool bOnlyLiving, bool bOnlyWithValidProfiles);
	struct FLinearColor GetSecondaryTeamColor(int32 Team);
	struct FLinearColor GetTeamColor(int32 Team);
	class FString GetTeamName(int32 Team);
	bool IsFriendly(class AActor* ActorA, class AActor* ActorB, bool bIsFriendlyIfSelf);
	void LastDemotableTick(float DeltaTime);
	bool LineTraceCharacters(const struct FVector& LineStart, const struct FVector& LineEnd, const TSet<class AAdvancedCharacter*>& IgnoreCharacters, TArray<struct FHitResult>* Results);
	void LocalPlayerChangedTeam();
	void OnRep_AllowVoteKick();
	void OnRep_EquipmentRemapper();
	void OnRep_MOTDURL();
	void OnRep_ReplicatedMatchDurationMax();
	void OnReplicatedMOTD();
	void PostPhysicsTick(float DeltaTime);
	void RegisterParticleSystemActor(class AParticleSystemActor* ParticleActor);
	void RemoveCharacterFromDistanceArray(class AAdvancedCharacter* Character);
	void ReserveCharacterRagdoll(class AAdvancedCharacter* Character);
	void ResetLoginProcessVars();
	void ResetOnNetworkRecovery();
	bool ShouldBlockPawnInput();
	bool ShouldTickAnimationThisFrame(class AAdvancedCharacter* Character);
	bool ShouldTickThisFrame(class AAdvancedCharacter* Character);
	void StoreEquipmentMeshInCache(class USkeletalMesh* Mesh, int32 ID, uint8 Skin, uint8 Part1, uint8 Part2, uint8 Part3, bool bUseAuxiliaryMesh);
	void UnregisterParticleSystemActor(class AParticleSystemActor* ParticleActor);
	void UpdateCapturePointData();
	void UpdateSoundGroups();

	bool ShouldPaintGearWithTeamColors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauGameState">();
	}
	static class AMordhauGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauGameState>();
	}
};
static_assert(alignof(AMordhauGameState) == 0x000008, "Wrong alignment on AMordhauGameState");
static_assert(sizeof(AMordhauGameState) == 0x0007B0, "Wrong size on AMordhauGameState");
static_assert(offsetof(AMordhauGameState, LastDemotableTickFunction) == 0x000290, "Member 'AMordhauGameState::LastDemotableTickFunction' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, PostPhysicsTickFunction) == 0x0002C0, "Member 'AMordhauGameState::PostPhysicsTickFunction' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, CharacterTemporaryArrayCached) == 0x000370, "Member 'AMordhauGameState::CharacterTemporaryArrayCached' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, NextBudgetTime) == 0x000380, "Member 'AMordhauGameState::NextBudgetTime' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, ParticleSystemActors) == 0x000398, "Member 'AMordhauGameState::ParticleSystemActors' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, CharacterDistanceArray) == 0x0003B0, "Member 'AMordhauGameState::CharacterDistanceArray' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, CharacterToDistanceArray) == 0x0003C0, "Member 'AMordhauGameState::CharacterToDistanceArray' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, CharacterPendingForDistanceArray) == 0x000410, "Member 'AMordhauGameState::CharacterPendingForDistanceArray' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, RagdollDistanceArray) == 0x000460, "Member 'AMordhauGameState::RagdollDistanceArray' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, EquipmentMeshCacheMap) == 0x000470, "Member 'AMordhauGameState::EquipmentMeshCacheMap' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, PreSkinnedPoseOracle) == 0x0004C0, "Member 'AMordhauGameState::PreSkinnedPoseOracle' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, NextLoginTime) == 0x0004C8, "Member 'AMordhauGameState::NextLoginTime' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, LoginAttemptInterval) == 0x0004D0, "Member 'AMordhauGameState::LoginAttemptInterval' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, LoginAttempts) == 0x0004D8, "Member 'AMordhauGameState::LoginAttempts' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, MaxLoginAttempts) == 0x0004DC, "Member 'AMordhauGameState::MaxLoginAttempts' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, NextTokenRefreshTime) == 0x0004E0, "Member 'AMordhauGameState::NextTokenRefreshTime' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, TokenRefreshInterval) == 0x0004E8, "Member 'AMordhauGameState::TokenRefreshInterval' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, MatchmakingTicketID) == 0x0004F0, "Member 'AMordhauGameState::MatchmakingTicketID' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, MatchmakingMatchID) == 0x000500, "Member 'AMordhauGameState::MatchmakingMatchID' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bAreStatsAvailable) == 0x000510, "Member 'AMordhauGameState::bAreStatsAvailable' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bIsInventoryAvailable) == 0x000511, "Member 'AMordhauGameState::bIsInventoryAvailable' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, ImmutableLivingCharacterArray) == 0x000518, "Member 'AMordhauGameState::ImmutableLivingCharacterArray' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, AttackTracesMemory) == 0x000530, "Member 'AMordhauGameState::AttackTracesMemory' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, MetaData) == 0x000540, "Member 'AMordhauGameState::MetaData' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bDisableClientStats) == 0x000548, "Member 'AMordhauGameState::bDisableClientStats' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bDisableChat) == 0x000549, "Member 'AMordhauGameState::bDisableChat' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bDisableScoreboard) == 0x00054A, "Member 'AMordhauGameState::bDisableScoreboard' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bAllowHealthRegen) == 0x00054B, "Member 'AMordhauGameState::bAllowHealthRegen' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bDoNotLimitPlaceables) == 0x00054C, "Member 'AMordhauGameState::bDoNotLimitPlaceables' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bOverrideArmorSpeedAndAccelerationFactor) == 0x00054D, "Member 'AMordhauGameState::bOverrideArmorSpeedAndAccelerationFactor' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, OverrideArmorSpeedFactor) == 0x000550, "Member 'AMordhauGameState::OverrideArmorSpeedFactor' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, OverrideArmorAccelerationFactor) == 0x000554, "Member 'AMordhauGameState::OverrideArmorAccelerationFactor' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bAllPlayersHaveMarkers) == 0x000558, "Member 'AMordhauGameState::bAllPlayersHaveMarkers' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, BannedEquipment) == 0x000560, "Member 'AMordhauGameState::BannedEquipment' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, BannedPerks) == 0x0005B0, "Member 'AMordhauGameState::BannedPerks' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, MOTDURL) == 0x000600, "Member 'AMordhauGameState::MOTDURL' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bIsThirdPersonCameraDisabled) == 0x000610, "Member 'AMordhauGameState::bIsThirdPersonCameraDisabled' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, ConstrainAspectRatio) == 0x000614, "Member 'AMordhauGameState::ConstrainAspectRatio' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bDisableClientMods) == 0x000618, "Member 'AMordhauGameState::bDisableClientMods' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, MatchDurationMax) == 0x00061C, "Member 'AMordhauGameState::MatchDurationMax' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, ReplicatedMatchDurationMax) == 0x000620, "Member 'AMordhauGameState::ReplicatedMatchDurationMax' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, MapCameraActors) == 0x000628, "Member 'AMordhauGameState::MapCameraActors' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, DefaultEndMatchMapChangeTime) == 0x000678, "Member 'AMordhauGameState::DefaultEndMatchMapChangeTime' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, EndMatchMapChangeEnd) == 0x00067C, "Member 'AMordhauGameState::EndMatchMapChangeEnd' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, PostMatchScreenDelay) == 0x000680, "Member 'AMordhauGameState::PostMatchScreenDelay' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, DefaultWarmupTime) == 0x000684, "Member 'AMordhauGameState::DefaultWarmupTime' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bSkipWarmupInDevBuild) == 0x000688, "Member 'AMordhauGameState::bSkipWarmupInDevBuild' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bBlockInputInWarmup) == 0x000689, "Member 'AMordhauGameState::bBlockInputInWarmup' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, MinPlayersToStart) == 0x00068C, "Member 'AMordhauGameState::MinPlayersToStart' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, WarmupEnd) == 0x000690, "Member 'AMordhauGameState::WarmupEnd' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bDoNotGoToNextMapOnMatchEnd) == 0x000694, "Member 'AMordhauGameState::bDoNotGoToNextMapOnMatchEnd' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bDoNotShowPostMatchScreen) == 0x000695, "Member 'AMordhauGameState::bDoNotShowPostMatchScreen' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bAllowSpawning) == 0x000696, "Member 'AMordhauGameState::bAllowSpawning' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bAllowVoteKick) == 0x000697, "Member 'AMordhauGameState::bAllowVoteKick' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bReplicatedAllowVoteKick) == 0x000698, "Member 'AMordhauGameState::bReplicatedAllowVoteKick' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bUsesAutoAssign) == 0x000699, "Member 'AMordhauGameState::bUsesAutoAssign' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, TeamCount) == 0x00069A, "Member 'AMordhauGameState::TeamCount' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, TeamScores) == 0x0006A0, "Member 'AMordhauGameState::TeamScores' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bIsTeamMode) == 0x0006B0, "Member 'AMordhauGameState::bIsTeamMode' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bEnforceTeamColors) == 0x0006B1, "Member 'AMordhauGameState::bEnforceTeamColors' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, TeamColors) == 0x0006B8, "Member 'AMordhauGameState::TeamColors' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, TeamNames) == 0x0006C8, "Member 'AMordhauGameState::TeamNames' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, SecondaryTeamColors) == 0x0006D8, "Member 'AMordhauGameState::SecondaryTeamColors' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, AllCapturePoints) == 0x0006E8, "Member 'AMordhauGameState::AllCapturePoints' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, Team1CapturePoints) == 0x0006F8, "Member 'AMordhauGameState::Team1CapturePoints' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, Team2CapturePoints) == 0x0006FC, "Member 'AMordhauGameState::Team2CapturePoints' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, bUsePushTopologicalProgress) == 0x000700, "Member 'AMordhauGameState::bUsePushTopologicalProgress' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, PushTopologicalProgressAttackingTeam) == 0x000701, "Member 'AMordhauGameState::PushTopologicalProgressAttackingTeam' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, Team1TopologicalProgress) == 0x000704, "Member 'AMordhauGameState::Team1TopologicalProgress' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, Team2TopologicalProgress) == 0x000708, "Member 'AMordhauGameState::Team2TopologicalProgress' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, CapturePointTopologicalOrdering) == 0x000710, "Member 'AMordhauGameState::CapturePointTopologicalOrdering' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, SoundGroups) == 0x000720, "Member 'AMordhauGameState::SoundGroups' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, LastBotVoiceCommandTime) == 0x000770, "Member 'AMordhauGameState::LastBotVoiceCommandTime' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, LastBotEmoteTime) == 0x000774, "Member 'AMordhauGameState::LastBotEmoteTime' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, LastBotClimbTime) == 0x000778, "Member 'AMordhauGameState::LastBotClimbTime' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, BloodDecalsArray) == 0x000780, "Member 'AMordhauGameState::BloodDecalsArray' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, OnSingletonReset) == 0x000798, "Member 'AMordhauGameState::OnSingletonReset' has a wrong offset!");
static_assert(offsetof(AMordhauGameState, EquipmentRemapper) == 0x0007A8, "Member 'AMordhauGameState::EquipmentRemapper' has a wrong offset!");

// Class Mordhau.MordhauHttpRequest
// 0x00A0 (0x00D0 - 0x0030)
class UMordhauHttpRequest final : public UOnlineBlueprintCallProxyBase
{
public:
	TMulticastInlineDelegate<void(class UPlayFabJsonObject* ResponseObject, int32 ResponseCode, float ElapsedTime)> OnRequestComplete;                                 // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 ResponseCode, float ElapsedTime)> OnRequestFailed;                                   // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x80];                                      // 0x0050(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMordhauHttpRequest* MordhauHttpRequest(class UObject* WorldContext, const class FString& InUrl, const class FString& InVerb, const TMap<class FString, class FString>& InHeaderMap, class UPlayFabJsonObject* InPlayFabJsonObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauHttpRequest">();
	}
	static class UMordhauHttpRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauHttpRequest>();
	}
};
static_assert(alignof(UMordhauHttpRequest) == 0x000008, "Wrong alignment on UMordhauHttpRequest");
static_assert(sizeof(UMordhauHttpRequest) == 0x0000D0, "Wrong size on UMordhauHttpRequest");
static_assert(offsetof(UMordhauHttpRequest, OnRequestComplete) == 0x000030, "Member 'UMordhauHttpRequest::OnRequestComplete' has a wrong offset!");
static_assert(offsetof(UMordhauHttpRequest, OnRequestFailed) == 0x000040, "Member 'UMordhauHttpRequest::OnRequestFailed' has a wrong offset!");

// Class Mordhau.MordhauHUD
// 0x0020 (0x0330 - 0x0310)
class AMordhauHUD : public AHUD
{
public:
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AControlPoint*>                  CapturePointsOfInterest;                           // 0x0318(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class AMordhauObjectiveTracker*               ObjectiveTracker;                                  // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EnqueueMordhauDialog(class UMordhauDialog* Dialog);
	void OnGameStateReplicated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauHUD">();
	}
	static class AMordhauHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauHUD>();
	}
};
static_assert(alignof(AMordhauHUD) == 0x000008, "Wrong alignment on AMordhauHUD");
static_assert(sizeof(AMordhauHUD) == 0x000330, "Wrong size on AMordhauHUD");
static_assert(offsetof(AMordhauHUD, CapturePointsOfInterest) == 0x000318, "Member 'AMordhauHUD::CapturePointsOfInterest' has a wrong offset!");
static_assert(offsetof(AMordhauHUD, ObjectiveTracker) == 0x000328, "Member 'AMordhauHUD::ObjectiveTracker' has a wrong offset!");

// Class Mordhau.MordhauHyperlinkTextDecorator
// 0x0510 (0x0538 - 0x0028)
class UMordhauHyperlinkTextDecorator : public URichTextBlockDecorator
{
public:
	struct FHyperlinkStyle                        Style;                                             // 0x0028(0x0500)(Edit, NativeAccessSpecifierPublic)
	class FString                                 URL;                                               // 0x0528(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnHyperTextClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauHyperlinkTextDecorator">();
	}
	static class UMordhauHyperlinkTextDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauHyperlinkTextDecorator>();
	}
};
static_assert(alignof(UMordhauHyperlinkTextDecorator) == 0x000008, "Wrong alignment on UMordhauHyperlinkTextDecorator");
static_assert(sizeof(UMordhauHyperlinkTextDecorator) == 0x000538, "Wrong size on UMordhauHyperlinkTextDecorator");
static_assert(offsetof(UMordhauHyperlinkTextDecorator, Style) == 0x000028, "Member 'UMordhauHyperlinkTextDecorator::Style' has a wrong offset!");
static_assert(offsetof(UMordhauHyperlinkTextDecorator, URL) == 0x000528, "Member 'UMordhauHyperlinkTextDecorator::URL' has a wrong offset!");

// Class Mordhau.MordhauInput
// 0x00C0 (0x00E8 - 0x0028)
class UMordhauInput final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDefaultBindingsChecked;                           // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInputAxisConfigEntry>          AxisConfig;                                        // 0x0038(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TArray<struct FInputActionKeyMapping>         ActionMappings;                                    // 0x0048(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TArray<struct FInputAxisKeyMapping>           AxisMappings;                                      // 0x0058(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TArray<struct FKey>                           ConsoleKeys;                                       // 0x0068(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	int32                                         ControlScheme;                                     // 0x0078(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AngleAttacksWithMovement;                          // 0x007C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MouseXIsFlipAttackSide;                            // 0x0080(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InverseAttackDirectionX;                           // 0x0084(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InverseAttackDirectionY;                           // 0x0088(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AngleAttackAfterPress;                             // 0x008C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ToggleSprint;                                      // 0x0090(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ToggleCrouch;                                      // 0x0094(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMouseXInverted;                                   // 0x0098(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseXSensitivity;                                 // 0x009C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMouseYInverted;                                   // 0x00A0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseYSensitivity;                                 // 0x00A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGamepadLeftXInverted;                             // 0x00A8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadLeftXSensitivity;                           // 0x00AC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GamepadLeftXDeadzone;                              // 0x00B0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGamepadLeftYInverted;                             // 0x00B4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadLeftYSensitivity;                           // 0x00B8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GamepadLeftYDeadzone;                              // 0x00BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGamepadRightXInverted;                            // 0x00C0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadRightXSensitivity;                          // 0x00C4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GamepadRightXDeadzone;                             // 0x00C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGamepadRightYInverted;                            // 0x00CC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadRightYSensitivity;                          // 0x00D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GamepadRightYDeadzone;                             // 0x00D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CustomSetInputModeGameAndUI(class APlayerController* PlayerController, class UWidget* InWidgetToFocus, EMouseLockMode InMouseLockMode, bool bHideCursorDuringCapture);
	static void CustomSetInputModeGameOnly(class APlayerController* PlayerController);
	static void CustomSetInputModeUIOnly(class APlayerController* PlayerController, class UWidget* InWidgetToFocus, EMouseLockMode InMouseLockMode);
	static struct FKey GetActionKey(const struct FInputActionKeyMapping& ActionKeyBinding);
	static class FName GetActionName(const struct FInputActionKeyMapping& ActionKeyBinding);
	static struct FKey GetAxisKey(const struct FInputAxisKeyMapping& AxisKeyBinding);
	static class FName GetAxisName(const struct FInputAxisKeyMapping& AxisKeyBinding);
	static class FName GetAxisOppositeDirectionName(const class FName& AxisName);
	static float GetAxisScale(const struct FInputAxisKeyMapping& AxisKeyBinding);

	void AddActionKeyBinding(const class FName& ActionName, const struct FKey& Key);
	void AddAxisKeyBinding(const class FName& AxisName, const struct FKey& Key);
	void AddConsoleKeyBinding(const struct FKey& Key);
	void ApplySettings();
	void ClearKeyBindings();
	void GetActionKeyBindings(TArray<struct FInputActionKeyMapping>* ActionKeyBindings);
	TArray<struct FInputActionKeyMapping> GetAllKeyBindingsForAction(const class FName& ActionName);
	void GetAxisKeyBindings(TArray<struct FInputAxisKeyMapping>* AxisKeyBindings);
	void GetConsoleKeyBindings(TArray<struct FKey>* ConsoleKeyBindings);
	struct FInputActionKeyMapping GetPrimaryActionKeyBinding(const class FName& ActionName);
	struct FInputAxisKeyMapping GetPrimaryAxisKeyBinding(const class FName& AxisName);
	struct FInputActionKeyMapping GetSecondaryActionKeyBinding(const class FName& ActionName);
	struct FInputAxisKeyMapping GetSecondaryAxisKeyBinding(const class FName& AxisName);
	void RestoreDefaultSettings();
	void SaveSettings();
	void SetAngleAttackAfterPress(int32 NewAngleAttackAfterPress);
	void SetAngleAttacksWithMovement(int32 NewAngleAttacksWithMovement);
	void SetControlScheme(int32 NewControlScheme);
	void SetGamepadLeftXDeadzone(float NewDeadzone);
	void SetGamepadLeftXInverted(bool bNewInverted);
	void SetGamepadLeftXSensitivity(float NewSensitivity);
	void SetGamepadLeftYDeadzone(float NewDeadzone);
	void SetGamepadLeftYInverted(bool bNewInverted);
	void SetGamepadLeftYSensitivity(float NewSensitivity);
	void SetGamepadRightXDeadzone(float NewDeadzone);
	void SetGamepadRightXInverted(bool bNewInverted);
	void SetGamepadRightXSensitivity(float NewSensitivity);
	void SetGamepadRightYDeadzone(float NewDeadzone);
	void SetGamepadRightYInverted(bool bNewInverted);
	void SetGamepadRightYSensitivity(float NewSensitivity);
	void SetInverseAttackDirectionX(int32 NewInverseAttackDirectionX);
	void SetInverseAttackDirectionY(int32 NewInverseAttackDirectionX);
	void SetMouseXInverted(bool bNewInverted);
	void SetMouseXIsFlipAttackSide(int32 NewIsFlipAttackSide);
	void SetMouseXSensitivity(float NewSensitivity);
	void SetMouseYInverted(bool bNewInverted);
	void SetMouseYSensitivity(float NewSensitivity);
	void SetToggleCrouch(int32 NewToggleCrouch);
	void SetToggleSprint(int32 NewToggleSprint);

	int32 GetAngleAttackAfterPress() const;
	int32 GetAngleAttacksWithMovement() const;
	int32 GetControlScheme() const;
	struct FVector2D GetGamepadDeadzoneLimits() const;
	float GetGamepadLeftXDeadzone() const;
	bool GetGamepadLeftXInverted() const;
	float GetGamepadLeftXSensitivity() const;
	float GetGamepadLeftYDeadzone() const;
	bool GetGamepadLeftYInverted() const;
	float GetGamepadLeftYSensitivity() const;
	float GetGamepadRightXDeadzone() const;
	bool GetGamepadRightXInverted() const;
	float GetGamepadRightXSensitivity() const;
	float GetGamepadRightYDeadzone() const;
	bool GetGamepadRightYInverted() const;
	float GetGamepadRightYSensitivity() const;
	struct FVector2D GetGamepadSensitivityLimits() const;
	int32 GetInverseAttackDirectionX() const;
	int32 GetInverseAttackDirectionY() const;
	struct FVector2D GetMouseSensitivityLimits() const;
	bool GetMouseXInverted() const;
	int32 GetMouseXIsFlipAttackSide() const;
	float GetMouseXSensitivity() const;
	bool GetMouseYInverted() const;
	float GetMouseYSensitivity() const;
	int32 GetToggleCrouch() const;
	int32 GetToggleSprint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauInput">();
	}
	static class UMordhauInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauInput>();
	}
};
static_assert(alignof(UMordhauInput) == 0x000008, "Wrong alignment on UMordhauInput");
static_assert(sizeof(UMordhauInput) == 0x0000E8, "Wrong size on UMordhauInput");
static_assert(offsetof(UMordhauInput, bDefaultBindingsChecked) == 0x000030, "Member 'UMordhauInput::bDefaultBindingsChecked' has a wrong offset!");
static_assert(offsetof(UMordhauInput, AxisConfig) == 0x000038, "Member 'UMordhauInput::AxisConfig' has a wrong offset!");
static_assert(offsetof(UMordhauInput, ActionMappings) == 0x000048, "Member 'UMordhauInput::ActionMappings' has a wrong offset!");
static_assert(offsetof(UMordhauInput, AxisMappings) == 0x000058, "Member 'UMordhauInput::AxisMappings' has a wrong offset!");
static_assert(offsetof(UMordhauInput, ConsoleKeys) == 0x000068, "Member 'UMordhauInput::ConsoleKeys' has a wrong offset!");
static_assert(offsetof(UMordhauInput, ControlScheme) == 0x000078, "Member 'UMordhauInput::ControlScheme' has a wrong offset!");
static_assert(offsetof(UMordhauInput, AngleAttacksWithMovement) == 0x00007C, "Member 'UMordhauInput::AngleAttacksWithMovement' has a wrong offset!");
static_assert(offsetof(UMordhauInput, MouseXIsFlipAttackSide) == 0x000080, "Member 'UMordhauInput::MouseXIsFlipAttackSide' has a wrong offset!");
static_assert(offsetof(UMordhauInput, InverseAttackDirectionX) == 0x000084, "Member 'UMordhauInput::InverseAttackDirectionX' has a wrong offset!");
static_assert(offsetof(UMordhauInput, InverseAttackDirectionY) == 0x000088, "Member 'UMordhauInput::InverseAttackDirectionY' has a wrong offset!");
static_assert(offsetof(UMordhauInput, AngleAttackAfterPress) == 0x00008C, "Member 'UMordhauInput::AngleAttackAfterPress' has a wrong offset!");
static_assert(offsetof(UMordhauInput, ToggleSprint) == 0x000090, "Member 'UMordhauInput::ToggleSprint' has a wrong offset!");
static_assert(offsetof(UMordhauInput, ToggleCrouch) == 0x000094, "Member 'UMordhauInput::ToggleCrouch' has a wrong offset!");
static_assert(offsetof(UMordhauInput, bMouseXInverted) == 0x000098, "Member 'UMordhauInput::bMouseXInverted' has a wrong offset!");
static_assert(offsetof(UMordhauInput, MouseXSensitivity) == 0x00009C, "Member 'UMordhauInput::MouseXSensitivity' has a wrong offset!");
static_assert(offsetof(UMordhauInput, bMouseYInverted) == 0x0000A0, "Member 'UMordhauInput::bMouseYInverted' has a wrong offset!");
static_assert(offsetof(UMordhauInput, MouseYSensitivity) == 0x0000A4, "Member 'UMordhauInput::MouseYSensitivity' has a wrong offset!");
static_assert(offsetof(UMordhauInput, bGamepadLeftXInverted) == 0x0000A8, "Member 'UMordhauInput::bGamepadLeftXInverted' has a wrong offset!");
static_assert(offsetof(UMordhauInput, GamepadLeftXSensitivity) == 0x0000AC, "Member 'UMordhauInput::GamepadLeftXSensitivity' has a wrong offset!");
static_assert(offsetof(UMordhauInput, GamepadLeftXDeadzone) == 0x0000B0, "Member 'UMordhauInput::GamepadLeftXDeadzone' has a wrong offset!");
static_assert(offsetof(UMordhauInput, bGamepadLeftYInverted) == 0x0000B4, "Member 'UMordhauInput::bGamepadLeftYInverted' has a wrong offset!");
static_assert(offsetof(UMordhauInput, GamepadLeftYSensitivity) == 0x0000B8, "Member 'UMordhauInput::GamepadLeftYSensitivity' has a wrong offset!");
static_assert(offsetof(UMordhauInput, GamepadLeftYDeadzone) == 0x0000BC, "Member 'UMordhauInput::GamepadLeftYDeadzone' has a wrong offset!");
static_assert(offsetof(UMordhauInput, bGamepadRightXInverted) == 0x0000C0, "Member 'UMordhauInput::bGamepadRightXInverted' has a wrong offset!");
static_assert(offsetof(UMordhauInput, GamepadRightXSensitivity) == 0x0000C4, "Member 'UMordhauInput::GamepadRightXSensitivity' has a wrong offset!");
static_assert(offsetof(UMordhauInput, GamepadRightXDeadzone) == 0x0000C8, "Member 'UMordhauInput::GamepadRightXDeadzone' has a wrong offset!");
static_assert(offsetof(UMordhauInput, bGamepadRightYInverted) == 0x0000CC, "Member 'UMordhauInput::bGamepadRightYInverted' has a wrong offset!");
static_assert(offsetof(UMordhauInput, GamepadRightYSensitivity) == 0x0000D0, "Member 'UMordhauInput::GamepadRightYSensitivity' has a wrong offset!");
static_assert(offsetof(UMordhauInput, GamepadRightYDeadzone) == 0x0000D4, "Member 'UMordhauInput::GamepadRightYDeadzone' has a wrong offset!");

// Class Mordhau.MordhauInteractable
// 0x0010 (0x03F0 - 0x03E0)
class AMordhauInteractable : public AMordhauActor
{
public:
	uint8                                         Interactions;                                      // 0x03E0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0xF];                                      // 0x03E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteractionsChanged(uint8 OldValue);
	void OnRep_Interactions(uint8 OldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauInteractable">();
	}
	static class AMordhauInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauInteractable>();
	}
};
static_assert(alignof(AMordhauInteractable) == 0x000010, "Wrong alignment on AMordhauInteractable");
static_assert(sizeof(AMordhauInteractable) == 0x0003F0, "Wrong size on AMordhauInteractable");
static_assert(offsetof(AMordhauInteractable, Interactions) == 0x0003E0, "Member 'AMordhauInteractable::Interactions' has a wrong offset!");

// Class Mordhau.MordhauMovementComponent
// 0x0100 (0x0D50 - 0x0C50)
class UMordhauMovementComponent final : public UAdvancedCharacterMovement
{
public:
	bool                                          bIsChasing;                                        // 0x0C48(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingChased;                                    // 0x0C49(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4A[0x2];                                      // 0x0C4A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnMaxSprintDuration;                            // 0x0C4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C50[0x10];                                     // 0x0C50(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TurnSprintPreventionDecayCurve;                    // 0x0C60(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TurnSprintPreventionSlowdownCurve;                 // 0x0C68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnSprintPreventionMaxAccumulatedAngle;           // 0x0C70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushSprintTimeStart;                               // 0x0C74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChasingSprintTimeStart;                            // 0x0C78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeingChasedSlowdownTimeFactor;                     // 0x0C7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleToChase;                                   // 0x0C80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleToStopChasing;                             // 0x0C84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ChasingMaxDistance;                                // 0x0C88(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StopChasingMaxDistance;                            // 0x0C94(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ChasedMaxDistance;                                 // 0x0CA0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToBreakUsChasing;                              // 0x0CAC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToBreakUsBeingChased;                          // 0x0CB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeToStartChasing;                             // 0x0CB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeToStartBeingChased;                         // 0x0CB8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWalkSpeedCrouchedWithRatPerk;                   // 0x0CBC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintModifier;                                    // 0x0CC0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChasingModifier;                                   // 0x0CC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PartialSprintModifier;                             // 0x0CC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SupersprintModifier;                               // 0x0CCC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackpedalModifier;                                 // 0x0CD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeModifier;                                    // 0x0CD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkAcceleration;                                  // 0x0CD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PartialSprintAcceleration;                         // 0x0CDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintAcceleration;                                // 0x0CE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintTimeToReachMaxSprint;                        // 0x0CE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintTime;                                        // 0x0CE8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CEC[0x4];                                      // 0x0CEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SupersprintAcceleration;                           // 0x0CF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionSpeedFactor;                                 // 0x0CF4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionBackpedalSpeedFactor;                        // 0x0CF8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EquipmentBackpedalSpeedFactor;                     // 0x0CFC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EquipmentSpeedFactorOverride;                      // 0x0D00(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorSpeedFactor;                                  // 0x0D04(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmorAccelerationFactor;                           // 0x0D08(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EquipmentSpeedBonusPercentage;                     // 0x0D0C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EquipmentSubSprintSpeedBonus;                      // 0x0D10(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EquipmentAccelerationBonusPercentage;              // 0x0D14(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementModifier                             MovementModifier;                                  // 0x0D18(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsSprint;                                      // 0x0D19(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSprintIsAllowed;                                  // 0x0D1A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyPartialSprint;                                // 0x0D1B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsSupersprint;                                 // 0x0D1C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1D[0x3];                                      // 0x0D1D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KnockbackGroundFriction;                           // 0x0D20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackFallingLateralFriction;                   // 0x0D24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackUpImpulse;                                // 0x0D28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedFalling;                                   // 0x0D2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseGroundFriction;                                // 0x0D30(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseFallingLateralFriction;                        // 0x0D34(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackDuration;                                 // 0x0D38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakingDecelerationFallingTooFast;                 // 0x0D3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D40[0x10];                                     // 0x0D40(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Knockback(const struct FVector& Amount);
	void OnCharacterLODTick(float DeltaTime);
	void OnInputTypeChange(bool bIsUsingGamepad);

	float GetAccelerationFactor() const;
	float GetSpeedFactor(float PartialSprintToSprintWeight) const;
	bool IsInKnockback() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauMovementComponent">();
	}
	static class UMordhauMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauMovementComponent>();
	}
};
static_assert(alignof(UMordhauMovementComponent) == 0x000010, "Wrong alignment on UMordhauMovementComponent");
static_assert(sizeof(UMordhauMovementComponent) == 0x000D50, "Wrong size on UMordhauMovementComponent");
static_assert(offsetof(UMordhauMovementComponent, bIsChasing) == 0x000C48, "Member 'UMordhauMovementComponent::bIsChasing' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, bIsBeingChased) == 0x000C49, "Member 'UMordhauMovementComponent::bIsBeingChased' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, SpawnMaxSprintDuration) == 0x000C4C, "Member 'UMordhauMovementComponent::SpawnMaxSprintDuration' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, TurnSprintPreventionDecayCurve) == 0x000C60, "Member 'UMordhauMovementComponent::TurnSprintPreventionDecayCurve' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, TurnSprintPreventionSlowdownCurve) == 0x000C68, "Member 'UMordhauMovementComponent::TurnSprintPreventionSlowdownCurve' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, TurnSprintPreventionMaxAccumulatedAngle) == 0x000C70, "Member 'UMordhauMovementComponent::TurnSprintPreventionMaxAccumulatedAngle' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, RushSprintTimeStart) == 0x000C74, "Member 'UMordhauMovementComponent::RushSprintTimeStart' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, ChasingSprintTimeStart) == 0x000C78, "Member 'UMordhauMovementComponent::ChasingSprintTimeStart' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, BeingChasedSlowdownTimeFactor) == 0x000C7C, "Member 'UMordhauMovementComponent::BeingChasedSlowdownTimeFactor' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, MaxAngleToChase) == 0x000C80, "Member 'UMordhauMovementComponent::MaxAngleToChase' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, MaxAngleToStopChasing) == 0x000C84, "Member 'UMordhauMovementComponent::MaxAngleToStopChasing' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, ChasingMaxDistance) == 0x000C88, "Member 'UMordhauMovementComponent::ChasingMaxDistance' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, StopChasingMaxDistance) == 0x000C94, "Member 'UMordhauMovementComponent::StopChasingMaxDistance' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, ChasedMaxDistance) == 0x000CA0, "Member 'UMordhauMovementComponent::ChasedMaxDistance' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, TimeToBreakUsChasing) == 0x000CAC, "Member 'UMordhauMovementComponent::TimeToBreakUsChasing' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, TimeToBreakUsBeingChased) == 0x000CB0, "Member 'UMordhauMovementComponent::TimeToBreakUsBeingChased' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, MinTimeToStartChasing) == 0x000CB4, "Member 'UMordhauMovementComponent::MinTimeToStartChasing' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, MinTimeToStartBeingChased) == 0x000CB8, "Member 'UMordhauMovementComponent::MinTimeToStartBeingChased' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, MaxWalkSpeedCrouchedWithRatPerk) == 0x000CBC, "Member 'UMordhauMovementComponent::MaxWalkSpeedCrouchedWithRatPerk' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, SprintModifier) == 0x000CC0, "Member 'UMordhauMovementComponent::SprintModifier' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, ChasingModifier) == 0x000CC4, "Member 'UMordhauMovementComponent::ChasingModifier' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, PartialSprintModifier) == 0x000CC8, "Member 'UMordhauMovementComponent::PartialSprintModifier' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, SupersprintModifier) == 0x000CCC, "Member 'UMordhauMovementComponent::SupersprintModifier' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, BackpedalModifier) == 0x000CD0, "Member 'UMordhauMovementComponent::BackpedalModifier' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, StrafeModifier) == 0x000CD4, "Member 'UMordhauMovementComponent::StrafeModifier' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, WalkAcceleration) == 0x000CD8, "Member 'UMordhauMovementComponent::WalkAcceleration' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, PartialSprintAcceleration) == 0x000CDC, "Member 'UMordhauMovementComponent::PartialSprintAcceleration' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, SprintAcceleration) == 0x000CE0, "Member 'UMordhauMovementComponent::SprintAcceleration' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, SprintTimeToReachMaxSprint) == 0x000CE4, "Member 'UMordhauMovementComponent::SprintTimeToReachMaxSprint' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, SprintTime) == 0x000CE8, "Member 'UMordhauMovementComponent::SprintTime' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, SupersprintAcceleration) == 0x000CF0, "Member 'UMordhauMovementComponent::SupersprintAcceleration' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, MotionSpeedFactor) == 0x000CF4, "Member 'UMordhauMovementComponent::MotionSpeedFactor' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, MotionBackpedalSpeedFactor) == 0x000CF8, "Member 'UMordhauMovementComponent::MotionBackpedalSpeedFactor' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, EquipmentBackpedalSpeedFactor) == 0x000CFC, "Member 'UMordhauMovementComponent::EquipmentBackpedalSpeedFactor' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, EquipmentSpeedFactorOverride) == 0x000D00, "Member 'UMordhauMovementComponent::EquipmentSpeedFactorOverride' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, ArmorSpeedFactor) == 0x000D04, "Member 'UMordhauMovementComponent::ArmorSpeedFactor' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, ArmorAccelerationFactor) == 0x000D08, "Member 'UMordhauMovementComponent::ArmorAccelerationFactor' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, EquipmentSpeedBonusPercentage) == 0x000D0C, "Member 'UMordhauMovementComponent::EquipmentSpeedBonusPercentage' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, EquipmentSubSprintSpeedBonus) == 0x000D10, "Member 'UMordhauMovementComponent::EquipmentSubSprintSpeedBonus' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, EquipmentAccelerationBonusPercentage) == 0x000D14, "Member 'UMordhauMovementComponent::EquipmentAccelerationBonusPercentage' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, MovementModifier) == 0x000D18, "Member 'UMordhauMovementComponent::MovementModifier' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, bWantsSprint) == 0x000D19, "Member 'UMordhauMovementComponent::bWantsSprint' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, bSprintIsAllowed) == 0x000D1A, "Member 'UMordhauMovementComponent::bSprintIsAllowed' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, bOnlyPartialSprint) == 0x000D1B, "Member 'UMordhauMovementComponent::bOnlyPartialSprint' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, bWantsSupersprint) == 0x000D1C, "Member 'UMordhauMovementComponent::bWantsSupersprint' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, KnockbackGroundFriction) == 0x000D20, "Member 'UMordhauMovementComponent::KnockbackGroundFriction' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, KnockbackFallingLateralFriction) == 0x000D24, "Member 'UMordhauMovementComponent::KnockbackFallingLateralFriction' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, KnockbackUpImpulse) == 0x000D28, "Member 'UMordhauMovementComponent::KnockbackUpImpulse' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, MaxSpeedFalling) == 0x000D2C, "Member 'UMordhauMovementComponent::MaxSpeedFalling' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, BaseGroundFriction) == 0x000D30, "Member 'UMordhauMovementComponent::BaseGroundFriction' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, BaseFallingLateralFriction) == 0x000D34, "Member 'UMordhauMovementComponent::BaseFallingLateralFriction' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, KnockbackDuration) == 0x000D38, "Member 'UMordhauMovementComponent::KnockbackDuration' has a wrong offset!");
static_assert(offsetof(UMordhauMovementComponent, BrakingDecelerationFallingTooFast) == 0x000D3C, "Member 'UMordhauMovementComponent::BrakingDecelerationFallingTooFast' has a wrong offset!");

// Class Mordhau.MordhauNavigationQueryFilter
// 0x0000 (0x0048 - 0x0048)
class UMordhauNavigationQueryFilter : public UNavigationQueryFilter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauNavigationQueryFilter">();
	}
	static class UMordhauNavigationQueryFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauNavigationQueryFilter>();
	}
};
static_assert(alignof(UMordhauNavigationQueryFilter) == 0x000008, "Wrong alignment on UMordhauNavigationQueryFilter");
static_assert(sizeof(UMordhauNavigationQueryFilter) == 0x000048, "Wrong size on UMordhauNavigationQueryFilter");

// Class Mordhau.MordhauNetworkTypes
// 0x0000 (0x0028 - 0x0028)
class UMordhauNetworkTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauNetworkTypes">();
	}
	static class UMordhauNetworkTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauNetworkTypes>();
	}
};
static_assert(alignof(UMordhauNetworkTypes) == 0x000008, "Wrong alignment on UMordhauNetworkTypes");
static_assert(sizeof(UMordhauNetworkTypes) == 0x000028, "Wrong size on UMordhauNetworkTypes");

// Class Mordhau.MordhauObjectiveTracker
// 0x0060 (0x0280 - 0x0220)
class AMordhauObjectiveTracker final : public AInfo
{
public:
	TMap<class AControlPoint*, struct FObjective> Objectives;                                        // 0x0220(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<class AControlPoint*>                  CapturePointsOfInterest;                           // 0x0270(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	TArray<class FText> GetObjectiveInfo(const struct FObjective& Objective, const TArray<int32>& Progress, const TArray<int32>& Goal);
	void OnObjectivesUpdated(const TArray<class FText>& List, const TArray<bool>& Completed);
	void RefreshObjectives();
	void UpdateCapturePoints();

	TArray<int32> GetObjectiveGoal(class AControlPoint* ControlPoint, const struct FObjective& Objective) const;
	TArray<int32> GetObjectiveProgress(class AControlPoint* ControlPoint, const struct FObjective& Objective) const;
	int32 GetTeam(int32 ViewingTeam) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauObjectiveTracker">();
	}
	static class AMordhauObjectiveTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauObjectiveTracker>();
	}
};
static_assert(alignof(AMordhauObjectiveTracker) == 0x000008, "Wrong alignment on AMordhauObjectiveTracker");
static_assert(sizeof(AMordhauObjectiveTracker) == 0x000280, "Wrong size on AMordhauObjectiveTracker");
static_assert(offsetof(AMordhauObjectiveTracker, Objectives) == 0x000220, "Member 'AMordhauObjectiveTracker::Objectives' has a wrong offset!");
static_assert(offsetof(AMordhauObjectiveTracker, CapturePointsOfInterest) == 0x000270, "Member 'AMordhauObjectiveTracker::CapturePointsOfInterest' has a wrong offset!");

// Class Mordhau.MordhauPhysicsCollisionHandler
// 0x0000 (0x0040 - 0x0040)
class UMordhauPhysicsCollisionHandler final : public UPhysicsCollisionHandler
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauPhysicsCollisionHandler">();
	}
	static class UMordhauPhysicsCollisionHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauPhysicsCollisionHandler>();
	}
};
static_assert(alignof(UMordhauPhysicsCollisionHandler) == 0x000008, "Wrong alignment on UMordhauPhysicsCollisionHandler");
static_assert(sizeof(UMordhauPhysicsCollisionHandler) == 0x000040, "Wrong size on UMordhauPhysicsCollisionHandler");

// Class Mordhau.MordhauPlayerController
// 0x0678 (0x0BE8 - 0x0570)
class AMordhauPlayerController : public APlayerController
{
public:
	uint8                                         Pad_570[0x4];                                      // 0x0570(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class APawn>                   LastPawn;                                          // 0x0574(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_57C[0x64];                                     // 0x057C(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	class UTagSystemComponent*                    TagSystemComponent;                                // 0x05E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FServerRestrictionInfo& ServerRestrictionInfo)> OnServerRestrictionInfoReceived;                   // 0x05E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         TotalMordhauCharacterTeamDamage;                   // 0x05F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalMordhauCharacterDamage;                       // 0x05FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAnythingRestockable;                            // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_601[0x3];                                      // 0x0601(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedCharacterProfile;                          // 0x0604(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedDefaultProfile;                            // 0x0608(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60C[0x4];                                      // 0x060C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterProfile                      CharacterProfile;                                  // 0x0610(0x00B8)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bReceivedValidProfileFromClient;                   // 0x06C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C9[0x3];                                      // 0x06C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastAskedForSpawnTime;                             // 0x06CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnToken;                                        // 0x06D0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D4[0xC];                                      // 0x06D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterProfile                      LastSentCharacterProfile;                          // 0x06E0(0x00B8)(NativeAccessSpecifierPublic)
	uint8                                         Pad_798[0x8];                                      // 0x0798(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACustomizationReplicationActor*         CustomizationReplicationActor;                     // 0x07A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSendsDefaultCustomization;                        // 0x07A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A9[0x7];                                      // 0x07A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEquipmentCustomization>        DefaultCharacterEquipment;                         // 0x07B0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C0[0x10];                                     // 0x07C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterGearCustomization>    DefaultCharacterTier;                              // 0x07D0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E0[0x8];                                      // 0x07E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterProfile                      PendingCharacterProfile;                           // 0x07E8(0x00B8)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsPendingCharacterProfileASelectedDefaultProfile; // 0x08A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A1[0x7];                                      // 0x08A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterProfile                      ConstructingCharacterProfile;                      // 0x08A8(0x00B8)(NativeAccessSpecifierPublic)
	uint8                                         Pad_960[0x4];                                      // 0x0960(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AMordhauCharacter>       LastControlledCharacter;                           // 0x0964(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96C[0x54];                                     // 0x096C(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NextRespawnTime;                                   // 0x09C0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C4[0x2];                                      // 0x09C4(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseInstancing;                                    // 0x09C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C7[0x1];                                      // 0x09C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AMordhauPlayerController*>         InInstanceWithControllers;                         // 0x09C8(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         LocallyTrackedObjectiveScore;                      // 0x0A18(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsBlockInput;                                  // 0x0A1C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1D[0x3];                                      // 0x0A1D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAFKTime;                                        // 0x0A20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyAFKIfAlive;                                   // 0x0A24(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A25[0x3];                                      // 0x0A25(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentAFKTime;                                    // 0x0A28(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastAFKCheckCameraLocation;                        // 0x0A2C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAuthenticating;                                 // 0x0A38(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAuthenticated;                                  // 0x0A39(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClientRequestedRewards;                           // 0x0A3A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerReceivedRewards;                            // 0x0A3B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardedGold;                                      // 0x0A3C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardedXP;                                        // 0x0A40(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FServerStats                           ServerStats;                                       // 0x0A44(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5C[0x4];                                      // 0x0A5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         MapVoteMaps;                                       // 0x0A60(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 MapVoteCounts;                                     // 0x0A70(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0A80(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A84[0x4];                                      // 0x0A84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MatchmakingMatchID;                                // 0x0A88(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartyID;                                           // 0x0A98(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartySize;                                         // 0x0AA8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AAC[0x4];                                      // 0x0AAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerCommand                         CurrentPlayerCommand;                              // 0x0AB0(0x0030)(NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AMordhauEquipment>>  PreferredWeaponModes;                              // 0x0AE0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_AF0[0x10];                                     // 0x0AF0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ScreenshotFilenames;                               // 0x0B00(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B10[0x20];                                     // 0x0B10(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bServerSupportsLagReports;                         // 0x0B30(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B31[0x1F];                                     // 0x0B31(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         RegisteredConsoleCommands;                         // 0x0B50(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UUserWidget*                            MordhauMainMenu;                                   // 0x0B60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B68[0x60];                                     // 0x0B68(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     CataClass;                                         // 0x0BC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     HorseClass;                                        // 0x0BD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     HogClass;                                          // 0x0BD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     HorsgorClass;                                      // 0x0BE0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddAdmin(const class FString& PlayerNameOrPlayFabID);
	void AddBots(int32 Amount);
	void AddBotsTeam(int32 Amount, int32 Team);
	void AddRandomBots(int32 Amount);
	void AddRandomCharacters(int32 Num);
	void AdminList();
	void AdminLogin(const class FString& Password);
	bool AreStatsAvailable();
	void AskForSpawn();
	void Ban(const class FString& PlayerNameOrPlayFabID, const int32 BanDuration, const class FString& BanReason);
	void BanList();
	bool CanAskForSpawn();
	void CancelVoteKick();
	void ChangeLevel(const class FString& LevelName);
	void ChangeMap(const class FString& MapName);
	void ChoiceMenu(int32 Index_0);
	void ChoiceMenuOptionSelected(int32 Choice);
	void Choose1();
	void Choose2();
	void Choose3();
	void Choose4();
	void Choose5();
	void Choose6();
	void Choose7();
	void Choose8();
	void Choose9();
	void ChooseExit();
	void ClientDrawTracer(const struct FVector& Start, const struct FVector& End);
	void ClientMessageBP(const class FString& String);
	void ClientReceiveMessage(const class FString& Message);
	void ClientReceiveScore(uint8 ReasonAndParam, int16 ScoreAmount, class AMordhauPlayerState* AssociatedPlayer);
	void ClientReceiveScoreBP(EScoreFeedReason Reason, uint8 ReasonParam, float ScoreAmount, class AMordhauPlayerState* AssociatedPlayer);
	void ClientReceiveScoreNoState(uint8 ReasonAndParam, int16 ScoreAmount);
	void ClientReceiveSphericalHitboxes(const TArray<struct FVector>& Locations, const struct FVector& WeaponTraceStart, const struct FVector& WeaponTraceEnd);
	void ClientRequestMatchmakingMatchID();
	void ClientRequestPartyInfo();
	void ClientRequestSessionTicket();
	void ClientRequestXPAndMMR();
	void ClientSetControlAndPawnRotation(class APawn* APawn, const struct FRotator& NewRotation);
	void ClientSetFlags(const class FString& InMyFlags, const TArray<struct FAdminFlag>& InAdminFlags);
	void ClientSetMapVoteCounts(const TArray<uint8>& InMapVoteCounts);
	void ClientSetMapVoteMaps(const TArray<class FString>& InMapVoteMaps);
	void ClientSetPlayFabMatch(const struct FPlayFabMatch& InMatch);
	void ClientSetServerInfo(const struct FBasicServerInfo& ServerInfo);
	void ClientSetServerStats(const struct FServerStats& InServerStats);
	void ClientWasKicked_Implementation(const class FText& KickReason);
	int32 ComputePlayerRank();
	void CopyID(const class FString& UniqueId);
	void CopyName(const class FString& UniqueId);
	void DebugMultithreadUpdate();
	void DisplayAnnouncement(const class FString& Text, const class FString& Subtext, float Duration);
	void DisplayMessage(class APlayerState* SenderPlayerState, const class FString& S, class FName Type, float MsgLifeTime);
	void EquipmentCommand(int32 Command);
	void FlushPendingAnglingInputs();
	float GetAnglingAngle();
	struct FVector2D GetAnglingVector();
	bool GetDefaultEquipmentCustomizationFor(TSubclassOf<class AMordhauEquipment> ForEquipmentClass, struct FEquipmentCustomization* OutCustomization);
	bool GetDefaultTierCustomizationForSlot(EMainWearableSlot MainSlot, uint8 ArmorTier, TMap<EWearableSlot, struct FWearableCustomization>* OutMap);
	class AMordhauCharacter* GetLastControlledCharacter();
	class AAdvancedCharacter* GetNextViewablePlayerNonAuth(bool bReverse, bool bOnlyOwnTeam);
	class FString GetPlayFabId();
	void GiveCata();
	void GiveClientScoreBP(EScoreFeedReason Reason, int32 ScoreAmount);
	void GiveHog();
	void GiveHorse();
	void Horsgor();
	bool IsAllowedClient(const class FString& Command);
	bool IsAllowedServer(const class FString& Command);
	bool IsAuthenticated();
	bool IsAuthenticating();
	bool IsConsoleCommandRegistered(const class FString& CommandName);
	bool IsConsoleOpen();
	bool IsInventoryAvailable();
	bool IsSessionTicketAvailable();
	void Kick(const class FString& PlayerNameOrPlayFabID, const class FString& KickReason);
	void LookUp(float Value);
	void LookupPlayer(const class FString& UniqueId);
	void MountPak(const class FString& PakPath);
	void Mute(const class FString& PlayerNameOrPlayFabID, const int32 MuteDuration);
	void MuteList();
	void OnActionFailed(const class FName& Reason);
	void OnAddRandomBots(int32 Num);
	void OnAFKTimeExceededMaximum();
	void OnAfterPossess(class APawn* APawn);
	void OnAfterUnPossess();
	void OnAmmoChanged(class AMordhauEquipment* Equipment, int32 AmmoDifference);
	void OnGetPlayFabIDsFromPlatformIDsComplete(bool bWasSuccessful, const struct FPlayFabApiError& Error, const TMap<class FString, class FString>& PlayFabIds);
	void OnGetPlayFabPlayerComplete(bool bWasSuccessful, const struct FPlayFabApiError& Error, const class FString& PlayFabId, const struct FPlayFabPlayer& PlayFabPlayer);
	void OnHighlightEnd(class AActor* Actor);
	void OnHighlightStart(class AActor* Actor);
	void OnInventoryItemsUnlocked(bool bWasSuccessful, const TArray<struct FItemStack>& ItemStacks);
	void OnIsAnythingRestockableChanged();
	void OnMordhauCharacterSpawned(class AMordhauCharacter* SpawnedCharacter);
	void OnNewProfileFromClientPostValidation();
	void OnNewProfileFromClientPreValidation();
	void OnPlayFabLoginComplete(bool bWasSuccessful, const struct FPlayFabApiError& Error, const class FString& PlayFabId);
	void OnReceivedAssistScore(float Percentage, class AMordhauCharacter* Killed);
	void OnReceivedKillScore(class AMordhauCharacter* Killed);
	void OnRequestCancelVoteKick();
	void OnRequestVoteKick(class AMordhauPlayerState* TargetPlayer);
	void OnSettingsChanged();
	void OnSkipTutorial();
	void OnSpectatorAction(uint8 Action);
	void OnSpectatorCmd(const class FString& Cmd, const class FString& Param);
	void ParryThis();
	void PlayerList();
	void PlayerStats();
	void PlayerStatus(const class FString& PlayFabId);
	void PrepareAndSendCustomizationIfChanged();
	void ProcessChatCommand(const class FString& Prefix, const class FString& Command, const class FString& Args);
	void QuickReportPlayer(EPlayerReportType PlayerReportType, const class FString& Platform, const class FString& ReporterId, const class FString& OffenderId, const class FString& ErrorMessage, const class FString& ServerId);
	void ReceiveServerRestrictionInfo(const struct FServerRestrictionInfo& Info);
	void RegisterAnglingXInput(float Value);
	void RegisterAnglingYInput(float Value);
	void RegisterConsoleCommand(const struct FMordhauConsoleCommand& ConsoleCommand);
	void RemoveAdmin(const class FString& PlayerNameOrPlayFabID);
	void RemoveBots(int32 Amount);
	void RemoveBotsTeam(int32 Amount, int32 Team);
	void ReportPlayer(const class FString& ReporteePlayFabID, const class FString& ReportType, const class FString& ScreenshotFilename);
	void ReportServerLag();
	void RequestQuickReportPlayer(EPlayerReportType PlayerReportType, const class FString& Platform, const class FString& ReporterId, const class FString& OffenderId, const class FString& ErrorMessage, const class FString& ServerId);
	void RequestReportPlayer(const class FString& ReporteePlayFabID, const class FString& ReportType, const class FString& Screenshot);
	void RequestRewards();
	void RequestServerRestrictionInfo();
	void RequestSphericalHitboxes();
	void SaveCurrentProfilesAsBotProfiles();
	void Server_Reliable_GiveCata();
	void Server_Reliable_GiveHog();
	void Server_Reliable_GiveHorse();
	void Server_Reliable_Horsgor();
	void ServerAddAdmin(const class FString& PlayFabId);
	void ServerAddBots(int32 Amount, int32 Team);
	void ServerAdminList();
	void ServerAdminLogin(const class FString& Password);
	void ServerBanList();
	void ServerBanPlayer(const class FString& PlayFabId, const int32 BanDuration, const class FString& BanReason);
	void ServerChangeLevel(const class FString& LevelName);
	void ServerChatMutePlayer(const class FString& PlayFabId, const int32 MuteDuration);
	void ServerChatUnmutePlayer(const class FString& PlayFabId);
	void ServerGetMapVoteCounts();
	void ServerGetMapVoteMaps();
	void ServerGetServerStats();
	void ServerHasPassedCheck(uint8 Param);
	void ServerKickPlayer(const class FString& PlayFabId, const class FString& KickReason);
	void ServerMuteList();
	void ServerNotifyItemsUnlocked();
	void ServerNotifyPlayerDisconnecting();
	void ServerPlayerStats();
	void ServerPlayerStatus(const class FString& PlayFabId);
	void ServerRemoveAdmin(const class FString& PlayFabId);
	void ServerRemoveBots(int32 Amount, int32 Team);
	void ServerReportServerLag();
	void ServerRequestAuthTraces(bool bEnabled);
	void ServerRequestSetAppearanceCustomization(const struct FAppearanceCustomization& NewCharacterAppearance);
	void ServerRequestSetDefaultCharacterEquipment(const TArray<struct FEquipmentCustomization>& Equip);
	void ServerRequestSetDefaultCharacterTiers(const TArray<struct FCharacterGearCustomization>& Tiers);
	void ServerRequestSetDefaultProfile(int32 NewDefaultProfile);
	void ServerRequestSetFaceCustomization(const struct FFaceCustomization& NewCharacterFace);
	void ServerRequestSetGearCustomization(const struct FCharacterGearCustomization& NewCharacterGear);
	void ServerRequestSetSkillsCustomization(const struct FSkillsCustomization& NewCharacterSkills);
	void ServerRequestSetTeam(int32 NewTeam);
	void ServerRequestSphericalHitboxes();
	void ServerSetBadge(uint8 NewBadge);
	void ServerSetFriendlyNetSkipOffset(int32 NewFriendlyNetSkipOffset);
	void ServerSetLevelDisplayType(uint8 NewLevelDisplayType);
	void ServerSetMatchmakingMatchID(const class FString& InMatchmakingMatchID);
	void ServerSetMaxNetSkip(int32 NewMaxNetSkip);
	void ServerSetPartyInfo(const class FString& InPartyID, int32 InPartySize);
	void ServerSetSessionTicket(const class FString& InSessionTicket);
	void ServerSetSpawnToken(int32 NewToken);
	void ServerSetXPAndMMR(int32 XP, int32 DuelMMR, int32 TeamfightMMR, int32 CasualMMR);
	void ServerSlomo(float Value);
	void ServerStartServerStatsFile();
	void ServerStopServerStatsFile();
	void ServerToggleDamage();
	void ServerToggleNetProfile();
	void ServerToggleStamina();
	void ServerUnbanPlayer(const class FString& PlayFabId);
	void ServerVoteLevel(const class FString& LevelName);
	void SetChoiceMenuConsumesInput(bool Value);
	void SetFriendlyNetSkipOffset(int32 NewFriendlyNetSkipOffset);
	void SetMaxNetSkip(int32 NewMaxNetSkip);
	void SetServerSupportsLagReports(bool bSupported);
	void SetWeaponModesArray(const TArray<TSubclassOf<class AMordhauEquipment>>& InWeapons);
	void ShowAuthTraces(bool bValue);
	void ShowEquipment();
	void ShowTips();
	void SkipTutorial();
	void Slomo(float Value);
	void SpectatorCmd(const class FString& SpecCmd);
	void StartServerStatsFile();
	void StopServerStatsFile();
	void TakeReportScreenshot();
	void ToggleDamage();
	void ToggleServerNetProfile();
	void ToggleStamina();
	void Turn(float Value);
	void Unban(const class FString& PlayFabId);
	void UnmountPak(const class FString& PakPath);
	void Unmute(const class FString& PlayerNameOrPlayFabID);
	void UnregisterConsoleCommand(const class FString& CommandName);
	void UpdateWeaponMode(TSubclassOf<class AMordhauEquipment> WeaponToUpdate, bool bAltMode);
	void UploadImage(const TArray<uint8>& ImageData, const class FString& URL, TDelegate<void(const class FString& response, bool bSuccess)> ImageUploadCompletedDelegate);
	void VoteKick(const class FString& PlayerNameOrPlayFabID);
	void VoteLevel(const class FString& LevelName);
	void VoteMap(const class FString& MapName);

	class AMordhauCharacter* GetControlledMordhauCharacter(bool bAlsoSearchVehicle) const;
	const struct FPlayFabPlayer GetPlayFabPlayer() const;
	bool IsAdmin() const;
	bool SharesInstanceWith(const class AActor* OtherActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauPlayerController">();
	}
	static class AMordhauPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauPlayerController>();
	}
};
static_assert(alignof(AMordhauPlayerController) == 0x000008, "Wrong alignment on AMordhauPlayerController");
static_assert(sizeof(AMordhauPlayerController) == 0x000BE8, "Wrong size on AMordhauPlayerController");
static_assert(offsetof(AMordhauPlayerController, LastPawn) == 0x000574, "Member 'AMordhauPlayerController::LastPawn' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, TagSystemComponent) == 0x0005E0, "Member 'AMordhauPlayerController::TagSystemComponent' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, OnServerRestrictionInfoReceived) == 0x0005E8, "Member 'AMordhauPlayerController::OnServerRestrictionInfoReceived' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, TotalMordhauCharacterTeamDamage) == 0x0005F8, "Member 'AMordhauPlayerController::TotalMordhauCharacterTeamDamage' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, TotalMordhauCharacterDamage) == 0x0005FC, "Member 'AMordhauPlayerController::TotalMordhauCharacterDamage' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, bIsAnythingRestockable) == 0x000600, "Member 'AMordhauPlayerController::bIsAnythingRestockable' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, SelectedCharacterProfile) == 0x000604, "Member 'AMordhauPlayerController::SelectedCharacterProfile' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, SelectedDefaultProfile) == 0x000608, "Member 'AMordhauPlayerController::SelectedDefaultProfile' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, CharacterProfile) == 0x000610, "Member 'AMordhauPlayerController::CharacterProfile' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, bReceivedValidProfileFromClient) == 0x0006C8, "Member 'AMordhauPlayerController::bReceivedValidProfileFromClient' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, LastAskedForSpawnTime) == 0x0006CC, "Member 'AMordhauPlayerController::LastAskedForSpawnTime' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, SpawnToken) == 0x0006D0, "Member 'AMordhauPlayerController::SpawnToken' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, LastSentCharacterProfile) == 0x0006E0, "Member 'AMordhauPlayerController::LastSentCharacterProfile' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, CustomizationReplicationActor) == 0x0007A0, "Member 'AMordhauPlayerController::CustomizationReplicationActor' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, bSendsDefaultCustomization) == 0x0007A8, "Member 'AMordhauPlayerController::bSendsDefaultCustomization' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, DefaultCharacterEquipment) == 0x0007B0, "Member 'AMordhauPlayerController::DefaultCharacterEquipment' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, DefaultCharacterTier) == 0x0007D0, "Member 'AMordhauPlayerController::DefaultCharacterTier' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, PendingCharacterProfile) == 0x0007E8, "Member 'AMordhauPlayerController::PendingCharacterProfile' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, bIsPendingCharacterProfileASelectedDefaultProfile) == 0x0008A0, "Member 'AMordhauPlayerController::bIsPendingCharacterProfileASelectedDefaultProfile' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, ConstructingCharacterProfile) == 0x0008A8, "Member 'AMordhauPlayerController::ConstructingCharacterProfile' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, LastControlledCharacter) == 0x000964, "Member 'AMordhauPlayerController::LastControlledCharacter' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, NextRespawnTime) == 0x0009C0, "Member 'AMordhauPlayerController::NextRespawnTime' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, bUseInstancing) == 0x0009C6, "Member 'AMordhauPlayerController::bUseInstancing' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, InInstanceWithControllers) == 0x0009C8, "Member 'AMordhauPlayerController::InInstanceWithControllers' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, LocallyTrackedObjectiveScore) == 0x000A18, "Member 'AMordhauPlayerController::LocallyTrackedObjectiveScore' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, bWantsBlockInput) == 0x000A1C, "Member 'AMordhauPlayerController::bWantsBlockInput' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, MaxAFKTime) == 0x000A20, "Member 'AMordhauPlayerController::MaxAFKTime' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, bOnlyAFKIfAlive) == 0x000A24, "Member 'AMordhauPlayerController::bOnlyAFKIfAlive' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, CurrentAFKTime) == 0x000A28, "Member 'AMordhauPlayerController::CurrentAFKTime' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, LastAFKCheckCameraLocation) == 0x000A2C, "Member 'AMordhauPlayerController::LastAFKCheckCameraLocation' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, bIsAuthenticating) == 0x000A38, "Member 'AMordhauPlayerController::bIsAuthenticating' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, bIsAuthenticated) == 0x000A39, "Member 'AMordhauPlayerController::bIsAuthenticated' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, bClientRequestedRewards) == 0x000A3A, "Member 'AMordhauPlayerController::bClientRequestedRewards' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, bServerReceivedRewards) == 0x000A3B, "Member 'AMordhauPlayerController::bServerReceivedRewards' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, RewardedGold) == 0x000A3C, "Member 'AMordhauPlayerController::RewardedGold' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, RewardedXP) == 0x000A40, "Member 'AMordhauPlayerController::RewardedXP' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, ServerStats) == 0x000A44, "Member 'AMordhauPlayerController::ServerStats' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, MapVoteMaps) == 0x000A60, "Member 'AMordhauPlayerController::MapVoteMaps' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, MapVoteCounts) == 0x000A70, "Member 'AMordhauPlayerController::MapVoteCounts' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, Rank) == 0x000A80, "Member 'AMordhauPlayerController::Rank' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, MatchmakingMatchID) == 0x000A88, "Member 'AMordhauPlayerController::MatchmakingMatchID' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, PartyID) == 0x000A98, "Member 'AMordhauPlayerController::PartyID' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, PartySize) == 0x000AA8, "Member 'AMordhauPlayerController::PartySize' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, CurrentPlayerCommand) == 0x000AB0, "Member 'AMordhauPlayerController::CurrentPlayerCommand' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, PreferredWeaponModes) == 0x000AE0, "Member 'AMordhauPlayerController::PreferredWeaponModes' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, ScreenshotFilenames) == 0x000B00, "Member 'AMordhauPlayerController::ScreenshotFilenames' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, bServerSupportsLagReports) == 0x000B30, "Member 'AMordhauPlayerController::bServerSupportsLagReports' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, RegisteredConsoleCommands) == 0x000B50, "Member 'AMordhauPlayerController::RegisteredConsoleCommands' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, MordhauMainMenu) == 0x000B60, "Member 'AMordhauPlayerController::MordhauMainMenu' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, CataClass) == 0x000BC8, "Member 'AMordhauPlayerController::CataClass' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, HorseClass) == 0x000BD0, "Member 'AMordhauPlayerController::HorseClass' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, HogClass) == 0x000BD8, "Member 'AMordhauPlayerController::HogClass' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerController, HorsgorClass) == 0x000BE0, "Member 'AMordhauPlayerController::HorsgorClass' has a wrong offset!");

// Class Mordhau.MordhauPlayerStart
// 0x0010 (0x0260 - 0x0250)
class AMordhauPlayerStart : public APlayerStart
{
public:
	bool                                          bIsSpawnDisabled;                                  // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Team;                                              // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Token;                                             // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSpawnPreferenceFor(class AController* Player);
	bool IsAllowedSpawnFor(class AController* Player);
	void OnSpawnChosen(class AController* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauPlayerStart">();
	}
	static class AMordhauPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauPlayerStart>();
	}
};
static_assert(alignof(AMordhauPlayerStart) == 0x000008, "Wrong alignment on AMordhauPlayerStart");
static_assert(sizeof(AMordhauPlayerStart) == 0x000260, "Wrong size on AMordhauPlayerStart");
static_assert(offsetof(AMordhauPlayerStart, bIsSpawnDisabled) == 0x000250, "Member 'AMordhauPlayerStart::bIsSpawnDisabled' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerStart, Team) == 0x000254, "Member 'AMordhauPlayerStart::Team' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerStart, Token) == 0x000258, "Member 'AMordhauPlayerStart::Token' has a wrong offset!");

// Class Mordhau.MordhauPlayerState
// 0x00F0 (0x0410 - 0x0320)
class AMordhauPlayerState : public APlayerState
{
public:
	TWeakObjectPtr<class AMordhauCharacter>       LastMordhauCharacter;                              // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<float>                                 MedianPings;                                       // 0x0328(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<float>                                 MedianPingsSorted;                                 // 0x0338(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         CurMedianPingIndex;                                // 0x0348(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PingMedian;                                        // 0x034C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocalStableShortID;                                // 0x0350(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         ReplicatedRank;                                    // 0x0354(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         ReplicatedKills;                                   // 0x0356(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         ReplicatedAssists;                                 // 0x0358(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ReplicatedDeathsAndFlags;                          // 0x035A(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          ReplicatedTeam;                                    // 0x035C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Badge;                                             // 0x035D(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LevelDisplayType;                                  // 0x035E(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPartyMember;                                    // 0x035F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFriend;                                         // 0x0360(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x3];                                      // 0x0361(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FilteredTeamKills;                                 // 0x0364(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAlive;                                          // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x3];                                      // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Kills;                                             // 0x036C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Deaths;                                            // 0x0370(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Assists;                                           // 0x0374(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Team;                                              // 0x0378(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAdmin;                                          // 0x037C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37D[0x3];                                      // 0x037D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AdminTier;                                         // 0x0380(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KilledLocalPlayerCounter;                          // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0394(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_395[0x3];                                      // 0x0395(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KilledByLocalPlayerCounter;                        // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayFabPlayer                         PlayFabPlayer;                                     // 0x03A0(0x0060)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionTicket;                                     // 0x0400(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddAssists(int32 Amount);
	void AddDeaths(int32 Amount);
	void AddKills(int32 Amount);
	void AddScore(int32 Amount);
	void BanPlayer(const int32 BanDuration, const class FString& BanReason, const bool bIsOfficialServerBan, EBanType BanType);
	class AMordhauCharacter* GetLastPossessedMordhauCharacter();
	class FString GetPlayFabId();
	const struct FPlayFabPlayer GetPlayFabPlayer();
	void OnRep_ReplicatedAssists();
	void OnRep_ReplicatedDeathsAndFlags();
	void OnRep_ReplicatedKills();
	void OnRep_ReplicatedTeam();
	void SetPlayerName(const class FString& S);
	void SetTeam(int32 NewTeam);

	int32 GetRank() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauPlayerState">();
	}
	static class AMordhauPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauPlayerState>();
	}
};
static_assert(alignof(AMordhauPlayerState) == 0x000008, "Wrong alignment on AMordhauPlayerState");
static_assert(sizeof(AMordhauPlayerState) == 0x000410, "Wrong size on AMordhauPlayerState");
static_assert(offsetof(AMordhauPlayerState, LastMordhauCharacter) == 0x000320, "Member 'AMordhauPlayerState::LastMordhauCharacter' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, MedianPings) == 0x000328, "Member 'AMordhauPlayerState::MedianPings' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, MedianPingsSorted) == 0x000338, "Member 'AMordhauPlayerState::MedianPingsSorted' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, CurMedianPingIndex) == 0x000348, "Member 'AMordhauPlayerState::CurMedianPingIndex' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, PingMedian) == 0x00034C, "Member 'AMordhauPlayerState::PingMedian' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, LocalStableShortID) == 0x000350, "Member 'AMordhauPlayerState::LocalStableShortID' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, ReplicatedRank) == 0x000354, "Member 'AMordhauPlayerState::ReplicatedRank' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, ReplicatedKills) == 0x000356, "Member 'AMordhauPlayerState::ReplicatedKills' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, ReplicatedAssists) == 0x000358, "Member 'AMordhauPlayerState::ReplicatedAssists' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, ReplicatedDeathsAndFlags) == 0x00035A, "Member 'AMordhauPlayerState::ReplicatedDeathsAndFlags' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, ReplicatedTeam) == 0x00035C, "Member 'AMordhauPlayerState::ReplicatedTeam' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, Badge) == 0x00035D, "Member 'AMordhauPlayerState::Badge' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, LevelDisplayType) == 0x00035E, "Member 'AMordhauPlayerState::LevelDisplayType' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, bIsPartyMember) == 0x00035F, "Member 'AMordhauPlayerState::bIsPartyMember' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, bIsFriend) == 0x000360, "Member 'AMordhauPlayerState::bIsFriend' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, FilteredTeamKills) == 0x000364, "Member 'AMordhauPlayerState::FilteredTeamKills' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, bIsAlive) == 0x000368, "Member 'AMordhauPlayerState::bIsAlive' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, Kills) == 0x00036C, "Member 'AMordhauPlayerState::Kills' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, Deaths) == 0x000370, "Member 'AMordhauPlayerState::Deaths' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, Assists) == 0x000374, "Member 'AMordhauPlayerState::Assists' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, Team) == 0x000378, "Member 'AMordhauPlayerState::Team' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, bIsAdmin) == 0x00037C, "Member 'AMordhauPlayerState::bIsAdmin' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, AdminTier) == 0x000380, "Member 'AMordhauPlayerState::AdminTier' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, KilledLocalPlayerCounter) == 0x000390, "Member 'AMordhauPlayerState::KilledLocalPlayerCounter' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, bIsMuted) == 0x000394, "Member 'AMordhauPlayerState::bIsMuted' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, KilledByLocalPlayerCounter) == 0x000398, "Member 'AMordhauPlayerState::KilledByLocalPlayerCounter' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, PlayFabPlayer) == 0x0003A0, "Member 'AMordhauPlayerState::PlayFabPlayer' has a wrong offset!");
static_assert(offsetof(AMordhauPlayerState, SessionTicket) == 0x000400, "Member 'AMordhauPlayerState::SessionTicket' has a wrong offset!");

// Class Mordhau.MordhauProjectile
// 0x0460 (0x0840 - 0x03E0)
class AMordhauProjectile : public AMordhauActor
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SpinComponent;                                     // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackAttenuation*              ForceFeedbackAttenunation;                         // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyWhenTerminated;                            // 0x03F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasAttachedOnClient;                              // 0x03F9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FA[0x6];                                      // 0x03FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ProjectileName;                                    // 0x0400(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                LastProjectileLocation;                            // 0x0418(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideProjectile;                                   // 0x0424(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_425[0xB];                                      // 0x0425(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CosmeticOffsetToBlendOut;                          // 0x0430(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CosmeticOffsetBlendOutSpeed;                       // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CosmeticOffsetBlendWeight;                         // 0x0464(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OriginalMeshRelativeTransform;                     // 0x0470(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  DefaultMeshRotationOffset;                         // 0x04A0(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FWoundInfo>                     WoundInfoArray;                                    // 0x04B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPhysicalSurface>                      WillStickyOn;                                      // 0x04C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EPhysicalSurface>                      WillPassThroughOn;                                 // 0x04D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EPhysicalSurface, class UParticleSystem*> SurfaceImpactParticles;                            // 0x04E0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EPhysicalSurface, struct FDecalInfo>     SurfaceImpactDecals;                               // 0x0530(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                RotationSpin;                                      // 0x0580(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathBlendDuration;                                 // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RagdollLifeSpan;                                   // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AttackMask;                                        // 0x0594(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_595[0x3];                                      // 0x0595(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMultiplier;                                  // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59C[0x4];                                      // 0x059C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              FlightSound;                                       // 0x05A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ImpactSound;                                       // 0x05A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              FleshImpactSound;                                  // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ProjectileForceFeedback;                           // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         CurrentFlightSound;                                // 0x05C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActorSetAndArray                      CosmeticIgnoreActors;                              // 0x05C8(0x0060)(NativeAccessSpecifierPublic)
	uint8                                         Pad_628[0x70];                                     // 0x0628(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     HitResultCache;                                    // 0x0698(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRotator                               AccumulatedRotationSpin;                           // 0x06A8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FReplicatedProjectileInfo              ReplicatedProjectileInfo;                          // 0x06B4(0x0034)(BlueprintVisible, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Creator;                                           // 0x06E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AController>             OwningController;                                  // 0x06F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APawn>                   OwningPawn;                                        // 0x06F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFromLocalPlayer;                                // 0x0700(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_701[0x7];                                      // 0x0701(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AMordhauProjectile*                     AssociatedProjectile;                              // 0x0708(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageModifierHuntsmanPerk;                        // 0x0710(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_714[0x4];                                      // 0x0714(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Damage;                                            // 0x0718(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 HeadBonus;                                         // 0x0728(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 LegBonus;                                          // 0x0738(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         WoodDamage;                                        // 0x0748(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StoneDamage;                                       // 0x074C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitKnockback;                                      // 0x0750(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasReceivedInfo;                                  // 0x0754(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_755[0x3];                                      // 0x0755(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FiredTime;                                         // 0x0758(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastProjectileSweepTime;                           // 0x075C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesLocalProjectileBlending;                      // 0x0760(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsConfirmed;                                      // 0x0761(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasTerminated;                                    // 0x0762(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_763[0x1];                                      // 0x0763(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TerminatedTime;                                    // 0x0764(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasNetworkOrigin;                                 // 0x0768(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFired;                                         // 0x0769(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76A[0x6];                                      // 0x076A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AMordhauEquipment>>  RestockAmmoForEquipment;                           // 0x0770(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class AMordhauEquipment>          GiveEquipmentOnPickup;                             // 0x0780(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAssignCustomizationOnPickup;                      // 0x0788(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_789[0x7];                                      // 0x0789(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEquipmentCustomization                CreatorEquipmentCustomization;                     // 0x0790(0x0030)(NativeAccessSpecifierPublic)
	bool                                          bIsActiveBlendProjectile;                          // 0x07C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasStartedTrail;                                  // 0x07C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyDetermineMeshLocation;               // 0x07C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C3[0x1];                                      // 0x07C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProjectileCollisionPrecedence;                     // 0x07C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillIgnoreShooter;                                // 0x07C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyDetermineSpinLocation;               // 0x07C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7CA[0x2];                                      // 0x07CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StickySurfacePitchBlend;                           // 0x07CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StickySurfaceYawBlend;                             // 0x07D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D4[0x4];                                      // 0x07D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        TrailParticleTemplate;                             // 0x07D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UParticleSystemComponent> CurrentTrailParticles;                             // 0x07E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrailStartSocket;                                  // 0x07E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TrailEndSocket;                                    // 0x07F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrailWidth;                                        // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrailWidthMode                               TrailWidthMode;                                    // 0x07FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocallyPredicted;                               // 0x07FD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7FE[0x2];                                      // 0x07FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitBounceForce;                                    // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackBounceForce;                                 // 0x0804(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParryBounceForce;                                  // 0x0808(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileBounceForce;                             // 0x080C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnvironmentBounceForce;                            // 0x0810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceAngularVelocityFactor;                       // 0x0814(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceMinAngularVelocity;                          // 0x0818(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldFlinch;                                     // 0x081C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81D[0x3];                                      // 0x081D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CullDistanceRagdoll;                               // 0x0820(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_824[0x4];                                      // 0x0824(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          CollisionComp;                                     // 0x0828(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAdvProjectileMovementComponent*        ProjectileMovement;                                // 0x0830(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_838[0x8];                                      // 0x0838(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAdvProjectileMovementComponent* GetProjectileMovementForProjectileClass(TSubclassOf<class AMordhauProjectile> ProjectileClass);

	bool AttachProjectile(const struct FHitResult& Hit);
	void BounceComponent(class USkeletalMeshComponent* ComponentToBounce, const struct FVector& NewVelocity, const struct FVector& NewAngularVelocity);
	void CarryOverTrail(class AMordhauProjectile* NewProjectile);
	void Fire();
	struct FTransform GetBlendedActorTransform(float T);
	struct FTransform GetBlendedMeshTransform(float T);
	struct FTransform GetBlendedTransform(const struct FTransform& Ours, const struct FTransform& Associated, float T);
	class UParticleSystemComponent* GetCurrentTrailParticles();
	float GetPercentageOfMaxVelocityClamped();
	class AActor* GetProjectileCreator();
	class AController* GetProjectileOwningController();
	void InitializeProjectile(class AController* InOwningController, bool bInIsLocallyPredicted, class AActor* InCreator);
	void OnProjectileDamagedDamagable(class UDamageableComponent* DamagableComp, bool bWillKill, const struct FVector& WorldLocation, class FName bone);
	void OnProjectileFired();
	void OnProjectileHit(const struct FVector& HitLocation, const struct FVector& HitNormal, float BounceForce, uint8 Surface, bool bHasHitWorld, bool bHasStopped);
	void OnProjectileHitCosmetic(class AActor* OtherActor, const struct FHitResult& Hit);
	void OnRep_ReplicatedProjectileInfo();
	void ProcessProjectileHit(bool bIsBlocking, const struct FHitResult& Hit);
	bool RestockCharacter(class AMordhauCharacter* Character);
	void SetCurrentTrailParticles(class UParticleSystemComponent* ParticleSystemComponent);
	void SpawnDecal(const struct FVector& Location, const struct FRotator& Rotation, const struct FDecalInfo& DecalInfo);
	void SpawnParticles(const struct FVector& Location, const struct FRotator& Rotation, class UParticleSystem* System);
	void StartTrail();
	void StopTrail();
	void SweepProjectile();
	void TerminateProjectile();
	void UpdateProjectileState(float DeltaTime);
	bool WillPassThrough(uint8 Surface);
	bool WillSticky(uint8 Surface);

	struct FTransform GetWorldMeshTransformWithOffsets() const;
	bool UsesProjectileBlending() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauProjectile">();
	}
	static class AMordhauProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauProjectile>();
	}
};
static_assert(alignof(AMordhauProjectile) == 0x000010, "Wrong alignment on AMordhauProjectile");
static_assert(sizeof(AMordhauProjectile) == 0x000840, "Wrong size on AMordhauProjectile");
static_assert(offsetof(AMordhauProjectile, SkeletalMeshComponent) == 0x0003E0, "Member 'AMordhauProjectile::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, SpinComponent) == 0x0003E8, "Member 'AMordhauProjectile::SpinComponent' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, ForceFeedbackAttenunation) == 0x0003F0, "Member 'AMordhauProjectile::ForceFeedbackAttenunation' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bDestroyWhenTerminated) == 0x0003F8, "Member 'AMordhauProjectile::bDestroyWhenTerminated' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bWasAttachedOnClient) == 0x0003F9, "Member 'AMordhauProjectile::bWasAttachedOnClient' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, ProjectileName) == 0x000400, "Member 'AMordhauProjectile::ProjectileName' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, LastProjectileLocation) == 0x000418, "Member 'AMordhauProjectile::LastProjectileLocation' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bHideProjectile) == 0x000424, "Member 'AMordhauProjectile::bHideProjectile' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, CosmeticOffsetToBlendOut) == 0x000430, "Member 'AMordhauProjectile::CosmeticOffsetToBlendOut' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, CosmeticOffsetBlendOutSpeed) == 0x000460, "Member 'AMordhauProjectile::CosmeticOffsetBlendOutSpeed' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, CosmeticOffsetBlendWeight) == 0x000464, "Member 'AMordhauProjectile::CosmeticOffsetBlendWeight' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, OriginalMeshRelativeTransform) == 0x000470, "Member 'AMordhauProjectile::OriginalMeshRelativeTransform' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, DefaultMeshRotationOffset) == 0x0004A0, "Member 'AMordhauProjectile::DefaultMeshRotationOffset' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, WoundInfoArray) == 0x0004B0, "Member 'AMordhauProjectile::WoundInfoArray' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, WillStickyOn) == 0x0004C0, "Member 'AMordhauProjectile::WillStickyOn' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, WillPassThroughOn) == 0x0004D0, "Member 'AMordhauProjectile::WillPassThroughOn' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, SurfaceImpactParticles) == 0x0004E0, "Member 'AMordhauProjectile::SurfaceImpactParticles' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, SurfaceImpactDecals) == 0x000530, "Member 'AMordhauProjectile::SurfaceImpactDecals' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, RotationSpin) == 0x000580, "Member 'AMordhauProjectile::RotationSpin' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, PathBlendDuration) == 0x00058C, "Member 'AMordhauProjectile::PathBlendDuration' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, RagdollLifeSpan) == 0x000590, "Member 'AMordhauProjectile::RagdollLifeSpan' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, AttackMask) == 0x000594, "Member 'AMordhauProjectile::AttackMask' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, DamageMultiplier) == 0x000598, "Member 'AMordhauProjectile::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, FlightSound) == 0x0005A0, "Member 'AMordhauProjectile::FlightSound' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, ImpactSound) == 0x0005A8, "Member 'AMordhauProjectile::ImpactSound' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, FleshImpactSound) == 0x0005B0, "Member 'AMordhauProjectile::FleshImpactSound' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, ProjectileForceFeedback) == 0x0005B8, "Member 'AMordhauProjectile::ProjectileForceFeedback' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, CurrentFlightSound) == 0x0005C0, "Member 'AMordhauProjectile::CurrentFlightSound' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, CosmeticIgnoreActors) == 0x0005C8, "Member 'AMordhauProjectile::CosmeticIgnoreActors' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, HitResultCache) == 0x000698, "Member 'AMordhauProjectile::HitResultCache' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, AccumulatedRotationSpin) == 0x0006A8, "Member 'AMordhauProjectile::AccumulatedRotationSpin' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, ReplicatedProjectileInfo) == 0x0006B4, "Member 'AMordhauProjectile::ReplicatedProjectileInfo' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, Creator) == 0x0006E8, "Member 'AMordhauProjectile::Creator' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, OwningController) == 0x0006F0, "Member 'AMordhauProjectile::OwningController' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, OwningPawn) == 0x0006F8, "Member 'AMordhauProjectile::OwningPawn' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bIsFromLocalPlayer) == 0x000700, "Member 'AMordhauProjectile::bIsFromLocalPlayer' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, AssociatedProjectile) == 0x000708, "Member 'AMordhauProjectile::AssociatedProjectile' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, DamageModifierHuntsmanPerk) == 0x000710, "Member 'AMordhauProjectile::DamageModifierHuntsmanPerk' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, Damage) == 0x000718, "Member 'AMordhauProjectile::Damage' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, HeadBonus) == 0x000728, "Member 'AMordhauProjectile::HeadBonus' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, LegBonus) == 0x000738, "Member 'AMordhauProjectile::LegBonus' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, WoodDamage) == 0x000748, "Member 'AMordhauProjectile::WoodDamage' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, StoneDamage) == 0x00074C, "Member 'AMordhauProjectile::StoneDamage' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, HitKnockback) == 0x000750, "Member 'AMordhauProjectile::HitKnockback' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bHasReceivedInfo) == 0x000754, "Member 'AMordhauProjectile::bHasReceivedInfo' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, FiredTime) == 0x000758, "Member 'AMordhauProjectile::FiredTime' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, LastProjectileSweepTime) == 0x00075C, "Member 'AMordhauProjectile::LastProjectileSweepTime' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bUsesLocalProjectileBlending) == 0x000760, "Member 'AMordhauProjectile::bUsesLocalProjectileBlending' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bIsConfirmed) == 0x000761, "Member 'AMordhauProjectile::bIsConfirmed' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bHasTerminated) == 0x000762, "Member 'AMordhauProjectile::bHasTerminated' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, TerminatedTime) == 0x000764, "Member 'AMordhauProjectile::TerminatedTime' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bHasNetworkOrigin) == 0x000768, "Member 'AMordhauProjectile::bHasNetworkOrigin' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bHasFired) == 0x000769, "Member 'AMordhauProjectile::bHasFired' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, RestockAmmoForEquipment) == 0x000770, "Member 'AMordhauProjectile::RestockAmmoForEquipment' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, GiveEquipmentOnPickup) == 0x000780, "Member 'AMordhauProjectile::GiveEquipmentOnPickup' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bAssignCustomizationOnPickup) == 0x000788, "Member 'AMordhauProjectile::bAssignCustomizationOnPickup' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, CreatorEquipmentCustomization) == 0x000790, "Member 'AMordhauProjectile::CreatorEquipmentCustomization' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bIsActiveBlendProjectile) == 0x0007C0, "Member 'AMordhauProjectile::bIsActiveBlendProjectile' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bHasStartedTrail) == 0x0007C1, "Member 'AMordhauProjectile::bHasStartedTrail' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bAutomaticallyDetermineMeshLocation) == 0x0007C2, "Member 'AMordhauProjectile::bAutomaticallyDetermineMeshLocation' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, ProjectileCollisionPrecedence) == 0x0007C4, "Member 'AMordhauProjectile::ProjectileCollisionPrecedence' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bWillIgnoreShooter) == 0x0007C8, "Member 'AMordhauProjectile::bWillIgnoreShooter' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bAutomaticallyDetermineSpinLocation) == 0x0007C9, "Member 'AMordhauProjectile::bAutomaticallyDetermineSpinLocation' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, StickySurfacePitchBlend) == 0x0007CC, "Member 'AMordhauProjectile::StickySurfacePitchBlend' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, StickySurfaceYawBlend) == 0x0007D0, "Member 'AMordhauProjectile::StickySurfaceYawBlend' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, TrailParticleTemplate) == 0x0007D8, "Member 'AMordhauProjectile::TrailParticleTemplate' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, CurrentTrailParticles) == 0x0007E0, "Member 'AMordhauProjectile::CurrentTrailParticles' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, TrailStartSocket) == 0x0007E8, "Member 'AMordhauProjectile::TrailStartSocket' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, TrailEndSocket) == 0x0007F0, "Member 'AMordhauProjectile::TrailEndSocket' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, TrailWidth) == 0x0007F8, "Member 'AMordhauProjectile::TrailWidth' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, TrailWidthMode) == 0x0007FC, "Member 'AMordhauProjectile::TrailWidthMode' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bIsLocallyPredicted) == 0x0007FD, "Member 'AMordhauProjectile::bIsLocallyPredicted' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, HitBounceForce) == 0x000800, "Member 'AMordhauProjectile::HitBounceForce' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, AttackBounceForce) == 0x000804, "Member 'AMordhauProjectile::AttackBounceForce' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, ParryBounceForce) == 0x000808, "Member 'AMordhauProjectile::ParryBounceForce' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, ProjectileBounceForce) == 0x00080C, "Member 'AMordhauProjectile::ProjectileBounceForce' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, EnvironmentBounceForce) == 0x000810, "Member 'AMordhauProjectile::EnvironmentBounceForce' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, BounceAngularVelocityFactor) == 0x000814, "Member 'AMordhauProjectile::BounceAngularVelocityFactor' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, BounceMinAngularVelocity) == 0x000818, "Member 'AMordhauProjectile::BounceMinAngularVelocity' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, bShouldFlinch) == 0x00081C, "Member 'AMordhauProjectile::bShouldFlinch' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, CullDistanceRagdoll) == 0x000820, "Member 'AMordhauProjectile::CullDistanceRagdoll' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, CollisionComp) == 0x000828, "Member 'AMordhauProjectile::CollisionComp' has a wrong offset!");
static_assert(offsetof(AMordhauProjectile, ProjectileMovement) == 0x000830, "Member 'AMordhauProjectile::ProjectileMovement' has a wrong offset!");

// Class Mordhau.MordhauSceneComponent
// 0x0000 (0x0200 - 0x0200)
class UMordhauSceneComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauSceneComponent">();
	}
	static class UMordhauSceneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauSceneComponent>();
	}
};
static_assert(alignof(UMordhauSceneComponent) == 0x000010, "Wrong alignment on UMordhauSceneComponent");
static_assert(sizeof(UMordhauSceneComponent) == 0x000200, "Wrong size on UMordhauSceneComponent");

// Class Mordhau.FindMordhauServerSessions
// 0x00A0 (0x00D0 - 0x0030)
class UFindMordhauServerSessions final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(TArray<struct FServerSearchResult>& Results)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<struct FServerSearchResult>& Results)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EServerList                                   ServerList;                                        // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxResults;                                        // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFindServerSessionsFilter              Filter;                                            // 0x0060(0x0048)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool AllowsJoin(const struct FServerSearchResult& Result);
	static class UFindMordhauServerSessions* FindMordhauServerSessions(class UObject* WorldContextObject, EServerList ServerList_0, int32 MaxResults_0, const struct FFindServerSessionsFilter& Filter_0);
	static int32 GetCurrentPlayers(const struct FServerSearchResult& Result);
	static class FString GetGameMode(const struct FServerSearchResult& Result);
	static class FString GetMapName(const struct FServerSearchResult& Result);
	static int32 GetMaxPlayers(const struct FServerSearchResult& Result);
	static TArray<int32> GetMods(const struct FServerSearchResult& Result);
	static int32 GetPing(const struct FServerSearchResult& Result);
	static TArray<class FString> GetPlayers(const struct FServerSearchResult& Result);
	static EServerRegion GetRegion(const struct FServerSearchResult& Result);
	static class FString GetServerAddress(const struct FServerSearchResult& Result);
	static class FString GetServerID(const struct FServerSearchResult& Result);
	static EServerList GetServerList(const struct FServerSearchResult& Result);
	static class FString GetServerName(const struct FServerSearchResult& Result);
	static EServerVisibility GetVisibility(const struct FServerSearchResult& Result);
	static bool IsConsoleServer(const struct FServerSearchResult& Result);
	static bool IsFavoriteServer(const struct FServerSearchResult& Result);
	static bool IsModded(const struct FServerSearchResult& Result);
	static bool IsNoviceServer(const struct FServerSearchResult& Result);
	static bool IsOfficial(const struct FServerSearchResult& Result);
	static bool IsPasswordProtected(const struct FServerSearchResult& Result);
	static bool IsRecentServer(const struct FServerSearchResult& Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FindMordhauServerSessions">();
	}
	static class UFindMordhauServerSessions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFindMordhauServerSessions>();
	}
};
static_assert(alignof(UFindMordhauServerSessions) == 0x000008, "Wrong alignment on UFindMordhauServerSessions");
static_assert(sizeof(UFindMordhauServerSessions) == 0x0000D0, "Wrong size on UFindMordhauServerSessions");
static_assert(offsetof(UFindMordhauServerSessions, onSuccess) == 0x000030, "Member 'UFindMordhauServerSessions::onSuccess' has a wrong offset!");
static_assert(offsetof(UFindMordhauServerSessions, onFailure) == 0x000040, "Member 'UFindMordhauServerSessions::onFailure' has a wrong offset!");
static_assert(offsetof(UFindMordhauServerSessions, World) == 0x000050, "Member 'UFindMordhauServerSessions::World' has a wrong offset!");
static_assert(offsetof(UFindMordhauServerSessions, ServerList) == 0x000058, "Member 'UFindMordhauServerSessions::ServerList' has a wrong offset!");
static_assert(offsetof(UFindMordhauServerSessions, MaxResults) == 0x00005C, "Member 'UFindMordhauServerSessions::MaxResults' has a wrong offset!");
static_assert(offsetof(UFindMordhauServerSessions, Filter) == 0x000060, "Member 'UFindMordhauServerSessions::Filter' has a wrong offset!");

// Class Mordhau.FindMordhauServerSessionByAddress
// 0x0038 (0x0068 - 0x0030)
class UFindMordhauServerSessionByAddress final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(struct FServerSearchResult& Result)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FServerSearchResult& Result)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FServerAddress                         Address;                                           // 0x0058(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFindMordhauServerSessionByAddress* FindMordhauServerSessionByAddress(class UObject* WorldContextObject, const struct FServerAddress& Address_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FindMordhauServerSessionByAddress">();
	}
	static class UFindMordhauServerSessionByAddress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFindMordhauServerSessionByAddress>();
	}
};
static_assert(alignof(UFindMordhauServerSessionByAddress) == 0x000008, "Wrong alignment on UFindMordhauServerSessionByAddress");
static_assert(sizeof(UFindMordhauServerSessionByAddress) == 0x000068, "Wrong size on UFindMordhauServerSessionByAddress");
static_assert(offsetof(UFindMordhauServerSessionByAddress, onSuccess) == 0x000030, "Member 'UFindMordhauServerSessionByAddress::onSuccess' has a wrong offset!");
static_assert(offsetof(UFindMordhauServerSessionByAddress, onFailure) == 0x000040, "Member 'UFindMordhauServerSessionByAddress::onFailure' has a wrong offset!");
static_assert(offsetof(UFindMordhauServerSessionByAddress, World) == 0x000050, "Member 'UFindMordhauServerSessionByAddress::World' has a wrong offset!");
static_assert(offsetof(UFindMordhauServerSessionByAddress, Address) == 0x000058, "Member 'UFindMordhauServerSessionByAddress::Address' has a wrong offset!");

// Class Mordhau.FindMordhauServerSessionByServerDetails
// 0x0068 (0x0098 - 0x0030)
class UFindMordhauServerSessionByServerDetails final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(struct FServerSearchResult& Result)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FServerSearchResult& Result)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayFabServerDetails                  SearchingServerDetails;                            // 0x0058(0x0038)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFindMordhauServerSessionByServerDetails* FindMordhauServerSessionByServerDetails(class UObject* WorldContextObject, const struct FPlayFabServerDetails& InServerDetails);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FindMordhauServerSessionByServerDetails">();
	}
	static class UFindMordhauServerSessionByServerDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFindMordhauServerSessionByServerDetails>();
	}
};
static_assert(alignof(UFindMordhauServerSessionByServerDetails) == 0x000008, "Wrong alignment on UFindMordhauServerSessionByServerDetails");
static_assert(sizeof(UFindMordhauServerSessionByServerDetails) == 0x000098, "Wrong size on UFindMordhauServerSessionByServerDetails");
static_assert(offsetof(UFindMordhauServerSessionByServerDetails, onSuccess) == 0x000030, "Member 'UFindMordhauServerSessionByServerDetails::onSuccess' has a wrong offset!");
static_assert(offsetof(UFindMordhauServerSessionByServerDetails, onFailure) == 0x000040, "Member 'UFindMordhauServerSessionByServerDetails::onFailure' has a wrong offset!");
static_assert(offsetof(UFindMordhauServerSessionByServerDetails, World) == 0x000050, "Member 'UFindMordhauServerSessionByServerDetails::World' has a wrong offset!");
static_assert(offsetof(UFindMordhauServerSessionByServerDetails, SearchingServerDetails) == 0x000058, "Member 'UFindMordhauServerSessionByServerDetails::SearchingServerDetails' has a wrong offset!");

// Class Mordhau.JoinMordhauServerSession
// 0x0148 (0x0178 - 0x0030)
class UJoinMordhauServerSession final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x128];                                     // 0x0050(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJoinMordhauServerSession* JoinMordhauServerSession(const struct FServerSearchResult& SearchResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JoinMordhauServerSession">();
	}
	static class UJoinMordhauServerSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJoinMordhauServerSession>();
	}
};
static_assert(alignof(UJoinMordhauServerSession) == 0x000008, "Wrong alignment on UJoinMordhauServerSession");
static_assert(sizeof(UJoinMordhauServerSession) == 0x000178, "Wrong size on UJoinMordhauServerSession");
static_assert(offsetof(UJoinMordhauServerSession, onSuccess) == 0x000030, "Member 'UJoinMordhauServerSession::onSuccess' has a wrong offset!");
static_assert(offsetof(UJoinMordhauServerSession, onFailure) == 0x000040, "Member 'UJoinMordhauServerSession::onFailure' has a wrong offset!");

// Class Mordhau.CancelFindMordhauSessions
// 0x0000 (0x0028 - 0x0028)
class UCancelFindMordhauSessions final : public UObject
{
public:
	static bool CancelFindMordhauSessions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CancelFindMordhauSessions">();
	}
	static class UCancelFindMordhauSessions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCancelFindMordhauSessions>();
	}
};
static_assert(alignof(UCancelFindMordhauSessions) == 0x000008, "Wrong alignment on UCancelFindMordhauSessions");
static_assert(sizeof(UCancelFindMordhauSessions) == 0x000028, "Wrong size on UCancelFindMordhauSessions");

// Class Mordhau.DestroyMordhauServerSession
// 0x0038 (0x0068 - 0x0030)
class UDestroyMordhauServerSession final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDestroyMordhauServerSession* DestroyMordhauServerSession();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestroyMordhauServerSession">();
	}
	static class UDestroyMordhauServerSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestroyMordhauServerSession>();
	}
};
static_assert(alignof(UDestroyMordhauServerSession) == 0x000008, "Wrong alignment on UDestroyMordhauServerSession");
static_assert(sizeof(UDestroyMordhauServerSession) == 0x000068, "Wrong size on UDestroyMordhauServerSession");
static_assert(offsetof(UDestroyMordhauServerSession, onSuccess) == 0x000030, "Member 'UDestroyMordhauServerSession::onSuccess' has a wrong offset!");
static_assert(offsetof(UDestroyMordhauServerSession, onFailure) == 0x000040, "Member 'UDestroyMordhauServerSession::onFailure' has a wrong offset!");

// Class Mordhau.PingMordhauServerSession
// 0x0140 (0x0170 - 0x0030)
class UPingMordhauServerSession final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 Ping)>    onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Ping)>    onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FServerSearchResult                    SearchResult;                                      // 0x0060(0x0110)(NativeAccessSpecifierPrivate)

public:
	static class UPingMordhauServerSession* PingMordhauServerSession(class UObject* WorldContextObject, const struct FServerSearchResult& SearchResult_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingMordhauServerSession">();
	}
	static class UPingMordhauServerSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPingMordhauServerSession>();
	}
};
static_assert(alignof(UPingMordhauServerSession) == 0x000008, "Wrong alignment on UPingMordhauServerSession");
static_assert(sizeof(UPingMordhauServerSession) == 0x000170, "Wrong size on UPingMordhauServerSession");
static_assert(offsetof(UPingMordhauServerSession, onSuccess) == 0x000030, "Member 'UPingMordhauServerSession::onSuccess' has a wrong offset!");
static_assert(offsetof(UPingMordhauServerSession, onFailure) == 0x000040, "Member 'UPingMordhauServerSession::onFailure' has a wrong offset!");
static_assert(offsetof(UPingMordhauServerSession, World) == 0x000058, "Member 'UPingMordhauServerSession::World' has a wrong offset!");
static_assert(offsetof(UPingMordhauServerSession, SearchResult) == 0x000060, "Member 'UPingMordhauServerSession::SearchResult' has a wrong offset!");

// Class Mordhau.ReserveMordhauServerSessionSlots
// 0x0160 (0x0190 - 0x0030)
class UReserveMordhauServerSessionSlots final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFull;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              onFailure;                                         // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FServerSearchResult                    SearchResult;                                      // 0x0070(0x0110)(NativeAccessSpecifierPrivate)
	TArray<struct FPlayFabPlayerEntity>           PartyMembers;                                      // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UReserveMordhauServerSessionSlots* ReserveMordhauServerSessionSlots(class UObject* WorldContextObject, const struct FServerSearchResult& SearchResult_0, const TArray<struct FPlayFabPlayerEntity>& PartyMembers_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReserveMordhauServerSessionSlots">();
	}
	static class UReserveMordhauServerSessionSlots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReserveMordhauServerSessionSlots>();
	}
};
static_assert(alignof(UReserveMordhauServerSessionSlots) == 0x000008, "Wrong alignment on UReserveMordhauServerSessionSlots");
static_assert(sizeof(UReserveMordhauServerSessionSlots) == 0x000190, "Wrong size on UReserveMordhauServerSessionSlots");
static_assert(offsetof(UReserveMordhauServerSessionSlots, onSuccess) == 0x000030, "Member 'UReserveMordhauServerSessionSlots::onSuccess' has a wrong offset!");
static_assert(offsetof(UReserveMordhauServerSessionSlots, OnFull) == 0x000040, "Member 'UReserveMordhauServerSessionSlots::OnFull' has a wrong offset!");
static_assert(offsetof(UReserveMordhauServerSessionSlots, onFailure) == 0x000050, "Member 'UReserveMordhauServerSessionSlots::onFailure' has a wrong offset!");
static_assert(offsetof(UReserveMordhauServerSessionSlots, World) == 0x000068, "Member 'UReserveMordhauServerSessionSlots::World' has a wrong offset!");
static_assert(offsetof(UReserveMordhauServerSessionSlots, SearchResult) == 0x000070, "Member 'UReserveMordhauServerSessionSlots::SearchResult' has a wrong offset!");
static_assert(offsetof(UReserveMordhauServerSessionSlots, PartyMembers) == 0x000180, "Member 'UReserveMordhauServerSessionSlots::PartyMembers' has a wrong offset!");

// Class Mordhau.GetMordhauServerSessionMods
// 0x0148 (0x0178 - 0x0030)
class UGetMordhauServerSessionMods final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(TArray<int32>& Mods)> onSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<int32>& Mods)> onFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FServerSearchResult                    SearchResult;                                      // 0x0050(0x0110)(NativeAccessSpecifierPrivate)
	class FString                                 ServerId;                                          // 0x0160(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGetMordhauServerSessionMods* GetMordhauServerSessionMods(const struct FServerSearchResult& SearchResult_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetMordhauServerSessionMods">();
	}
	static class UGetMordhauServerSessionMods* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetMordhauServerSessionMods>();
	}
};
static_assert(alignof(UGetMordhauServerSessionMods) == 0x000008, "Wrong alignment on UGetMordhauServerSessionMods");
static_assert(sizeof(UGetMordhauServerSessionMods) == 0x000178, "Wrong size on UGetMordhauServerSessionMods");
static_assert(offsetof(UGetMordhauServerSessionMods, onSuccess) == 0x000030, "Member 'UGetMordhauServerSessionMods::onSuccess' has a wrong offset!");
static_assert(offsetof(UGetMordhauServerSessionMods, onFailure) == 0x000040, "Member 'UGetMordhauServerSessionMods::onFailure' has a wrong offset!");
static_assert(offsetof(UGetMordhauServerSessionMods, SearchResult) == 0x000050, "Member 'UGetMordhauServerSessionMods::SearchResult' has a wrong offset!");
static_assert(offsetof(UGetMordhauServerSessionMods, ServerId) == 0x000160, "Member 'UGetMordhauServerSessionMods::ServerId' has a wrong offset!");

// Class Mordhau.MordhauShield
// 0x0010 (0x1CA0 - 0x1C90)
class AMordhauShield : public AMordhauWeapon
{
public:
	bool                                          bCanBlockMeleePassively;                           // 0x1C90(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C91[0x3];                                     // 0x1C91(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PassiveBlockDamageModifier;                        // 0x1C94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowShieldWall;                                  // 0x1C98(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C99[0x7];                                     // 0x1C99(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauShield">();
	}
	static class AMordhauShield* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauShield>();
	}
};
static_assert(alignof(AMordhauShield) == 0x000010, "Wrong alignment on AMordhauShield");
static_assert(sizeof(AMordhauShield) == 0x001CA0, "Wrong size on AMordhauShield");
static_assert(offsetof(AMordhauShield, bCanBlockMeleePassively) == 0x001C90, "Member 'AMordhauShield::bCanBlockMeleePassively' has a wrong offset!");
static_assert(offsetof(AMordhauShield, PassiveBlockDamageModifier) == 0x001C94, "Member 'AMordhauShield::PassiveBlockDamageModifier' has a wrong offset!");
static_assert(offsetof(AMordhauShield, bAllowShieldWall) == 0x001C98, "Member 'AMordhauShield::bAllowShieldWall' has a wrong offset!");

// Class Mordhau.MordhauSingleton
// 0x08E8 (0x0910 - 0x0028)
class UMordhauSingleton : public UObject
{
public:
	uint8                                         Pad_28[0x148];                                     // 0x0028(0x0148)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UObject*>                          AlwaysLoadedObjects;                               // 0x0170(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<TSoftClassPtr<class UClass>, class UClass*> CachedLoadedClassMap;                              // 0x01C0(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UObject>, class UObject*> CachedLoadedObjectMap;                             // 0x0210(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0xE8];                                     // 0x0260(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FSoftObjectPath>                  LoadQueue;                                         // 0x0348(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FSoftObjectPath>                  CurrentlyProcessingLoadQueue;                      // 0x03A0(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                CurrentlyProcessingLoadQueueArray;                 // 0x03F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          DefaultCharacterMesh;                              // 0x0400(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_408[0x50];                                     // 0x0408(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathPheromoneDecayTerm;                            // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathPheromoneMaxVisualizationAmount;               // 0x045C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBloodPools;                                     // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SingletonVersion;                                  // 0x0464(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UBotProfile>>        BotProfiles;                                       // 0x0468(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FString>                         RandomBotNames;                                    // 0x0478(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         DefaultHead;                                       // 0x0488(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_489[0x7];                                      // 0x0489(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           HeadWearables;                                     // 0x0490(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           OriginalHeadWearables;                             // 0x04A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         DefaultUpperChest;                                 // 0x04B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           UpperChestWearables;                               // 0x04B8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           OriginalUpperChestWearables;                       // 0x04C8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         DefaultLegs;                                       // 0x04D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           LegsWearables;                                     // 0x04E0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           OriginalLegsWearables;                             // 0x04F0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           Equipment;                                         // 0x0500(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           OriginalEquipment;                                 // 0x0510(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCharacterFace>>     MaleFaces;                                         // 0x0520(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCharacterFace>>     OriginalMaleFaces;                                 // 0x0530(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCharacterFace>>     FemaleFaces;                                       // 0x0540(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCharacterFace>>     OriginalFemaleFaces;                               // 0x0550(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           MaleVoices;                                        // 0x0560(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           OriginalMaleVoices;                                // 0x0570(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           FemaleVoices;                                      // 0x0580(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           OriginalFemaleVoices;                              // 0x0590(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UEmblem>>            Emblems;                                           // 0x05A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UEmblem>>            OriginalEmblems;                                   // 0x05B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UBadge>>             Badges;                                            // 0x05C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UBadge>>             OriginalBadges;                                    // 0x05D0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UPerk>>              Perks;                                             // 0x05E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UPerk>>              OriginalPerks;                                     // 0x05F0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UArchetype>>         Archetypes;                                        // 0x0600(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UArchetype>>         OriginalArchetypes;                                // 0x0610(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCharacterHair>>     Eyebrows;                                          // 0x0620(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCharacterHair>>     OriginalEyebrows;                                  // 0x0630(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FMordhauColorItemTable>         ColorTables;                                       // 0x0640(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMordhauColorItemTable>         OriginalColorTables;                               // 0x0650(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FMordhauColorItemTable                 SkinColorTable;                                    // 0x0660(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMordhauColorItemTable                 EyeColorTable;                                     // 0x0688(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMordhauColorItemTable                 HairColorTable;                                    // 0x06B0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMordhauColorItemTable                 EmblemColorTable;                                  // 0x06D8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMordhauColorItemTable                 MetalTintsColorTable;                              // 0x0700(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         SelectedBadge;                                     // 0x0728(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SelectedLevelDisplayType;                          // 0x0729(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72A[0x6];                                      // 0x072A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterProfile>              CharacterProfiles;                                 // 0x0730(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSet<TSoftClassPtr<class UClass>>             AllInventoryItems;                                 // 0x0740(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<TSoftClassPtr<class UClass>>             PreviousLaunchInventoryItems;                      // 0x0790(0x0050)(Edit, BlueprintVisible, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSet<TSoftClassPtr<class UClass>>             UnseenInventoryItems;                              // 0x07E0(0x0050)(Edit, BlueprintVisible, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FCharacterProfile>              DefaultProfiles;                                   // 0x0830(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEquipmentCustomization>        DefaultCharacterEquipment;                         // 0x0840(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FCharacterGearCustomization>    DefaultCharacterTier;                              // 0x0850(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FFaceCustomization                     DefaultCharacterFace;                              // 0x0860(0x0030)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	struct FAppearanceCustomization               DefaultCharacterAppearance;                        // 0x0890(0x0028)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	TArray<struct FCharacterProfile>              BotCharacterProfiles;                              // 0x08B8(0x0010)(BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FCharacterProfile>              DefaultBotCharacterProfiles;                       // 0x08C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AMordhauCharacter>          DefaultCharacter;                                  // 0x08D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoaded;                                         // 0x08E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E1[0x7];                                      // 0x08E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEquipmentRemapperSpawned;                        // 0x08E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AMordhauEquipmentRemapper*              EquipmentRemapper;                                 // 0x08F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UUserWidget>>        AlternativeHoveredWidgets;                         // 0x0900(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void ApplyProfileTo(const struct FCharacterProfile& Profile, class AMordhauCharacter* Char, uint8 Team, bool bAddEquipment);
	struct FLinearColor GetEmblemColor(uint8 ID);
	class UMordhauColor* GetEmblemColorObject(uint8 ID);
	TSubclassOf<class AMordhauEquipment> GetEquipment(int32 Index_0);
	const TArray<TSoftClassPtr<class UClass>> GetEquipmentArray();
	uint8 GetEquipmentID(TSubclassOf<class AMordhauEquipment> EquipmentType);
	struct FLinearColor GetEyeColor(uint8 ID);
	class UMordhauColor* GetEyeColorObject(uint8 ID);
	TSubclassOf<class UCharacterVoice> GetFemaleVoice(int32 Index_0);
	const TArray<TSoftClassPtr<class UClass>> GetFemaleVoices();
	struct FLinearColor GetHairColor(uint8 ID);
	class UMordhauColor* GetHairColorObject(uint8 ID);
	TSubclassOf<class UHeadWearable> GetHeadWearable(int32 Index_0);
	const TArray<TSoftClassPtr<class UClass>> GetHeadWearables();
	TSubclassOf<class ULegsWearable> GetLegsWearable(int32 Index_0);
	const TArray<TSoftClassPtr<class UClass>> GetLegsWearables();
	TSubclassOf<class UCharacterVoice> GetMaleVoice(int32 Index_0);
	const TArray<TSoftClassPtr<class UClass>> GetMaleVoices();
	struct FLinearColor GetMetalTintsColor(uint8 ID);
	class UMordhauColor* GetMetalTintsColorObject(uint8 ID);
	TArray<class FString> GetRandomBotNames();
	struct FLinearColor GetSkinColor(uint8 ID);
	class UMordhauColor* GetSkinColorObject(uint8 ID);
	struct FLinearColor GetTableColor(uint8 Table, uint8 ID);
	class UMordhauColor* GetTableColorObject(uint8 Table, uint8 ID);
	TSubclassOf<class UUpperChestWearable> GetUpperChestWearable(int32 Index_0);
	const TArray<TSoftClassPtr<class UClass>> GetUpperChestWearables();
	void LoadFromConfig();
	void LoadQueueFinishedLoadingChunk();
	void SaveToConfig();
	bool SetEquipmentArray(const TArray<TSoftClassPtr<class UClass>>& NewEquipment);
	bool SetFemaleVoices(const TArray<TSoftClassPtr<class UClass>>& NewVoices);
	bool SetHeadWearables(const TArray<TSoftClassPtr<class UClass>>& NewHeadWearables);
	bool SetLegsWearables(const TArray<TSoftClassPtr<class UClass>>& NewLegsWearables);
	bool SetMaleVoices(const TArray<TSoftClassPtr<class UClass>>& NewVoices);
	bool SetRandomBotNames(const TArray<class FString>& InRandomBotNames);
	bool SetUpperChestWearables(const TArray<TSoftClassPtr<class UClass>>& NewUpperChestWearables);
	class AMordhauEquipment* SpawnEquipment(class UWorld* WorldRef, const struct FEquipmentCustomization& Customization, uint8 Emblem, uint8 EmblemColor1, uint8 EmblemColor2, bool bForceInstantMeshUpdate, bool bForceMipStreaming);
	class AMordhauEquipment* SpawnEquipmentFromClass(class UWorld* WorldRef, TSoftClassPtr<class UClass> EquipmentClass);
	void UpdatePreviousLaunchInventory();

	int32 GetEquipmentNum() const;
	class AMordhauEquipmentRemapper* GetEquipmentRemapper() const;
	int32 GetFemaleVoicesNum() const;
	int32 GetHeadWearablesNum() const;
	bool GetIsLoadingAssets() const;
	int32 GetLegsWearablesNum() const;
	int32 GetMaleVoicesNum() const;
	int32 GetUpperChestWearablesNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauSingleton">();
	}
	static class UMordhauSingleton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauSingleton>();
	}
};
static_assert(alignof(UMordhauSingleton) == 0x000008, "Wrong alignment on UMordhauSingleton");
static_assert(sizeof(UMordhauSingleton) == 0x000910, "Wrong size on UMordhauSingleton");
static_assert(offsetof(UMordhauSingleton, AlwaysLoadedObjects) == 0x000170, "Member 'UMordhauSingleton::AlwaysLoadedObjects' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, CachedLoadedClassMap) == 0x0001C0, "Member 'UMordhauSingleton::CachedLoadedClassMap' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, CachedLoadedObjectMap) == 0x000210, "Member 'UMordhauSingleton::CachedLoadedObjectMap' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, LoadQueue) == 0x000348, "Member 'UMordhauSingleton::LoadQueue' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, CurrentlyProcessingLoadQueue) == 0x0003A0, "Member 'UMordhauSingleton::CurrentlyProcessingLoadQueue' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, CurrentlyProcessingLoadQueueArray) == 0x0003F0, "Member 'UMordhauSingleton::CurrentlyProcessingLoadQueueArray' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, DefaultCharacterMesh) == 0x000400, "Member 'UMordhauSingleton::DefaultCharacterMesh' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, PathPheromoneDecayTerm) == 0x000458, "Member 'UMordhauSingleton::PathPheromoneDecayTerm' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, PathPheromoneMaxVisualizationAmount) == 0x00045C, "Member 'UMordhauSingleton::PathPheromoneMaxVisualizationAmount' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, MaxBloodPools) == 0x000460, "Member 'UMordhauSingleton::MaxBloodPools' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, SingletonVersion) == 0x000464, "Member 'UMordhauSingleton::SingletonVersion' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, BotProfiles) == 0x000468, "Member 'UMordhauSingleton::BotProfiles' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, RandomBotNames) == 0x000478, "Member 'UMordhauSingleton::RandomBotNames' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, DefaultHead) == 0x000488, "Member 'UMordhauSingleton::DefaultHead' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, HeadWearables) == 0x000490, "Member 'UMordhauSingleton::HeadWearables' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalHeadWearables) == 0x0004A0, "Member 'UMordhauSingleton::OriginalHeadWearables' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, DefaultUpperChest) == 0x0004B0, "Member 'UMordhauSingleton::DefaultUpperChest' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, UpperChestWearables) == 0x0004B8, "Member 'UMordhauSingleton::UpperChestWearables' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalUpperChestWearables) == 0x0004C8, "Member 'UMordhauSingleton::OriginalUpperChestWearables' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, DefaultLegs) == 0x0004D8, "Member 'UMordhauSingleton::DefaultLegs' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, LegsWearables) == 0x0004E0, "Member 'UMordhauSingleton::LegsWearables' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalLegsWearables) == 0x0004F0, "Member 'UMordhauSingleton::OriginalLegsWearables' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, Equipment) == 0x000500, "Member 'UMordhauSingleton::Equipment' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalEquipment) == 0x000510, "Member 'UMordhauSingleton::OriginalEquipment' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, MaleFaces) == 0x000520, "Member 'UMordhauSingleton::MaleFaces' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalMaleFaces) == 0x000530, "Member 'UMordhauSingleton::OriginalMaleFaces' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, FemaleFaces) == 0x000540, "Member 'UMordhauSingleton::FemaleFaces' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalFemaleFaces) == 0x000550, "Member 'UMordhauSingleton::OriginalFemaleFaces' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, MaleVoices) == 0x000560, "Member 'UMordhauSingleton::MaleVoices' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalMaleVoices) == 0x000570, "Member 'UMordhauSingleton::OriginalMaleVoices' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, FemaleVoices) == 0x000580, "Member 'UMordhauSingleton::FemaleVoices' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalFemaleVoices) == 0x000590, "Member 'UMordhauSingleton::OriginalFemaleVoices' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, Emblems) == 0x0005A0, "Member 'UMordhauSingleton::Emblems' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalEmblems) == 0x0005B0, "Member 'UMordhauSingleton::OriginalEmblems' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, Badges) == 0x0005C0, "Member 'UMordhauSingleton::Badges' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalBadges) == 0x0005D0, "Member 'UMordhauSingleton::OriginalBadges' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, Perks) == 0x0005E0, "Member 'UMordhauSingleton::Perks' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalPerks) == 0x0005F0, "Member 'UMordhauSingleton::OriginalPerks' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, Archetypes) == 0x000600, "Member 'UMordhauSingleton::Archetypes' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalArchetypes) == 0x000610, "Member 'UMordhauSingleton::OriginalArchetypes' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, Eyebrows) == 0x000620, "Member 'UMordhauSingleton::Eyebrows' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalEyebrows) == 0x000630, "Member 'UMordhauSingleton::OriginalEyebrows' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, ColorTables) == 0x000640, "Member 'UMordhauSingleton::ColorTables' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OriginalColorTables) == 0x000650, "Member 'UMordhauSingleton::OriginalColorTables' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, SkinColorTable) == 0x000660, "Member 'UMordhauSingleton::SkinColorTable' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, EyeColorTable) == 0x000688, "Member 'UMordhauSingleton::EyeColorTable' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, HairColorTable) == 0x0006B0, "Member 'UMordhauSingleton::HairColorTable' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, EmblemColorTable) == 0x0006D8, "Member 'UMordhauSingleton::EmblemColorTable' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, MetalTintsColorTable) == 0x000700, "Member 'UMordhauSingleton::MetalTintsColorTable' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, SelectedBadge) == 0x000728, "Member 'UMordhauSingleton::SelectedBadge' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, SelectedLevelDisplayType) == 0x000729, "Member 'UMordhauSingleton::SelectedLevelDisplayType' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, CharacterProfiles) == 0x000730, "Member 'UMordhauSingleton::CharacterProfiles' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, AllInventoryItems) == 0x000740, "Member 'UMordhauSingleton::AllInventoryItems' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, PreviousLaunchInventoryItems) == 0x000790, "Member 'UMordhauSingleton::PreviousLaunchInventoryItems' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, UnseenInventoryItems) == 0x0007E0, "Member 'UMordhauSingleton::UnseenInventoryItems' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, DefaultProfiles) == 0x000830, "Member 'UMordhauSingleton::DefaultProfiles' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, DefaultCharacterEquipment) == 0x000840, "Member 'UMordhauSingleton::DefaultCharacterEquipment' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, DefaultCharacterTier) == 0x000850, "Member 'UMordhauSingleton::DefaultCharacterTier' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, DefaultCharacterFace) == 0x000860, "Member 'UMordhauSingleton::DefaultCharacterFace' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, DefaultCharacterAppearance) == 0x000890, "Member 'UMordhauSingleton::DefaultCharacterAppearance' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, BotCharacterProfiles) == 0x0008B8, "Member 'UMordhauSingleton::BotCharacterProfiles' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, DefaultBotCharacterProfiles) == 0x0008C8, "Member 'UMordhauSingleton::DefaultBotCharacterProfiles' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, DefaultCharacter) == 0x0008D8, "Member 'UMordhauSingleton::DefaultCharacter' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, bIsLoaded) == 0x0008E0, "Member 'UMordhauSingleton::bIsLoaded' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, OnEquipmentRemapperSpawned) == 0x0008E8, "Member 'UMordhauSingleton::OnEquipmentRemapperSpawned' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, EquipmentRemapper) == 0x0008F8, "Member 'UMordhauSingleton::EquipmentRemapper' has a wrong offset!");
static_assert(offsetof(UMordhauSingleton, AlternativeHoveredWidgets) == 0x000900, "Member 'UMordhauSingleton::AlternativeHoveredWidgets' has a wrong offset!");

// Class Mordhau.MordhauSpectator
// 0x0028 (0x02D0 - 0x02A8)
class AMordhauSpectator : public ASpectatorPawn
{
public:
	float                                         BlockInputAfterDeathTime;                          // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyAsksForSpawn;                        // 0x02AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanOnlyViewOwnTeam;                               // 0x02AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AE[0x2];                                      // 0x02AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CreatedTime;                                       // 0x02B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastSentCameraUpdate;                              // 0x02B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSmoothedTurnValue;                            // 0x02B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSmoothingTurnVelocity;                        // 0x02BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSmoothedLookUpValue;                          // 0x02C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSmoothingLookUpVelocity;                      // 0x02C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFirstTick;                                      // 0x02C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsWatchingOwnDeath();
	void PrimarySpectatorAction();
	void SecondarySpectatorAction();
	void SwitchToFreeCam();
	void TertiarySpectatorAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauSpectator">();
	}
	static class AMordhauSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauSpectator>();
	}
};
static_assert(alignof(AMordhauSpectator) == 0x000008, "Wrong alignment on AMordhauSpectator");
static_assert(sizeof(AMordhauSpectator) == 0x0002D0, "Wrong size on AMordhauSpectator");
static_assert(offsetof(AMordhauSpectator, BlockInputAfterDeathTime) == 0x0002A8, "Member 'AMordhauSpectator::BlockInputAfterDeathTime' has a wrong offset!");
static_assert(offsetof(AMordhauSpectator, bAutomaticallyAsksForSpawn) == 0x0002AC, "Member 'AMordhauSpectator::bAutomaticallyAsksForSpawn' has a wrong offset!");
static_assert(offsetof(AMordhauSpectator, bCanOnlyViewOwnTeam) == 0x0002AD, "Member 'AMordhauSpectator::bCanOnlyViewOwnTeam' has a wrong offset!");
static_assert(offsetof(AMordhauSpectator, CreatedTime) == 0x0002B0, "Member 'AMordhauSpectator::CreatedTime' has a wrong offset!");
static_assert(offsetof(AMordhauSpectator, LastSentCameraUpdate) == 0x0002B4, "Member 'AMordhauSpectator::LastSentCameraUpdate' has a wrong offset!");
static_assert(offsetof(AMordhauSpectator, MouseSmoothedTurnValue) == 0x0002B8, "Member 'AMordhauSpectator::MouseSmoothedTurnValue' has a wrong offset!");
static_assert(offsetof(AMordhauSpectator, MouseSmoothingTurnVelocity) == 0x0002BC, "Member 'AMordhauSpectator::MouseSmoothingTurnVelocity' has a wrong offset!");
static_assert(offsetof(AMordhauSpectator, MouseSmoothedLookUpValue) == 0x0002C0, "Member 'AMordhauSpectator::MouseSmoothedLookUpValue' has a wrong offset!");
static_assert(offsetof(AMordhauSpectator, MouseSmoothingLookUpVelocity) == 0x0002C4, "Member 'AMordhauSpectator::MouseSmoothingLookUpVelocity' has a wrong offset!");
static_assert(offsetof(AMordhauSpectator, bIsFirstTick) == 0x0002C8, "Member 'AMordhauSpectator::bIsFirstTick' has a wrong offset!");

// Class Mordhau.MordhauStats
// 0x0288 (0x02B0 - 0x0028)
class UMordhauStats final : public UObject
{
public:
	uint8                                         Pad_28[0x90];                                      // 0x0028(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStat                                  GameVersion;                                       // 0x00B8(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  Blocks;                                            // 0x00C4(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  Chambers;                                          // 0x00D0(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  ProjectilesDeflected;                              // 0x00DC(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  ProjectilesBlocked;                                // 0x00E8(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  Battlecries;                                       // 0x00F4(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  Disarms;                                           // 0x0100(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  Kills;                                             // 0x010C(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  Assists;                                           // 0x0118(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  KillsOneMatch;                                     // 0x0124(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  AssistsOneMatch;                                   // 0x0130(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  KillsOneLife;                                      // 0x013C(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  DamageTakenOneLife;                                // 0x0148(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  HeadsDecapitated;                                  // 0x0154(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  ProjectileHeadHits;                                // 0x0160(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  ProjectileTorsoHits;                               // 0x016C(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  ProjectileLegHits;                                 // 0x0178(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  MeleeHeadHits;                                     // 0x0184(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  MeleeTorsoHits;                                    // 0x0190(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  MeleeLegHits;                                      // 0x019C(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  KillsOneAttack;                                    // 0x01A8(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  FireKills;                                         // 0x01B4(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  CouchedHeadKills;                                  // 0x01C0(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  LadderKills;                                       // 0x01CC(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  TrampleKills;                                      // 0x01D8(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  CasualRank;                                        // 0x01E4(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  CasualRankSamples;                                 // 0x01F0(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  CasualRankTimestamp;                               // 0x01FC(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  DuelRank;                                          // 0x0208(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  DuelRankSamples;                                   // 0x0214(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  DuelRankTimestamp;                                 // 0x0220(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  DuelRankLeaderboard;                               // 0x022C(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  TeamfightRank;                                     // 0x0238(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  TeamfightRankSamples;                              // 0x0244(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  TeamfightRankTimestamp;                            // 0x0250(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FStat                                  TeamfightRankLeaderboard;                          // 0x025C(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAchievement                           TheABCs;                                           // 0x0268(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAchievement                           LivedToTell;                                       // 0x0270(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAchievement                           Highlander;                                        // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAchievement                           KeepsComingOff;                                    // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAchievement                           EagleEye;                                          // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAchievement                           Yoink;                                             // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAchievement                           JusticeFromGrave;                                  // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAchievement                           NotSparta;                                         // 0x02A0(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAchievement                           BurningMan;                                        // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	bool AreStatsAvailable(const class FString& PlayFabId);
	void GetPlayerValue(ECallResult* CallResult, const class FString& PlayFabId, const struct FStat& Stat, int32* Value);
	void GetValue(ECallResult* CallResult, const struct FStat& Stat, int32* Value);
	bool GetValueByName(const class FString& StatName, int32* OutValue);
	void IncrementValueChecked(class UWorld* World, const struct FStat& Stat);
	void IsAchievementUnlocked(ECallResult* CallResult, const struct FAchievement& Achievement, bool* bIsUnlocked);
	void LockAchievement(ECallResult* CallResult, const struct FAchievement& Achievement);
	void RequestPlayerStats(ECallResult* CallResult, const class FString& PlayFabId);
	void RequestStats(ECallResult* CallResult);
	void ResetAllStats(ECallResult* CallResult, bool bAchievementsToo);
	void SetAchievementProgress(ECallResult* CallResult, const struct FAchievement& Achievement, float Value);
	void SetPlayerValue(ECallResult* CallResult, const class FString& PlayFabId, const struct FStat& Stat, int32 Value);
	void SetValue(ECallResult* CallResult, const struct FStat& Stat, int32 Value);
	void StorePlayerStats(ECallResult* CallResult, const class FString& PlayFabId);
	void StoreStats(ECallResult* CallResult);
	void UnlockAchievement(ECallResult* CallResult, const struct FAchievement& Achievement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauStats">();
	}
	static class UMordhauStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauStats>();
	}
};
static_assert(alignof(UMordhauStats) == 0x000008, "Wrong alignment on UMordhauStats");
static_assert(sizeof(UMordhauStats) == 0x0002B0, "Wrong size on UMordhauStats");
static_assert(offsetof(UMordhauStats, GameVersion) == 0x0000B8, "Member 'UMordhauStats::GameVersion' has a wrong offset!");
static_assert(offsetof(UMordhauStats, Blocks) == 0x0000C4, "Member 'UMordhauStats::Blocks' has a wrong offset!");
static_assert(offsetof(UMordhauStats, Chambers) == 0x0000D0, "Member 'UMordhauStats::Chambers' has a wrong offset!");
static_assert(offsetof(UMordhauStats, ProjectilesDeflected) == 0x0000DC, "Member 'UMordhauStats::ProjectilesDeflected' has a wrong offset!");
static_assert(offsetof(UMordhauStats, ProjectilesBlocked) == 0x0000E8, "Member 'UMordhauStats::ProjectilesBlocked' has a wrong offset!");
static_assert(offsetof(UMordhauStats, Battlecries) == 0x0000F4, "Member 'UMordhauStats::Battlecries' has a wrong offset!");
static_assert(offsetof(UMordhauStats, Disarms) == 0x000100, "Member 'UMordhauStats::Disarms' has a wrong offset!");
static_assert(offsetof(UMordhauStats, Kills) == 0x00010C, "Member 'UMordhauStats::Kills' has a wrong offset!");
static_assert(offsetof(UMordhauStats, Assists) == 0x000118, "Member 'UMordhauStats::Assists' has a wrong offset!");
static_assert(offsetof(UMordhauStats, KillsOneMatch) == 0x000124, "Member 'UMordhauStats::KillsOneMatch' has a wrong offset!");
static_assert(offsetof(UMordhauStats, AssistsOneMatch) == 0x000130, "Member 'UMordhauStats::AssistsOneMatch' has a wrong offset!");
static_assert(offsetof(UMordhauStats, KillsOneLife) == 0x00013C, "Member 'UMordhauStats::KillsOneLife' has a wrong offset!");
static_assert(offsetof(UMordhauStats, DamageTakenOneLife) == 0x000148, "Member 'UMordhauStats::DamageTakenOneLife' has a wrong offset!");
static_assert(offsetof(UMordhauStats, HeadsDecapitated) == 0x000154, "Member 'UMordhauStats::HeadsDecapitated' has a wrong offset!");
static_assert(offsetof(UMordhauStats, ProjectileHeadHits) == 0x000160, "Member 'UMordhauStats::ProjectileHeadHits' has a wrong offset!");
static_assert(offsetof(UMordhauStats, ProjectileTorsoHits) == 0x00016C, "Member 'UMordhauStats::ProjectileTorsoHits' has a wrong offset!");
static_assert(offsetof(UMordhauStats, ProjectileLegHits) == 0x000178, "Member 'UMordhauStats::ProjectileLegHits' has a wrong offset!");
static_assert(offsetof(UMordhauStats, MeleeHeadHits) == 0x000184, "Member 'UMordhauStats::MeleeHeadHits' has a wrong offset!");
static_assert(offsetof(UMordhauStats, MeleeTorsoHits) == 0x000190, "Member 'UMordhauStats::MeleeTorsoHits' has a wrong offset!");
static_assert(offsetof(UMordhauStats, MeleeLegHits) == 0x00019C, "Member 'UMordhauStats::MeleeLegHits' has a wrong offset!");
static_assert(offsetof(UMordhauStats, KillsOneAttack) == 0x0001A8, "Member 'UMordhauStats::KillsOneAttack' has a wrong offset!");
static_assert(offsetof(UMordhauStats, FireKills) == 0x0001B4, "Member 'UMordhauStats::FireKills' has a wrong offset!");
static_assert(offsetof(UMordhauStats, CouchedHeadKills) == 0x0001C0, "Member 'UMordhauStats::CouchedHeadKills' has a wrong offset!");
static_assert(offsetof(UMordhauStats, LadderKills) == 0x0001CC, "Member 'UMordhauStats::LadderKills' has a wrong offset!");
static_assert(offsetof(UMordhauStats, TrampleKills) == 0x0001D8, "Member 'UMordhauStats::TrampleKills' has a wrong offset!");
static_assert(offsetof(UMordhauStats, CasualRank) == 0x0001E4, "Member 'UMordhauStats::CasualRank' has a wrong offset!");
static_assert(offsetof(UMordhauStats, CasualRankSamples) == 0x0001F0, "Member 'UMordhauStats::CasualRankSamples' has a wrong offset!");
static_assert(offsetof(UMordhauStats, CasualRankTimestamp) == 0x0001FC, "Member 'UMordhauStats::CasualRankTimestamp' has a wrong offset!");
static_assert(offsetof(UMordhauStats, DuelRank) == 0x000208, "Member 'UMordhauStats::DuelRank' has a wrong offset!");
static_assert(offsetof(UMordhauStats, DuelRankSamples) == 0x000214, "Member 'UMordhauStats::DuelRankSamples' has a wrong offset!");
static_assert(offsetof(UMordhauStats, DuelRankTimestamp) == 0x000220, "Member 'UMordhauStats::DuelRankTimestamp' has a wrong offset!");
static_assert(offsetof(UMordhauStats, DuelRankLeaderboard) == 0x00022C, "Member 'UMordhauStats::DuelRankLeaderboard' has a wrong offset!");
static_assert(offsetof(UMordhauStats, TeamfightRank) == 0x000238, "Member 'UMordhauStats::TeamfightRank' has a wrong offset!");
static_assert(offsetof(UMordhauStats, TeamfightRankSamples) == 0x000244, "Member 'UMordhauStats::TeamfightRankSamples' has a wrong offset!");
static_assert(offsetof(UMordhauStats, TeamfightRankTimestamp) == 0x000250, "Member 'UMordhauStats::TeamfightRankTimestamp' has a wrong offset!");
static_assert(offsetof(UMordhauStats, TeamfightRankLeaderboard) == 0x00025C, "Member 'UMordhauStats::TeamfightRankLeaderboard' has a wrong offset!");
static_assert(offsetof(UMordhauStats, TheABCs) == 0x000268, "Member 'UMordhauStats::TheABCs' has a wrong offset!");
static_assert(offsetof(UMordhauStats, LivedToTell) == 0x000270, "Member 'UMordhauStats::LivedToTell' has a wrong offset!");
static_assert(offsetof(UMordhauStats, Highlander) == 0x000278, "Member 'UMordhauStats::Highlander' has a wrong offset!");
static_assert(offsetof(UMordhauStats, KeepsComingOff) == 0x000280, "Member 'UMordhauStats::KeepsComingOff' has a wrong offset!");
static_assert(offsetof(UMordhauStats, EagleEye) == 0x000288, "Member 'UMordhauStats::EagleEye' has a wrong offset!");
static_assert(offsetof(UMordhauStats, Yoink) == 0x000290, "Member 'UMordhauStats::Yoink' has a wrong offset!");
static_assert(offsetof(UMordhauStats, JusticeFromGrave) == 0x000298, "Member 'UMordhauStats::JusticeFromGrave' has a wrong offset!");
static_assert(offsetof(UMordhauStats, NotSparta) == 0x0002A0, "Member 'UMordhauStats::NotSparta' has a wrong offset!");
static_assert(offsetof(UMordhauStats, BurningMan) == 0x0002A8, "Member 'UMordhauStats::BurningMan' has a wrong offset!");

// Class Mordhau.MordhauTitleScreen
// 0x0070 (0x02E8 - 0x0278)
class UMordhauTitleScreen : public UMordhauDialog
{
public:
	class UMordhauGameInstance*                   GameInstance;                                      // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   KeyToContinue;                                     // 0x0280(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   GamepadKeyToContinue;                              // 0x0298(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Info)> OnAgeRestrictionDialogConfirmed;                   // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Info)> OnLicenceDialogConfirmed;                          // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Info)> FOnLoginRequiredConfirmed;                         // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ConsumeKeyPressed(const struct FGeometry& InGeometry, const struct FKeyEvent& InKeyEvent);
	bool ConsumeMouseKeyEvent(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent);
	void ForceCloseTitleScreen();
	void OnShowAgeRestrictionDialog();
	void OnShowLicenseRequiredDialog();
	void OnShowLoginRequiredDialog();
	void OnUserConfirmedAgeRestricton(const class FString& Info);
	void OnUserConfirmedLicenceDialog(const class FString& Info);
	void OnUserConfirmedLogin();
	void OnUserConfirmedNotLoggedIn(const class FString& Info);
	void Setup(const struct FKey& InKeyToContinue, const struct FKey& InGamepadKeyToContinue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauTitleScreen">();
	}
	static class UMordhauTitleScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauTitleScreen>();
	}
};
static_assert(alignof(UMordhauTitleScreen) == 0x000008, "Wrong alignment on UMordhauTitleScreen");
static_assert(sizeof(UMordhauTitleScreen) == 0x0002E8, "Wrong size on UMordhauTitleScreen");
static_assert(offsetof(UMordhauTitleScreen, GameInstance) == 0x000278, "Member 'UMordhauTitleScreen::GameInstance' has a wrong offset!");
static_assert(offsetof(UMordhauTitleScreen, KeyToContinue) == 0x000280, "Member 'UMordhauTitleScreen::KeyToContinue' has a wrong offset!");
static_assert(offsetof(UMordhauTitleScreen, GamepadKeyToContinue) == 0x000298, "Member 'UMordhauTitleScreen::GamepadKeyToContinue' has a wrong offset!");
static_assert(offsetof(UMordhauTitleScreen, OnAgeRestrictionDialogConfirmed) == 0x0002B0, "Member 'UMordhauTitleScreen::OnAgeRestrictionDialogConfirmed' has a wrong offset!");
static_assert(offsetof(UMordhauTitleScreen, OnLicenceDialogConfirmed) == 0x0002C0, "Member 'UMordhauTitleScreen::OnLicenceDialogConfirmed' has a wrong offset!");
static_assert(offsetof(UMordhauTitleScreen, FOnLoginRequiredConfirmed) == 0x0002D0, "Member 'UMordhauTitleScreen::FOnLoginRequiredConfirmed' has a wrong offset!");

// Class Mordhau.MordhauTypes
// 0x0000 (0x0028 - 0x0028)
class UMordhauTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauTypes">();
	}
	static class UMordhauTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauTypes>();
	}
};
static_assert(alignof(UMordhauTypes) == 0x000008, "Wrong alignment on UMordhauTypes");
static_assert(sizeof(UMordhauTypes) == 0x000028, "Wrong size on UMordhauTypes");

// Class Mordhau.MordhauUserWidget
// 0x0008 (0x0268 - 0x0260)
class UMordhauUserWidget : public UUserWidget
{
public:
	class UMordhauWidgetComponent*                ParentWidgetComponent;                             // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauUserWidget">();
	}
	static class UMordhauUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauUserWidget>();
	}
};
static_assert(alignof(UMordhauUserWidget) == 0x000008, "Wrong alignment on UMordhauUserWidget");
static_assert(sizeof(UMordhauUserWidget) == 0x000268, "Wrong size on UMordhauUserWidget");
static_assert(offsetof(UMordhauUserWidget, ParentWidgetComponent) == 0x000260, "Member 'UMordhauUserWidget::ParentWidgetComponent' has a wrong offset!");

// Class Mordhau.MordhauUtilityLibrary
// 0x0000 (0x0028 - 0x0028)
class UMordhauUtilityLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float ActorGetDistanceToCollision(class AActor* Actor, const struct FVector& Point, struct FVector* PointOnCollision, ECollisionChannel TraceChannel);
	static float AngularDistance(const struct FRotator& A, const struct FRotator& B);
	static bool AreActorsFromSameLevel(class AActor* ActorA, class AActor* ActorB);
	static bool AreConfirmCancelSwapped();
	static bool AreProfilesEqual(const struct FCharacterProfile& First, const struct FCharacterProfile& Second);
	static void AwardDuelMMR(const class FString& WinnerID, const class FString& LoserID, int32* NewWinnerMMR, int32* NewLoserMMR);
	static void AwardTeamfightMMR(const bool& bIsWin, const class FString& PlayFabId, const int32& OtherTeamMMR, int32* NewMMR);
	static void BreakFaceCustomization(const struct FFaceCustomization& FaceCustomization, TArray<int32>* OutTranslate, TArray<int32>* OutRotate, TArray<int32>* OutScale);
	static void BreakSkillsCustomization(const struct FSkillsCustomization& SkillsCustomization, int32* OutPerks);
	static float CalculateAngle2D(const struct FVector& Direction, float Yaw);
	static int32 CalculateGCD(int32 ValueA, int32 ValueB);
	static bool CallFunctionByNameWithArgs(const class FString& Str, class UObject* Executor);
	static bool CanCrossplayWith(EPlatform OtherPlatform);
	static class FString Capitalize(const class FString& String);
	static struct FVector ClosestPointOnLine(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FVector& Point);
	static bool CompareAppearanceCustomization(const struct FAppearanceCustomization& First, const struct FAppearanceCustomization& Second);
	static bool CompareEquipmentCustomization(const struct FEquipmentCustomization& First, const struct FEquipmentCustomization& Second);
	static bool CompareFaceCustomization(const struct FFaceCustomization& First, const struct FFaceCustomization& Second);
	static bool CompareGearCustomization(const struct FCharacterGearCustomization& First, const struct FCharacterGearCustomization& Second);
	static bool CompressData(const TArray<uint8>& InData, class FString* OutData);
	static int32 ComputePointsLeft(const struct FCharacterProfile& Profile);
	static bool ConsumeBudget(class AAdvancedCharacter* Character, EBudgetType BudgetType, bool bSkipInvisible, float Duration, float DistanceCutoff, bool bForce);
	static class FString Conv_SoftObjectPathToString(const struct FSoftObjectPath& SoftObjectPath);
	static bool ConvertColorArrayToImage(int32 InSizeX, int32 InSizeY, const TArray<struct FColor>& InImageData, TArray<uint8>* CompressedData, int32 ImageQuality, const class FString& ImageFormat);
	static class FString ConvertRelativePathToFull(const class FString& Path);
	static void ConvertStringSteamIDsToPlayFabIDs(const TArray<class FString>& InSteamIDArray, const class FString& Filename, TDelegate<void(bool bSuccess, struct FSteamPlayFabConversionResult& OutMap)> Delegate);
	static void ConvertTextureToColorArray(class UTexture2DDynamic* DynTex, const TDelegate<void(TArray<struct FColor>& ColorData)>& OnTextureConvertedToColorArrayDelegate);
	static void CopyToClipboard(const class FString& MessageToCopy);
	static bool DecodeBase64ToByteArray(const class FString& Source, TArray<uint8>* Dest);
	static bool DecodeBase64ToString(const class FString& Source, class FString* OutDest);
	static bool DoesProfileContainBannedEquipment(const struct FCharacterProfile& Profile, class AGameStateBase* GameState);
	static bool DoesProfileContainBannedPerks(const struct FCharacterProfile& Profile, class AGameStateBase* GameState);
	static void DrawText(class UCanvas* Canvas, const class UFont* Font, int32 Size, const class FString& Text, const struct FVector2D& position, const struct FLinearColor& TextColor, float Kerning, const struct FLinearColor& ShadowColor, const struct FVector2D& ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, const struct FLinearColor& OutlineColor);
	static class FString EncodeByteArrayToBase64String(const TArray<uint8>& Array);
	static class FString EncodeStringToBase64String(const class FString& String);
	static bool Equal_PlayFabPlayer(const struct FPlayFabPlayer& A, const struct FPlayFabPlayer& B);
	static void FakeTickComponent(class USceneComponent* Component, float DeltaTime);
	static TArray<class UObject*> FilterArrayByFunction(const TArray<class UObject*>& Array, const TDelegate<void(class UObject* Obj, bool* RetVal)>& FuncDel, const TSubclassOf<class UObject> Class_0);
	static struct FRotator FindBetween(const struct FVector& A, const struct FVector& B);
	static class UObject* FindByFunction(const TArray<class UObject*>& Array, const TDelegate<void(class UObject* Obj, bool* RetVal)>& FuncDel);
	static class UObject* FindByFunctionTyped(const TArray<class UObject*>& Array, const TDelegate<void(class UObject* Obj, bool* RetVal)>& FuncDel, const TSubclassOf<class UObject> Class_0);
	static bool FindCircleIntersectionPoints(const struct FVector2D& CenterA, const float& RadiusA, const struct FVector2D& CenterB, const float& RadiusB, struct FVector2D* PointA, struct FVector2D* PointB);
	static class UClass* FindClass(const class FString& ClassName);
	static class AMordhauPlayerState* FindPlayerState(const class FString& PlayerNameOrPlayFabID);
	static class AMordhauPlayerState* FindPlayerStateWithoutLocalID(const class FString& PlayerNameOrPlayFabID);
	static const struct FPlayFabPlayer FindPlayFabPlayer(const class FString& PlayerNameOrPlayFabID);
	static bool FindTeleportSpot(class AActor* Actor, const struct FVector& InLocation, const struct FRotator& InRotation, struct FVector* OutLocation);
	static float FInterpConstantToSeparate(float Current, float Target, float DeltaTime, float IncreaseSpeed, float DecreaseSpeed);
	static float FInterpToSeparate(float Current, float Target, float DeltaTime, float IncreaseSpeed, float DecreaseSpeed);
	static void FlashWindow();
	static void FlushPlayerControllerPressedKeys(class APlayerController* Controller);
	static void ForceReplicationUpdate(class UCharacterMovementComponent* CMC);
	static void ForceSRGB(class UTextureRenderTarget2D* rt);
	static bool ForceValidCharacterProfile(const struct FCharacterProfile& Profile, struct FCharacterProfile* ForceValidatedProfile, bool bValidateInventory);
	static class FText FormatText(const class FText& Text);
	static void FSmoothDamp(float* Current, float Target, float* CurrentVelocity, float SmoothTime, float DeltaTime, float MaxSpeed);
	static class FString GetActorLevelName(class AActor* Actor);
	static void GetAllActorsInLevelOfClass(class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const class FString& LevelName, TArray<class AActor*>* OutActors);
	static TArray<class FString> GetAllPaksPathsInCustomPaksFolder();
	static TArray<TSubclassOf<class UMordhauWearable>> GetAllWearableClassesForSlotExhaustive(EWearableSlot Slot);
	static class UArchetype* GetArchetypeObject(const struct FCharacterProfile& Profile);
	static class AActor* GetAttachParentActor(class AActor* Actor);
	static struct FVector GetAxisAngleFromRotator(const struct FRotator& Rot, float* OutAngle);
	static TArray<class FText> GetBannedEquipmentArray(const struct FCharacterProfile& Profile, class AGameStateBase* GameState);
	static class FString GetBannedEquipmentNames(const struct FCharacterProfile& Profile, class AGameStateBase* GameState);
	static class FString GetBannedPerkNames(const struct FCharacterProfile& Profile, class AGameStateBase* GameState);
	static TArray<class UPerk*> GetBannedPerksArray(const struct FCharacterProfile& Profile, class AGameStateBase* GameState);
	static class FString GetBaseFilename(const class FString& InPath, bool bRemovePath);
	static class FString GetBeaconPortName();
	static struct FBox GetBoundingBoxOfBoneInfluence(class USkeletalMeshComponent* MeshComponent, const TArray<class FName>& Bones, float WeightThreshold);
	static struct FVector GetBoxCenter(const struct FBox& Box);
	static class FString GetBuildDateTime();
	static int32 GetBuildVersion();
	static bool GetCanEverAffectNavigation(class USceneComponent* SceneComp);
	static int32 GetCategoryMaxNameLenght();
	static struct FVector GetCentroid(const TArray<struct FVector>& Points);
	static class UClass* GetClassByPath(const class FString& ClassPath);
	static struct FVector GetComponentsBoundingBoxInActorSpace(class AActor* Actor);
	static int32 GetConsoleMaxLoadouts();
	static float GetConsoleVariableFloat(const class FString& VariableName);
	static int32 GetConsoleVariableInt(const class FString& VariableName);
	static class FString GetConsoleVariableString(const class FString& VariableName);
	static float GetCurrentDemoTime(class UWorld* World);
	static int32 GetCurrentFrame(class UWorld* World);
	static int32 GetCurrentFrameBP(class UObject* WorldContextObject);
	static class FString GetCurrentPlatformName();
	static TArray<class FString> GetCustomConfigVar_Array(const class FString& SectionName, const class FString& VariableName, int32* ArraySize);
	static bool GetCustomConfigVar_Bool(const class FString& SectionName, const class FString& VariableName, bool* IsValid);
	static struct FLinearColor GetCustomConfigVar_Color(const class FString& SectionName, const class FString& VariableName, bool* IsValid);
	static float GetCustomConfigVar_Float(const class FString& SectionName, const class FString& VariableName, bool* IsValid);
	static int32 GetCustomConfigVar_Int(const class FString& SectionName, const class FString& VariableName, bool* IsValid);
	static struct FRotator GetCustomConfigVar_Rotator(const class FString& SectionName, const class FString& VariableName, bool* IsValid);
	static class FString GetCustomConfigVar_String(const class FString& SectionName, const class FString& VariableName, bool* IsValid);
	static struct FVector GetCustomConfigVar_Vector(const class FString& SectionName, const class FString& VariableName, bool* IsValid);
	static struct FVector2D GetCustomConfigVar_Vector2D(const class FString& SectionName, const class FString& VariableName, bool* IsValid);
	static struct FDateTime GetDateTimeFromUnixTimestamp(int32 Timestamp);
	static class AActor* GetDefaultActor(class UClass* FromClass);
	static void GetDefaultActorCopy(class UClass* FromClass, class AActor** ActorCopy);
	static class UBadge* GetDefaultBadge(TSubclassOf<class UBadge> BadgeClass);
	static class UObject* GetDefaultObject(class UClass* FromClass);
	static void GetDefaultObjectCopy(class UClass* FromClass, class UObject** ObjectCopy, class UObject* Outer_0);
	static class UMordhauWearable* GetDefaultWearable(class UClass* FromClass);
	static class FText GetDurationText(int32 Seconds);
	static class FString GetEnumKey(const class FString& EnumName, const int32 EnumValue);
	static int32 GetEnumValue(const class FString& EnumName, const class FString& EnumKey);
	static class FText getErrorText(const class FString& ErrorString);
	static int32 GetFaceIndex(const struct FHitResult& Hit);
	static class FString GetGamePortName();
	static int32 GetGameServerGamePort();
	static struct FBoxSphereBounds GetImportedBounds(class USkeletalMeshComponent* SkeletalMeshComponent);
	static EIngameEvent GetIngameEvent(const class UObject* WorldContextObject);
	static bool GetIsPeasant(const struct FCharacterProfile& Profile);
	static bool GetIsUsingController();
	static float GetLastReceiveTime(const class UObject* WorldContextObject);
	static uint32 GetLocalNetworkVersion();
	static int32 GetLocalShortID(const class AMordhauPlayerState* PlayerState);
	static EServerLocation GetLocation(const class FString& LocationName);
	static class FText GetLocationDisplayName(EServerLocation Location);
	static class FString GetLocationName(EServerLocation Location);
	static class UPrimitiveComponent* GetLODParentPrimitive(class UPrimitiveComponent* Comp);
	static struct FMapInfo GetMapInfo(const class UObject* WorldContextObject, const class FString& MapPath);
	static class FString GetMapName(const class UObject* WorldContextObject);
	static int32 GetMaxIndexWithDraw(const TArray<int32>& inArray, bool* bFoundDraw);
	static class AMordhauGameSession* GetMordhauGameSession(const class UObject* WorldContextObject);
	static class UMordhauGameUserSettings* GetMordhauGameUserSettings();
	static class AMordhauHUD* GetMordhauHUD(class UObject* WorldContextObject);
	static class UMordhauInput* GetMordhauInput();
	static class UMordhauInventory* GetMordhauInventory();
	static class UMordhauSingleton* GetMordhauSingleton();
	static class UMordhauStats* GetMordhauStats();
	static struct FVector2D GetMousePosition(class APlayerController* Controller);
	static float GetNormalizedTime(float Start, float End, float Current);
	static bool GetNotifyServerReceivedClientData(class UCharacterMovementComponent* CMC);
	static class FString GetOnlineEnvironmentName();
	static class FText GetOnlineServiceName();
	static class FString GetOSVersion();
	static int32 GetPacketsLost(const class UObject* WorldContextObject);
	static int32 GetPerforceRevision();
	static int32 GetPerforceRevisionEnforced();
	static TArray<class UPerk*> GetPerks(const struct FCharacterProfile& Profile);
	static int32 GetPerksCost(const struct FCharacterProfile& Profile);
	static struct FBox GetPhysicsBodyBounds(class USkeletalMeshComponent* MeshComponent, class FName BoneName);
	static struct FTransform GetPhysicsBodyWorldTransform(class USkeletalMeshComponent* MeshComponent, class FName BoneName);
	static float GetPing(const class UObject* WorldContextObject, bool bUseMedian);
	static EPlatform GetPlatform();
	static EPlatform GetPlatformByName(const class FString& PlatformName);
	static class FString GetPlatformName(EPlatform Platform);
	static EPlatformSpecific GetPlatformSpecific();
	static class UTexture2DDynamic* GetPlayerAvatar(const struct FPlayFabPlayer& Player);
	static void GetPlayerByShortId(const TArray<class FString>& ShortId, const EPlatform PlatformFilter, const TDelegate<void(bool bWasSuccessful, struct FPlayFabApiError& Error, struct FGetPlayerByShortIdResult& ShortIdResults)>& Delegate);
	static TArray<int32> GetPlayerCountFromGameModeMetadataClass(TSubclassOf<class UGameModeMetadata> MetadataClass);
	static int32 GetPlayerMaxNameLenght();
	static class UPlayFabAPI* GetPlayFabAPI();
	static class FString GetPlayFabEntityID();
	static class FString GetPlayFabId();
	static struct FPlayFabPlayer GetPlayFabPlayer();
	static struct FDateTime GetPlayFabTimestamp();
	static class UArmsWearable* GetRandomArmsWearable(int32* ID, class UUpperChestWearable* UpperChestWearable, const struct FSkillsCustomization& SkillsCustomization, EItemRarity MaxRarity);
	static class UMordhauWearable* GetRandomCoifWearable(int32* ID, class UHeadWearable* HeadWearable, const struct FSkillsCustomization& SkillsCustomization, EItemRarity MaxRarity);
	static class AMordhauEquipment* GetRandomEquipment(int32* ID, const struct FSkillsCustomization& SkillsCustomization, EItemRarity MaxRarity);
	static struct FVector GetRandomFaceCustomizationVector(float RandomExponent, const float Limit);
	static class UMordhauWearable* GetRandomFeetWearable(int32* ID, class ULegsWearable* LegsWearable, const struct FSkillsCustomization& SkillsCustomization, EItemRarity MaxRarity);
	static class UMordhauWearable* GetRandomHandsWearable(int32* ID, class UArmsWearable* ArmsWearable, const struct FSkillsCustomization& SkillsCustomization, EItemRarity MaxRarity);
	static class UHeadWearable* GetRandomHeadWearable(int32* ID, const struct FSkillsCustomization& SkillsCustomization, EItemRarity MaxRarity);
	static class ULegsWearable* GetRandomLegsWearable(int32* ID, const struct FSkillsCustomization& SkillsCustomization, EItemRarity MaxRarity);
	static class UMordhauWearable* GetRandomLowerChestWearable(int32* ID, class UUpperChestWearable* UpperChestWearable, const struct FSkillsCustomization& SkillsCustomization, EItemRarity MaxRarity);
	static class AMordhauEquipment* GetRandomMeleeWeapon(int32* ID, const struct FSkillsCustomization& SkillsCustomization, EItemRarity MaxRarity);
	static class AMordhauEquipment* GetRandomRangedWeapon(int32* ID, const struct FSkillsCustomization& SkillsCustomization, EItemRarity MaxRarity);
	static class UMordhauWearable* GetRandomShouldersWearable(int32* ID, class UUpperChestWearable* UpperChestWearable, const struct FSkillsCustomization& SkillsCustomization, EItemRarity MaxRarity);
	static void GetRandomSkin(int32* ID, struct FEquipmentSkinEntry* Skin, class AMordhauEquipment* Equipment, EItemRarity MaxRarity);
	static class UUpperChestWearable* GetRandomUpperChestWearable(int32* ID, const struct FSkillsCustomization& SkillsCustomization, EItemRarity MaxRarity);
	static class AMordhauEquipment* GetRandomWeapon(int32* ID, const struct FSkillsCustomization& SkillsCustomization, EItemRarity MaxRarity);
	static int32 GetRankFromXP(int32 XP);
	static EServerRegion GetRegion(const class FString& RegionName);
	static class FText GetRegionDisplayName(EServerRegion Region);
	static class FString GetRegionName(EServerRegion Region);
	static int32 GetReleaseVersion();
	static ENetRole GetRole(class AActor* Actor);
	static class FName GetSculptableBoneAtLine(const struct FVector& LineStart, const struct FVector& LineEnd, float SearchRadius, class USkeletalMeshComponent* MeshComponent, class AMordhauCharacter* Character, int32 Level);
	static class FString GetServerConnectString(const struct FPlayFabServerDetails& ServerDetails, const class FString& PortName);
	static void GetSoundMixInfo(const class FString& Name_0, struct FSoundMixInfo* SoundMixInfo);
	static bool GetSupportedScreenResolutions(TArray<class FString>* Resolutions);
	static float GetSyncGroupPositionBetweenMarkers(class UAnimInstance* AnimInstance, class FName SyncGroup);
	static bool GetTexture2DDynamicDimensions(class UTexture2DDynamic* DynTex, int32* Height, int32* Width);
	static float GetTotalDemoTime(class UWorld* World);
	static class FString GetVersionName();
	static class FString GetVersionString();
	static class AMordhauCharacter* GetViewTargetCharacter(class UObject* WorldContextObject, bool bOnlyLiving);
	static int32 GetVisibilityId(class UPrimitiveComponent* Comp);
	static TSubclassOf<class UMordhauWearable> GetWearableClass(const struct FCharacterGearCustomization& CharacterGearCustomization, EWearableSlot Slot);
	static TArray<TSubclassOf<class UMordhauWearable>> GetWearableClasses(const struct FCharacterGearCustomization& CharacterGearCustomization, EWearableSlot Slot);
	static TArray<class FText> GetWearableNames(const struct FCharacterGearCustomization& CharacterGearCustomization, EWearableSlot Slot);
	static EWearableSlot GetWearableSlot(TSubclassOf<class UMordhauWearable> Wearable);
	static class UWorld* GetWorldOf(class UObject* Object);
	static int32 GetXPFromRank(int32 Rank);
	static struct FBox GrowBoxToIncludePoint(const struct FBox& Box, const struct FVector& Vector);
	static bool HasActorBegunPlay(class AActor* Actor);
	static bool HasBeenReallyRecentlyRendered(class UMeshComponent* MeshComponent);
	static bool HasPath(class AAIController* Controller);
	static bool IsClient();
	static bool IsCommunityServer();
	static bool IsConsolePlatform();
	static bool IsDedicatedServer();
	static bool IsDemoPlayback(class UWorld* World);
	static bool IsDevelopmentBranch();
	static bool IsDevelopmentBuild();
	static bool IsDevelopmentEnvironment();
	static bool IsDLCInstalled(const EDownloadableContent DLC);
	static bool IsEditor();
	static const bool IsFriend(class AMordhauPlayerState* Player);
	static bool IsFriendlyToLocalPlayer(class UWorld* WorldReference, class AActor* OtherActor);
	static bool IsListenServer();
	static bool IsNonShippingBuildConfig();
	static bool IsOfficialServer();
	static bool IsOnlinePurchaseQueryEnabled();
	static const bool IsPartyMember(class AMordhauPlayerState* Player);
	static bool IsPIE();
	static bool IsPlayInEditor();
	static bool IsPrivateIPAddress(const class FString& IPAddress);
	static bool IsPublicIPAddress(const class FString& IPAddress);
	static bool IsReflexAvailable();
	static bool IsServer();
	static bool IsStandalone();
	static bool IsValid_PlayFabPlayer(const struct FPlayFabPlayer& Player);
	static bool IsValidIPAddress(const class FString& IPAddress);
	static struct FPOV LerpPOV(const struct FPOV& A, const struct FPOV& B, float Alpha);
	static bool LineTraceMultiForObjectsReturnFace(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf);
	static bool LoadArrayFromFile(const class FString& Filename, TArray<uint8>* LoadedArray, const class FString& FileExtension);
	static class UObject* LoadAsset(const struct FSoftObjectPath& SoftObjectPath);
	static bool LoadReportImageByteArray(const class FString& ImageName, TArray<uint8>* LoadedArray);
	static bool LoadStringArrayFromFile(const class FString& Filename, TArray<class FString>* LoadedStringArray, const class FString& FileExtension);
	static bool LoadStringFromFile(const class FString& Filename, class FString* LoadedString, const class FString& FileExtension);
	static struct FCharacterProfile MakeEmptyProfile(TSubclassOf<class AMordhauCharacter> CharacterClass, bool bRandomizeVoice);
	static void MakeFaceCustomization(const TArray<int32>& Translate, const TArray<int32>& Rotate, const TArray<int32>& Scale, struct FFaceCustomization* FaceCustomization);
	static void MakeSkillsCustomization(int32 Perks, struct FSkillsCustomization* OutSkillsCustomization);
	static void MarkRenderStateDirty(class UMeshComponent* MeshComp);
	static bool MordhauApplyRadialDamageWithFalloff(const class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, float BaseStructureDamage, float MinimumStructureDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, const TArray<class AActor*>& IgnoreActors, float BaseKnockback, float MinimumKnockback, float RagdollFallRadius, class AActor* DamageCauser, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel, bool bIgnoreFriendly, EMordhauDamageType DamageType);
	static bool MountPak(const class FString& PakPath, class UObject* WorldContextObject);
	static bool NotEqual_PlayFabPlayer(const struct FPlayFabPlayer& A, const struct FPlayFabPlayer& B);
	static void OpenDiscordInvite();
	static void OpenDLCStorePage(const class FString& DlcId);
	static void OpenKeyBindings();
	static void OpenPlayerProfile(const struct FPlayFabPlayer& Player);
	static void OpenRentServer();
	static void OpenSocial(const class FString& URL);
	static void OpenURL(const class FString& URL);
	static void PerformCharacterRenderingStressTest(const class UObject* WorldContextObject, TSubclassOf<class AMordhauCharacter> Type, int32 Amount, float Spread, float DistanceFromCamera);
	static bool PlaneTrace(class UObject* WorldContextObject, const struct FVector& Left, const struct FVector& Right, const struct FVector& Forward, const struct FVector& Back, const struct FVector& TraceAmount, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bConnectLeftRight, bool bConnectForwardBack, const struct FVector& ConnectOffset, struct FHitResult* LeftHit, struct FHitResult* RightHit, struct FHitResult* ForwardHit, struct FHitResult* BackHit, struct FVector* OutRight, struct FVector* OutForward, bool bIgnoreSelf);
	static void PrintToConsoleAndLog(const class FString& String, bool bSkipRepeatedStrings);
	static bool ProjectWorldToScreenBidirectional(class APlayerController* Player, const struct FVector& WorldPosition, struct FVector2D* ScreenPosition, bool* bTargetBehindCamera, bool bPlayerViewportRelative);
	static int32 RandomRangeExclude(int32 Min, int32 Max, int32 Exclude);
	static void ReserveCharacterRagdoll(class AAdvancedCharacter* Character);
	static void ResetClientPredictionData(class UCharacterMovementComponent* CMC);
	static void ResetController(class AController* Controller);
	static void ResetServerPredictionData(class UCharacterMovementComponent* CMC);
	static class FString SanitizePlayerName(const class FString& InName, const class FString& InFallback);
	static bool SaveArrayToFile(const class FString& Filename, const TArray<uint8>& ByteArray, const class FString& FileExtension);
	static bool SaveStringArrayToFile(const class FString& Filename, const TArray<class FString>& StringArray, const class FString& FileExtension);
	static bool SaveStringToFile(const class FString& Filename, const class FString& String, const class FString& FileExtension);
	static int32 SCompare(const class FString& StringA, const class FString& StringB);
	static void SearchUsername(const class FString& Usernames, const TDelegate<void(bool bWasSuccessful, struct FPlayFabApiError& Error, struct FUsernameSearchResult& SearchResults)>& Delegate, EUsernameSearchFilter SearchFilter, int32 Limit, int32 Offset, EPlatform PlatformFilter);
	static void SendClientAdjustment(class UCharacterMovementComponent* CMC);
	static bool SendMessageToRconClients(const class FString& Message, const int32& ClientId, bool bToAll, EBroadcastTypes TypeOfBroadcast);
	static void SetCachedMaxDistanceAndMarkDirty(class UPrimitiveComponent* Comp, float NewMaxDistance);
	static void SetCanEverAffectNavigation(class UActorComponent* ActorComponent, bool bRelevant);
	static void SetCustomConfigVar_Array(const class FString& SectionName, const class FString& VariableName, const TArray<class FString>& Value);
	static void SetCustomConfigVar_Bool(const class FString& SectionName, const class FString& VariableName, bool Value);
	static void SetCustomConfigVar_Color(const class FString& SectionName, const class FString& VariableName, const struct FLinearColor& Value);
	static void SetCustomConfigVar_Float(const class FString& SectionName, const class FString& VariableName, float Value);
	static void SetCustomConfigVar_Int(const class FString& SectionName, const class FString& VariableName, int32 Value);
	static void SetCustomConfigVar_Rotator(const class FString& SectionName, const class FString& VariableName, const struct FRotator& Value);
	static void SetCustomConfigVar_String(const class FString& SectionName, const class FString& VariableName, const class FString& Value);
	static void SetCustomConfigVar_Vector(const class FString& SectionName, const class FString& VariableName, const struct FVector& Value);
	static void SetCustomConfigVar_Vector2D(const class FString& SectionName, const class FString& VariableName, const struct FVector2D& Value);
	static void SetDecalFadeScreenSize(class UDecalComponent* Decal, float NewFadeScreenSize);
	static void SetForceMipStreaming(class USkeletalMeshComponent* SMC, bool bValue);
	static void SetLocalSpaceKinematics(class USkeletalMeshComponent* Mesh, bool bNewValue);
	static void SetLODActorDrawDistance(class ALODActor* Actor, float NewDrawDistance);
	static void SetMousePosition(class APlayerController* Controller, float LocationX, float LocationY);
	static void SetNavAreaClass(class UShapeComponent* ShapeComponent, TSubclassOf<class UNavArea> AreaClass);
	static void SetNeverDistanceCull(class UPrimitiveComponent* Comp, bool bNewValue);
	static void SetPawnFromRep(class AController* Contr, class APawn* NewPawn);
	static void SetPerBoneMotionBlur(class USkeletalMeshComponent* Component, bool bNewValue);
	static void SetRealMultiplayerStatus(bool bEnable, bool bCrossplay, bool bSpectate);
	static void SetSoundMixVolume(ESoundMix SoundMix, float Volume);
	static void SetVisibilityId(class UPrimitiveComponent* Comp, int32 NewId);
	static bool SGreaterThan(const class FString& StringA, const class FString& StringB);
	static bool SLessThan(const class FString& StringA, const class FString& StringB);
	static float Snap180AngleToSteps(float Angle180, float Step);
	static TArray<class UObject*> SortAndFilterArrayByFunction(const TArray<class UObject*>& Array, const TDelegate<void(class UObject* ObjA, class UObject* ObjB, bool* RetVal)>& FuncDel, const TSubclassOf<class UObject> Class_0);
	static TArray<class UObject*> SortArrayByFunction(const TArray<class UObject*>& Array, const TDelegate<void(class UObject* ObjA, class UObject* ObjB, bool* RetVal)>& FuncDel);
	static TArray<class UObject*> SortArrayByProperty(const TArray<class UObject*>& Array, const class FName& PropertyName, bool bAscending, bool* bWasTypeValid);
	static TArray<struct FServerSearchResult> SortForMatchmaking(const TArray<struct FServerSearchResult>& Array);
	static TArray<struct FPlayFabGameServer> SortForMatchmakingByLocationPreference(const TArray<struct FPlayFabGameServer>& Servers, const TArray<EServerLocation>& LocationPreference);
	static TArray<struct FServerSearchResult> SortForServerBrowserByCount(const TArray<struct FServerSearchResult>& Array, bool bSortAscending);
	static TArray<struct FServerSearchResult> SortForServerBrowserByGameModeName(const TArray<struct FServerSearchResult>& Array, bool bSortAscending);
	static TArray<struct FServerSearchResult> SortForServerBrowserByMapName(const TArray<struct FServerSearchResult>& Array, bool bSortAscending);
	static TArray<struct FServerSearchResult> SortForServerBrowserByPing(const TArray<struct FServerSearchResult>& Array, bool bSortAscending);
	static TArray<struct FServerSearchResult> SortForServerBrowserByServerName(const TArray<struct FServerSearchResult>& Array, bool bSortAscending);
	static TArray<int32> SortIntArray(const TArray<int32>& Array, bool bSortAscending);
	static TArray<class AMordhauPlayerState*> SortPlayers(const TArray<class AMordhauPlayerState*>& Array);
	static TArray<class FString> SortQueueNamesByBestMatch(const TMap<class FString, struct FPlayFabMatchmakingMatch>& Matches);
	static TArray<class FString> SortStringArray(const TArray<class FString>& Array, bool bSortAscending);
	static class UDecalComponent* SpawnBloodDecalAtLocation(class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan);
	static struct FCharacterProfile StripProfile(const struct FCharacterProfile& InProfile, bool bStripEquipment, bool bStripPerks, bool bStripNonTier0Armor);
	static void TermAllChildBodiesOf(class USkeletalMeshComponent* USMC, class FName BoneName);
	static void ToggleNavigation(const class APlayerController* PlayerController, const bool bEnable);
	static bool TryExecuteHeavydutyOperation(class UWorld* WorldObject, bool bIsForced);
	static bool UncompressData(const class FString& InData, TArray<uint8>* OutData);
	static bool UnmountPak(const class FString& PakPath, class UObject* WorldContextObject);
	static void UnpossessCharacterAndHandleSpectating(class AController* Controller);
	static class FString UploadChat(const class FString& ChatString);
	static bool ValidateCharacterProfile(const struct FCharacterProfile& Profile, bool bValidateInventory);
	static void VSmoothDamp(struct FVector* Current, const struct FVector& Target, struct FVector* CurrentVelocity, float SmoothTime, float DeltaTime, float MaxSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauUtilityLibrary">();
	}
	static class UMordhauUtilityLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauUtilityLibrary>();
	}
};
static_assert(alignof(UMordhauUtilityLibrary) == 0x000008, "Wrong alignment on UMordhauUtilityLibrary");
static_assert(sizeof(UMordhauUtilityLibrary) == 0x000028, "Wrong size on UMordhauUtilityLibrary");

// Class Mordhau.MordhauWheeledVehicle
// 0x0030 (0x0BC0 - 0x0B90)
class AMordhauWheeledVehicle : public AMordhauCompoundVehicle
{
public:
	struct FVector2D                              PreviousRotation;                                  // 0x0B88(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotationVelocity;                                  // 0x0B90(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotationVelocityInterpSpeed;                       // 0x0B98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotationVelocityMax;                               // 0x0BA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftHandIKPushTarget;                              // 0x0BA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightHandIKPushTarget;                             // 0x0BB0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              MoveSoundCue;                                      // 0x0BB8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauWheeledVehicle">();
	}
	static class AMordhauWheeledVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMordhauWheeledVehicle>();
	}
};
static_assert(alignof(AMordhauWheeledVehicle) == 0x000010, "Wrong alignment on AMordhauWheeledVehicle");
static_assert(sizeof(AMordhauWheeledVehicle) == 0x000BC0, "Wrong size on AMordhauWheeledVehicle");
static_assert(offsetof(AMordhauWheeledVehicle, PreviousRotation) == 0x000B88, "Member 'AMordhauWheeledVehicle::PreviousRotation' has a wrong offset!");
static_assert(offsetof(AMordhauWheeledVehicle, RotationVelocity) == 0x000B90, "Member 'AMordhauWheeledVehicle::RotationVelocity' has a wrong offset!");
static_assert(offsetof(AMordhauWheeledVehicle, RotationVelocityInterpSpeed) == 0x000B98, "Member 'AMordhauWheeledVehicle::RotationVelocityInterpSpeed' has a wrong offset!");
static_assert(offsetof(AMordhauWheeledVehicle, RotationVelocityMax) == 0x000BA0, "Member 'AMordhauWheeledVehicle::RotationVelocityMax' has a wrong offset!");
static_assert(offsetof(AMordhauWheeledVehicle, LeftHandIKPushTarget) == 0x000BA8, "Member 'AMordhauWheeledVehicle::LeftHandIKPushTarget' has a wrong offset!");
static_assert(offsetof(AMordhauWheeledVehicle, RightHandIKPushTarget) == 0x000BB0, "Member 'AMordhauWheeledVehicle::RightHandIKPushTarget' has a wrong offset!");
static_assert(offsetof(AMordhauWheeledVehicle, MoveSoundCue) == 0x000BB8, "Member 'AMordhauWheeledVehicle::MoveSoundCue' has a wrong offset!");

// Class Mordhau.MordhauWidgetComponent
// 0x00C0 (0x0650 - 0x0590)
class UMordhauWidgetComponent final : public UWidgetComponent
{
public:
	bool                                          bHideWhenParentNotRendered;                        // 0x0590(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PartakesInSortedVisibilityQueue;                   // 0x0591(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_592[0x2];                                      // 0x0592(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SortedVisibilityQueueBiasWeight;                   // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldStickToScreen;                              // 0x0598(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_599[0x3];                                      // 0x0599(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              StickToScreenEdgeOffset;                           // 0x059C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StickToScreenForwardProject;                       // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibilityWeightInterpolationSpeed;                // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5AC[0x8];                                      // 0x05AC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VisibilityWeight;                                  // 0x05B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSlowHideOverride;                               // 0x05B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B9[0x3];                                      // 0x05B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              WidgetCullDistance;                                // 0x05BC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldSpaceZOffset;                                 // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C8[0xC];                                      // 0x05C8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              WidgetCullAngle;                                   // 0x05D4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WidgetCullAngleZPositionOffset;                    // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToCameraZPositionOffset;                   // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToCamera;                                  // 0x05E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextParameter;                                     // 0x05E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntParameter;                                      // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DistanceToCameraString;                            // 0x0600(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_610[0x4];                                      // 0x0610(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWantsDistanceToCameraStringUpdated;               // 0x0614(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_615[0x3];                                      // 0x0615(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngleToCamera;                                     // 0x0618(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverrideVisible;                                   // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_620[0x4];                                      // 0x0620(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class APlayerState>            PlayerStateAlwaysSee;                              // 0x0624(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInMapView;                                    // 0x062C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInMainMenu;                                   // 0x062D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesViewTargetTeamRestriction;                    // 0x062E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62F[0x1];                                      // 0x062F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ViewTargetTeamRestriction;                         // 0x0630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrameSkip;                                         // 0x0634(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_638[0x8];                                      // 0x0638(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AMordhauCameraManager*                  CachedPlayerCameraManager;                         // 0x0640(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMordhauGameState*                      CachedGameState;                                   // 0x0648(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetPlayerStateAlwaysSee(class APlayerState* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MordhauWidgetComponent">();
	}
	static class UMordhauWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMordhauWidgetComponent>();
	}
};
static_assert(alignof(UMordhauWidgetComponent) == 0x000010, "Wrong alignment on UMordhauWidgetComponent");
static_assert(sizeof(UMordhauWidgetComponent) == 0x000650, "Wrong size on UMordhauWidgetComponent");
static_assert(offsetof(UMordhauWidgetComponent, bHideWhenParentNotRendered) == 0x000590, "Member 'UMordhauWidgetComponent::bHideWhenParentNotRendered' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, PartakesInSortedVisibilityQueue) == 0x000591, "Member 'UMordhauWidgetComponent::PartakesInSortedVisibilityQueue' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, SortedVisibilityQueueBiasWeight) == 0x000594, "Member 'UMordhauWidgetComponent::SortedVisibilityQueueBiasWeight' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, bShouldStickToScreen) == 0x000598, "Member 'UMordhauWidgetComponent::bShouldStickToScreen' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, StickToScreenEdgeOffset) == 0x00059C, "Member 'UMordhauWidgetComponent::StickToScreenEdgeOffset' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, StickToScreenForwardProject) == 0x0005A4, "Member 'UMordhauWidgetComponent::StickToScreenForwardProject' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, VisibilityWeightInterpolationSpeed) == 0x0005A8, "Member 'UMordhauWidgetComponent::VisibilityWeightInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, VisibilityWeight) == 0x0005B4, "Member 'UMordhauWidgetComponent::VisibilityWeight' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, bIsSlowHideOverride) == 0x0005B8, "Member 'UMordhauWidgetComponent::bIsSlowHideOverride' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, WidgetCullDistance) == 0x0005BC, "Member 'UMordhauWidgetComponent::WidgetCullDistance' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, WorldSpaceZOffset) == 0x0005C4, "Member 'UMordhauWidgetComponent::WorldSpaceZOffset' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, WidgetCullAngle) == 0x0005D4, "Member 'UMordhauWidgetComponent::WidgetCullAngle' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, WidgetCullAngleZPositionOffset) == 0x0005DC, "Member 'UMordhauWidgetComponent::WidgetCullAngleZPositionOffset' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, DistanceToCameraZPositionOffset) == 0x0005E0, "Member 'UMordhauWidgetComponent::DistanceToCameraZPositionOffset' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, DistanceToCamera) == 0x0005E4, "Member 'UMordhauWidgetComponent::DistanceToCamera' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, TextParameter) == 0x0005E8, "Member 'UMordhauWidgetComponent::TextParameter' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, IntParameter) == 0x0005F8, "Member 'UMordhauWidgetComponent::IntParameter' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, DistanceToCameraString) == 0x000600, "Member 'UMordhauWidgetComponent::DistanceToCameraString' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, bWantsDistanceToCameraStringUpdated) == 0x000614, "Member 'UMordhauWidgetComponent::bWantsDistanceToCameraStringUpdated' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, AngleToCamera) == 0x000618, "Member 'UMordhauWidgetComponent::AngleToCamera' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, OverrideVisible) == 0x00061C, "Member 'UMordhauWidgetComponent::OverrideVisible' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, PlayerStateAlwaysSee) == 0x000624, "Member 'UMordhauWidgetComponent::PlayerStateAlwaysSee' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, bShowInMapView) == 0x00062C, "Member 'UMordhauWidgetComponent::bShowInMapView' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, bShowInMainMenu) == 0x00062D, "Member 'UMordhauWidgetComponent::bShowInMainMenu' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, bUsesViewTargetTeamRestriction) == 0x00062E, "Member 'UMordhauWidgetComponent::bUsesViewTargetTeamRestriction' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, ViewTargetTeamRestriction) == 0x000630, "Member 'UMordhauWidgetComponent::ViewTargetTeamRestriction' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, FrameSkip) == 0x000634, "Member 'UMordhauWidgetComponent::FrameSkip' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, CachedPlayerCameraManager) == 0x000640, "Member 'UMordhauWidgetComponent::CachedPlayerCameraManager' has a wrong offset!");
static_assert(offsetof(UMordhauWidgetComponent, CachedGameState) == 0x000648, "Member 'UMordhauWidgetComponent::CachedGameState' has a wrong offset!");

// Class Mordhau.MotionSystemComponent
// 0x00B8 (0x0168 - 0x00B0)
class UMotionSystemComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MotionFOVOffsetZeroSpeed;                          // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNetMotion                             NetMotion;                                         // 0x00C4(0x0006)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNetMotion>                     UnconfirmedMotionsBacklog;                         // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x2];                                       // 0x00E0(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNetMotion                             LocallyPredictedNetMotion;                         // 0x00E2(0x0006)(NoDestructor, NativeAccessSpecifierPublic)
	class UMordhauMotion*                         Motion;                                            // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParryMotion*                           LastParryMotion;                                   // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFlinchMotion*                          LastFlinchMotion;                                  // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeintedMotion*                         LastFeintedMotion;                                 // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAttackMotion*                          LastAttackMotion;                                  // 0x0108(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEmoteMotion*                           LastEmoteMotion;                                   // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EAttackMove, TSubclassOf<class UAttackMotion>> AttackMotions;                                     // 0x0118(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void OnClientSetNetMotion(const struct FNetMotion& NewMotion, float ServerStartTime);
	void OnLateTick(float DeltaTime);
	void OnLODTick(float DeltaTime);
	void OnPreBeginPlay(class AMordhauCharacter* Character);
	void OnServerAssignNetMotion(const struct FNetMotion& NewNetMotion, uint8 LastAuthObserved);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotionSystemComponent">();
	}
	static class UMotionSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotionSystemComponent>();
	}
};
static_assert(alignof(UMotionSystemComponent) == 0x000008, "Wrong alignment on UMotionSystemComponent");
static_assert(sizeof(UMotionSystemComponent) == 0x000168, "Wrong size on UMotionSystemComponent");
static_assert(offsetof(UMotionSystemComponent, MotionFOVOffsetZeroSpeed) == 0x0000C0, "Member 'UMotionSystemComponent::MotionFOVOffsetZeroSpeed' has a wrong offset!");
static_assert(offsetof(UMotionSystemComponent, NetMotion) == 0x0000C4, "Member 'UMotionSystemComponent::NetMotion' has a wrong offset!");
static_assert(offsetof(UMotionSystemComponent, UnconfirmedMotionsBacklog) == 0x0000D0, "Member 'UMotionSystemComponent::UnconfirmedMotionsBacklog' has a wrong offset!");
static_assert(offsetof(UMotionSystemComponent, LocallyPredictedNetMotion) == 0x0000E2, "Member 'UMotionSystemComponent::LocallyPredictedNetMotion' has a wrong offset!");
static_assert(offsetof(UMotionSystemComponent, Motion) == 0x0000E8, "Member 'UMotionSystemComponent::Motion' has a wrong offset!");
static_assert(offsetof(UMotionSystemComponent, LastParryMotion) == 0x0000F0, "Member 'UMotionSystemComponent::LastParryMotion' has a wrong offset!");
static_assert(offsetof(UMotionSystemComponent, LastFlinchMotion) == 0x0000F8, "Member 'UMotionSystemComponent::LastFlinchMotion' has a wrong offset!");
static_assert(offsetof(UMotionSystemComponent, LastFeintedMotion) == 0x000100, "Member 'UMotionSystemComponent::LastFeintedMotion' has a wrong offset!");
static_assert(offsetof(UMotionSystemComponent, LastAttackMotion) == 0x000108, "Member 'UMotionSystemComponent::LastAttackMotion' has a wrong offset!");
static_assert(offsetof(UMotionSystemComponent, LastEmoteMotion) == 0x000110, "Member 'UMotionSystemComponent::LastEmoteMotion' has a wrong offset!");
static_assert(offsetof(UMotionSystemComponent, AttackMotions) == 0x000118, "Member 'UMotionSystemComponent::AttackMotions' has a wrong offset!");

// Class Mordhau.MoveSoundComponent
// 0x0060 (0x08C0 - 0x0860)
class UMoveSoundComponent final : public UAudioComponent
{
public:
	bool                                          bShouldPlayMoveSound;                              // 0x0860(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayTurnSound;                              // 0x0861(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_862[0x2];                                      // 0x0862(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MoveSoundAttachSocket;                             // 0x0864(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSoundFadeOut;                                  // 0x086C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MinRotationVelocityToPlayMoveSound;                // 0x0870(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MinTranslationVelocityToPlayMoveSound;             // 0x0878(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotationVelocityInterpSpeed;                       // 0x0884(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotationVelocityMax;                               // 0x088C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_894[0x4];                                      // 0x0894(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              MoveSoundCue;                                      // 0x0898(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         LastMoveSound;                                     // 0x08A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PreviousRotation;                                  // 0x08A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotationVelocity;                                  // 0x08B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B8[0x8];                                      // 0x08B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterDied(class AAdvancedCharacter* Character);
	void OnLODTick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveSoundComponent">();
	}
	static class UMoveSoundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveSoundComponent>();
	}
};
static_assert(alignof(UMoveSoundComponent) == 0x000010, "Wrong alignment on UMoveSoundComponent");
static_assert(sizeof(UMoveSoundComponent) == 0x0008C0, "Wrong size on UMoveSoundComponent");
static_assert(offsetof(UMoveSoundComponent, bShouldPlayMoveSound) == 0x000860, "Member 'UMoveSoundComponent::bShouldPlayMoveSound' has a wrong offset!");
static_assert(offsetof(UMoveSoundComponent, bShouldPlayTurnSound) == 0x000861, "Member 'UMoveSoundComponent::bShouldPlayTurnSound' has a wrong offset!");
static_assert(offsetof(UMoveSoundComponent, MoveSoundAttachSocket) == 0x000864, "Member 'UMoveSoundComponent::MoveSoundAttachSocket' has a wrong offset!");
static_assert(offsetof(UMoveSoundComponent, MoveSoundFadeOut) == 0x00086C, "Member 'UMoveSoundComponent::MoveSoundFadeOut' has a wrong offset!");
static_assert(offsetof(UMoveSoundComponent, MinRotationVelocityToPlayMoveSound) == 0x000870, "Member 'UMoveSoundComponent::MinRotationVelocityToPlayMoveSound' has a wrong offset!");
static_assert(offsetof(UMoveSoundComponent, MinTranslationVelocityToPlayMoveSound) == 0x000878, "Member 'UMoveSoundComponent::MinTranslationVelocityToPlayMoveSound' has a wrong offset!");
static_assert(offsetof(UMoveSoundComponent, RotationVelocityInterpSpeed) == 0x000884, "Member 'UMoveSoundComponent::RotationVelocityInterpSpeed' has a wrong offset!");
static_assert(offsetof(UMoveSoundComponent, RotationVelocityMax) == 0x00088C, "Member 'UMoveSoundComponent::RotationVelocityMax' has a wrong offset!");
static_assert(offsetof(UMoveSoundComponent, MoveSoundCue) == 0x000898, "Member 'UMoveSoundComponent::MoveSoundCue' has a wrong offset!");
static_assert(offsetof(UMoveSoundComponent, LastMoveSound) == 0x0008A0, "Member 'UMoveSoundComponent::LastMoveSound' has a wrong offset!");
static_assert(offsetof(UMoveSoundComponent, PreviousRotation) == 0x0008A8, "Member 'UMoveSoundComponent::PreviousRotation' has a wrong offset!");
static_assert(offsetof(UMoveSoundComponent, RotationVelocity) == 0x0008B0, "Member 'UMoveSoundComponent::RotationVelocity' has a wrong offset!");

// Class Mordhau.OneDimensionalMovementComponent
// 0x0040 (0x0C90 - 0x0C50)
class UOneDimensionalMovementComponent final : public UAdvancedCharacterMovement
{
public:
	bool                                          bIsMovementInSteps;                                // 0x0C48(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDriverSpeedFactor;                             // 0x0C49(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4A[0x2];                                      // 0x0C4A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetStep;                                        // 0x0C4C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepSize;                                          // 0x0C50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalSteps;                                        // 0x0C54(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasInitializedLine;                               // 0x0C58(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C59[0x3];                                      // 0x0C59(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentStep;                                       // 0x0C5C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineStart;                                         // 0x0C60(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x0C6C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MovementDirection;                                 // 0x0C78(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C84[0xC];                                      // 0x0C84(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMovementLine(const struct FVector& NewLineStart, const struct FVector& NewLineEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OneDimensionalMovementComponent">();
	}
	static class UOneDimensionalMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOneDimensionalMovementComponent>();
	}
};
static_assert(alignof(UOneDimensionalMovementComponent) == 0x000010, "Wrong alignment on UOneDimensionalMovementComponent");
static_assert(sizeof(UOneDimensionalMovementComponent) == 0x000C90, "Wrong size on UOneDimensionalMovementComponent");
static_assert(offsetof(UOneDimensionalMovementComponent, bIsMovementInSteps) == 0x000C48, "Member 'UOneDimensionalMovementComponent::bIsMovementInSteps' has a wrong offset!");
static_assert(offsetof(UOneDimensionalMovementComponent, bUseDriverSpeedFactor) == 0x000C49, "Member 'UOneDimensionalMovementComponent::bUseDriverSpeedFactor' has a wrong offset!");
static_assert(offsetof(UOneDimensionalMovementComponent, TargetStep) == 0x000C4C, "Member 'UOneDimensionalMovementComponent::TargetStep' has a wrong offset!");
static_assert(offsetof(UOneDimensionalMovementComponent, StepSize) == 0x000C50, "Member 'UOneDimensionalMovementComponent::StepSize' has a wrong offset!");
static_assert(offsetof(UOneDimensionalMovementComponent, TotalSteps) == 0x000C54, "Member 'UOneDimensionalMovementComponent::TotalSteps' has a wrong offset!");
static_assert(offsetof(UOneDimensionalMovementComponent, bHasInitializedLine) == 0x000C58, "Member 'UOneDimensionalMovementComponent::bHasInitializedLine' has a wrong offset!");
static_assert(offsetof(UOneDimensionalMovementComponent, CurrentStep) == 0x000C5C, "Member 'UOneDimensionalMovementComponent::CurrentStep' has a wrong offset!");
static_assert(offsetof(UOneDimensionalMovementComponent, LineStart) == 0x000C60, "Member 'UOneDimensionalMovementComponent::LineStart' has a wrong offset!");
static_assert(offsetof(UOneDimensionalMovementComponent, LineEnd) == 0x000C6C, "Member 'UOneDimensionalMovementComponent::LineEnd' has a wrong offset!");
static_assert(offsetof(UOneDimensionalMovementComponent, MovementDirection) == 0x000C78, "Member 'UOneDimensionalMovementComponent::MovementDirection' has a wrong offset!");

// Class Mordhau.ParticleSystemActor
// 0x0018 (0x0238 - 0x0220)
class AParticleSystemActor final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        Template;                                          // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SparseTick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleSystemActor">();
	}
	static class AParticleSystemActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AParticleSystemActor>();
	}
};
static_assert(alignof(AParticleSystemActor) == 0x000008, "Wrong alignment on AParticleSystemActor");
static_assert(sizeof(AParticleSystemActor) == 0x000238, "Wrong size on AParticleSystemActor");
static_assert(offsetof(AParticleSystemActor, Template) == 0x000228, "Member 'AParticleSystemActor::Template' has a wrong offset!");
static_assert(offsetof(AParticleSystemActor, ParticleSystemComponent) == 0x000230, "Member 'AParticleSystemActor::ParticleSystemComponent' has a wrong offset!");

// Class Mordhau.Perk
// 0x0048 (0x0070 - 0x0028)
class UPerk : public UObject
{
public:
	class FText                                   Name_0;                                            // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPerk                                         Enum;                                              // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Perk">();
	}
	static class UPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerk>();
	}
};
static_assert(alignof(UPerk) == 0x000008, "Wrong alignment on UPerk");
static_assert(sizeof(UPerk) == 0x000070, "Wrong size on UPerk");
static_assert(offsetof(UPerk, Name_0) == 0x000028, "Member 'UPerk::Name_0' has a wrong offset!");
static_assert(offsetof(UPerk, Cost) == 0x000040, "Member 'UPerk::Cost' has a wrong offset!");
static_assert(offsetof(UPerk, Description) == 0x000048, "Member 'UPerk::Description' has a wrong offset!");
static_assert(offsetof(UPerk, Icon) == 0x000060, "Member 'UPerk::Icon' has a wrong offset!");
static_assert(offsetof(UPerk, Enum) == 0x000068, "Member 'UPerk::Enum' has a wrong offset!");

// Class Mordhau.PerkSystemComponent
// 0x0090 (0x0140 - 0x00B0)
class UPerkSystemComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ButcherDamageModifier;                             // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WreckerStructureDamageModifier;                    // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmithStructureRepairModifier;                      // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireproofReceivedFireDamageModifier;               // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FuryStaminaOnKill;                                 // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondWindExtraStaminaOnHit;                       // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcrobatJumpStaminaCost;                            // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushMovementBoostDuration;                         // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RushMovementRestrictionOverrideDuration;           // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HuntsmanCooldown;                                  // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RatFootstepVolumeModifier;                         // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CatFallDamageModifier;                             // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankScale;                                         // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankArmorSpeedFactor;                              // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankArmorAccelerationFactor;                       // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankHealingModifier;                               // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankReceivedDamageModifier;                        // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankVoicePitchMultiplier;                          // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TankAttackTurncapModifier;                         // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DwarfScale;                                        // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DwarfMeshZOffset;                                  // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DwarfMeshZOffsetCrouched;                          // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DwarfReceivedDamageModifier;                       // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DwarfSpeedModifier;                                // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DwarfVoicePitchMultiplier;                         // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DwarfJumpVelocityMultiplier;                       // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterBuilt(class AMordhauCharacter* Character);
	void OnLODTick(float DeltaTime);
	void OnPreBeginPlay(class AMordhauCharacter* Character);
	void OnTakeDamage(class AAdvancedCharacter* Character, const struct FMordhauDamageInfo& DamageInfo, class AController* EventInstigator, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkSystemComponent">();
	}
	static class UPerkSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkSystemComponent>();
	}
};
static_assert(alignof(UPerkSystemComponent) == 0x000008, "Wrong alignment on UPerkSystemComponent");
static_assert(sizeof(UPerkSystemComponent) == 0x000140, "Wrong size on UPerkSystemComponent");
static_assert(offsetof(UPerkSystemComponent, ButcherDamageModifier) == 0x0000D0, "Member 'UPerkSystemComponent::ButcherDamageModifier' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, WreckerStructureDamageModifier) == 0x0000D4, "Member 'UPerkSystemComponent::WreckerStructureDamageModifier' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, SmithStructureRepairModifier) == 0x0000D8, "Member 'UPerkSystemComponent::SmithStructureRepairModifier' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, FireproofReceivedFireDamageModifier) == 0x0000DC, "Member 'UPerkSystemComponent::FireproofReceivedFireDamageModifier' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, FuryStaminaOnKill) == 0x0000E0, "Member 'UPerkSystemComponent::FuryStaminaOnKill' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, SecondWindExtraStaminaOnHit) == 0x0000E4, "Member 'UPerkSystemComponent::SecondWindExtraStaminaOnHit' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, AcrobatJumpStaminaCost) == 0x0000E8, "Member 'UPerkSystemComponent::AcrobatJumpStaminaCost' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, RushMovementBoostDuration) == 0x0000EC, "Member 'UPerkSystemComponent::RushMovementBoostDuration' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, RushMovementRestrictionOverrideDuration) == 0x0000F0, "Member 'UPerkSystemComponent::RushMovementRestrictionOverrideDuration' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, HuntsmanCooldown) == 0x0000F4, "Member 'UPerkSystemComponent::HuntsmanCooldown' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, RatFootstepVolumeModifier) == 0x0000F8, "Member 'UPerkSystemComponent::RatFootstepVolumeModifier' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, CatFallDamageModifier) == 0x0000FC, "Member 'UPerkSystemComponent::CatFallDamageModifier' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, TankScale) == 0x000100, "Member 'UPerkSystemComponent::TankScale' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, TankArmorSpeedFactor) == 0x000104, "Member 'UPerkSystemComponent::TankArmorSpeedFactor' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, TankArmorAccelerationFactor) == 0x000108, "Member 'UPerkSystemComponent::TankArmorAccelerationFactor' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, TankHealingModifier) == 0x00010C, "Member 'UPerkSystemComponent::TankHealingModifier' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, TankReceivedDamageModifier) == 0x000110, "Member 'UPerkSystemComponent::TankReceivedDamageModifier' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, TankVoicePitchMultiplier) == 0x000114, "Member 'UPerkSystemComponent::TankVoicePitchMultiplier' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, TankAttackTurncapModifier) == 0x000118, "Member 'UPerkSystemComponent::TankAttackTurncapModifier' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, DwarfScale) == 0x00011C, "Member 'UPerkSystemComponent::DwarfScale' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, DwarfMeshZOffset) == 0x000120, "Member 'UPerkSystemComponent::DwarfMeshZOffset' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, DwarfMeshZOffsetCrouched) == 0x000124, "Member 'UPerkSystemComponent::DwarfMeshZOffsetCrouched' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, DwarfReceivedDamageModifier) == 0x000128, "Member 'UPerkSystemComponent::DwarfReceivedDamageModifier' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, DwarfSpeedModifier) == 0x00012C, "Member 'UPerkSystemComponent::DwarfSpeedModifier' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, DwarfVoicePitchMultiplier) == 0x000130, "Member 'UPerkSystemComponent::DwarfVoicePitchMultiplier' has a wrong offset!");
static_assert(offsetof(UPerkSystemComponent, DwarfJumpVelocityMultiplier) == 0x000134, "Member 'UPerkSystemComponent::DwarfJumpVelocityMultiplier' has a wrong offset!");

// Class Mordhau.PerspectiveTypes
// 0x0000 (0x0028 - 0x0028)
class UPerspectiveTypes final : public UBlueprintFunctionLibrary
{
public:
	static class UAnimMontage* Get(const struct FPerspectiveAnimMontage& PerspectiveType, bool bIsFirstPerson);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerspectiveTypes">();
	}
	static class UPerspectiveTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerspectiveTypes>();
	}
};
static_assert(alignof(UPerspectiveTypes) == 0x000008, "Wrong alignment on UPerspectiveTypes");
static_assert(sizeof(UPerspectiveTypes) == 0x000028, "Wrong size on UPerspectiveTypes");

// Class Mordhau.PhysicsProxy
// 0x0050 (0x0270 - 0x0220)
class APhysicsProxy final : public AActor
{
public:
	TWeakObjectPtr<class AActor>                  Original;                                          // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0230(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMesh;                                      // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleTime;                                          // 0x0268(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsProxy">();
	}
	static class APhysicsProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhysicsProxy>();
	}
};
static_assert(alignof(APhysicsProxy) == 0x000010, "Wrong alignment on APhysicsProxy");
static_assert(sizeof(APhysicsProxy) == 0x000270, "Wrong size on APhysicsProxy");
static_assert(offsetof(APhysicsProxy, Original) == 0x000220, "Member 'APhysicsProxy::Original' has a wrong offset!");
static_assert(offsetof(APhysicsProxy, Offset) == 0x000230, "Member 'APhysicsProxy::Offset' has a wrong offset!");
static_assert(offsetof(APhysicsProxy, SkeletalMesh) == 0x000260, "Member 'APhysicsProxy::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(APhysicsProxy, IdleTime) == 0x000268, "Member 'APhysicsProxy::IdleTime' has a wrong offset!");

// Class Mordhau.PhysicsVehicleComponent
// 0x0030 (0x01E0 - 0x01B0)
class UPhysicsVehicleComponent : public UMordhauVehicleComponent
{
public:
	class FName                                   LeftHandIKPushTarget;                              // 0x01A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightHandIKPushTarget;                             // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeed;                                          // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRotation;                                       // 0x01BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirectionInterpSpeed;                              // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D4[0xC];                                      // 0x01D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsVehicleComponent">();
	}
	static class UPhysicsVehicleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsVehicleComponent>();
	}
};
static_assert(alignof(UPhysicsVehicleComponent) == 0x000010, "Wrong alignment on UPhysicsVehicleComponent");
static_assert(sizeof(UPhysicsVehicleComponent) == 0x0001E0, "Wrong size on UPhysicsVehicleComponent");
static_assert(offsetof(UPhysicsVehicleComponent, LeftHandIKPushTarget) == 0x0001A8, "Member 'UPhysicsVehicleComponent::LeftHandIKPushTarget' has a wrong offset!");
static_assert(offsetof(UPhysicsVehicleComponent, RightHandIKPushTarget) == 0x0001B0, "Member 'UPhysicsVehicleComponent::RightHandIKPushTarget' has a wrong offset!");
static_assert(offsetof(UPhysicsVehicleComponent, MaxSpeed) == 0x0001B8, "Member 'UPhysicsVehicleComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UPhysicsVehicleComponent, MaxRotation) == 0x0001BC, "Member 'UPhysicsVehicleComponent::MaxRotation' has a wrong offset!");
static_assert(offsetof(UPhysicsVehicleComponent, DirectionInterpSpeed) == 0x0001D0, "Member 'UPhysicsVehicleComponent::DirectionInterpSpeed' has a wrong offset!");

// Class Mordhau.PlayerlistCommand
// 0x0000 (0x0080 - 0x0080)
class UPlayerlistCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerlistCommand">();
	}
	static class UPlayerlistCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerlistCommand>();
	}
};
static_assert(alignof(UPlayerlistCommand) == 0x000008, "Wrong alignment on UPlayerlistCommand");
static_assert(sizeof(UPlayerlistCommand) == 0x000080, "Wrong size on UPlayerlistCommand");

// Class Mordhau.PommelThrowDrawMotion
// 0x0028 (0x00C8 - 0x00A0)
class UPommelThrowDrawMotion final : public UMordhauMotion
{
public:
	class AMordhauEquipment*                      RangedEquipment;                                   // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Stage;                                             // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FirstStageEnd;                                     // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondStageEnd;                                    // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdStageEnd;                                     // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFiredLocally;                                  // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlaying1P;                                      // 0x00B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CurrentMontage;                                    // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PommelThrowDrawMotion">();
	}
	static class UPommelThrowDrawMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPommelThrowDrawMotion>();
	}
};
static_assert(alignof(UPommelThrowDrawMotion) == 0x000008, "Wrong alignment on UPommelThrowDrawMotion");
static_assert(sizeof(UPommelThrowDrawMotion) == 0x0000C8, "Wrong size on UPommelThrowDrawMotion");
static_assert(offsetof(UPommelThrowDrawMotion, RangedEquipment) == 0x0000A0, "Member 'UPommelThrowDrawMotion::RangedEquipment' has a wrong offset!");
static_assert(offsetof(UPommelThrowDrawMotion, Stage) == 0x0000A8, "Member 'UPommelThrowDrawMotion::Stage' has a wrong offset!");
static_assert(offsetof(UPommelThrowDrawMotion, FirstStageEnd) == 0x0000AC, "Member 'UPommelThrowDrawMotion::FirstStageEnd' has a wrong offset!");
static_assert(offsetof(UPommelThrowDrawMotion, SecondStageEnd) == 0x0000B0, "Member 'UPommelThrowDrawMotion::SecondStageEnd' has a wrong offset!");
static_assert(offsetof(UPommelThrowDrawMotion, ThirdStageEnd) == 0x0000B4, "Member 'UPommelThrowDrawMotion::ThirdStageEnd' has a wrong offset!");
static_assert(offsetof(UPommelThrowDrawMotion, bHasFiredLocally) == 0x0000B8, "Member 'UPommelThrowDrawMotion::bHasFiredLocally' has a wrong offset!");
static_assert(offsetof(UPommelThrowDrawMotion, bIsPlaying1P) == 0x0000B9, "Member 'UPommelThrowDrawMotion::bIsPlaying1P' has a wrong offset!");
static_assert(offsetof(UPommelThrowDrawMotion, CurrentMontage) == 0x0000C0, "Member 'UPommelThrowDrawMotion::CurrentMontage' has a wrong offset!");

// Class Mordhau.PommelThrowReleaseMotion
// 0x0018 (0x00B8 - 0x00A0)
class UPommelThrowReleaseMotion final : public UMordhauMotion
{
public:
	class AMordhauEquipment*                      RangedEquipment;                                   // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauProjectile>      CreatedLocalProjectile;                            // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Stage;                                             // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FirstStageEnd;                                     // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PommelThrowReleaseMotion">();
	}
	static class UPommelThrowReleaseMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPommelThrowReleaseMotion>();
	}
};
static_assert(alignof(UPommelThrowReleaseMotion) == 0x000008, "Wrong alignment on UPommelThrowReleaseMotion");
static_assert(sizeof(UPommelThrowReleaseMotion) == 0x0000B8, "Wrong size on UPommelThrowReleaseMotion");
static_assert(offsetof(UPommelThrowReleaseMotion, RangedEquipment) == 0x0000A0, "Member 'UPommelThrowReleaseMotion::RangedEquipment' has a wrong offset!");
static_assert(offsetof(UPommelThrowReleaseMotion, CreatedLocalProjectile) == 0x0000A8, "Member 'UPommelThrowReleaseMotion::CreatedLocalProjectile' has a wrong offset!");
static_assert(offsetof(UPommelThrowReleaseMotion, Stage) == 0x0000B0, "Member 'UPommelThrowReleaseMotion::Stage' has a wrong offset!");
static_assert(offsetof(UPommelThrowReleaseMotion, FirstStageEnd) == 0x0000B4, "Member 'UPommelThrowReleaseMotion::FirstStageEnd' has a wrong offset!");

// Class Mordhau.PrecomputedOcclusionDataActor
// 0x0058 (0x0278 - 0x0220)
class APrecomputedOcclusionDataActor final : public AActor
{
public:
	uint8                                         Pad_220[0x58];                                     // 0x0220(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrecomputedOcclusionDataActor">();
	}
	static class APrecomputedOcclusionDataActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APrecomputedOcclusionDataActor>();
	}
};
static_assert(alignof(APrecomputedOcclusionDataActor) == 0x000008, "Wrong alignment on APrecomputedOcclusionDataActor");
static_assert(sizeof(APrecomputedOcclusionDataActor) == 0x000278, "Wrong size on APrecomputedOcclusionDataActor");

// Class Mordhau.PreSkinnedPoseOracle
// 0x0050 (0x0270 - 0x0220)
class APreSkinnedPoseOracle final : public AActor
{
public:
	TMap<class USkeleton*, class USkeletalMeshComponent*> SkeletonToMeshComp;                                // 0x0220(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreSkinnedPoseOracle">();
	}
	static class APreSkinnedPoseOracle* GetDefaultObj()
	{
		return GetDefaultObjImpl<APreSkinnedPoseOracle>();
	}
};
static_assert(alignof(APreSkinnedPoseOracle) == 0x000008, "Wrong alignment on APreSkinnedPoseOracle");
static_assert(sizeof(APreSkinnedPoseOracle) == 0x000270, "Wrong size on APreSkinnedPoseOracle");
static_assert(offsetof(APreSkinnedPoseOracle, SkeletonToMeshComp) == 0x000220, "Member 'APreSkinnedPoseOracle::SkeletonToMeshComp' has a wrong offset!");

// Class Mordhau.ProgressActor
// 0x0000 (0x03E0 - 0x03E0)
class AProgressActor final : public AMordhauActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressActor">();
	}
	static class AProgressActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProgressActor>();
	}
};
static_assert(alignof(AProgressActor) == 0x000010, "Wrong alignment on AProgressActor");
static_assert(sizeof(AProgressActor) == 0x0003E0, "Wrong size on AProgressActor");

// Class Mordhau.ProgressDriver
// 0x0000 (0x03E0 - 0x03E0)
class AProgressDriver : public AMordhauActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressDriver">();
	}
	static class AProgressDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProgressDriver>();
	}
};
static_assert(alignof(AProgressDriver) == 0x000010, "Wrong alignment on AProgressDriver");
static_assert(sizeof(AProgressDriver) == 0x0003E0, "Wrong size on AProgressDriver");

// Class Mordhau.ProjectileArmShooterComponent
// 0x0080 (0x0310 - 0x0290)
class UProjectileArmShooterComponent final : public UProjectileShooterComponent
{
public:
	float                                         LoadedArmMin;                                      // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArmAdjustmentMin;                                  // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArmAdjustmentMax;                                  // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArmAdjustmentStep;                                 // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ArmPullSoundAttachSocket;                          // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              ArmPullSoundCue;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondaryReleaseSoundAttachSocket;                 // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              SecondaryReleaseSoundCue;                          // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RecoverySoundAttachSocket;                         // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              RecoveryReleaseSoundCue;                           // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmPullSoundFadeOutDuration;                       // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedArm;                                     // 0x02D4(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArmFrom;                                           // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmTarget;                                         // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmRaisedTimestamp;                                // 0x02E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmLoweredTimestamp;                               // 0x02E4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastArmTarget;                                     // 0x02E8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            FiredController;                                   // 0x02F0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmTargetInterpolationSpeed;                       // 0x02F8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         LastArmPullSound;                                  // 0x02FC(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0xC];                                      // 0x0304(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustArm(int32 Delta);
	void LowerArm();
	void OnLowerArmPressed();
	void OnRaiseArmPressed();
	void RaiseArm();
	void UpdateArmPullSound(class AActor* CharacterOwner, float DeltaTime);
	void UpdateArmTarget(class AActor* Owner, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileArmShooterComponent">();
	}
	static class UProjectileArmShooterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileArmShooterComponent>();
	}
};
static_assert(alignof(UProjectileArmShooterComponent) == 0x000010, "Wrong alignment on UProjectileArmShooterComponent");
static_assert(sizeof(UProjectileArmShooterComponent) == 0x000310, "Wrong size on UProjectileArmShooterComponent");
static_assert(offsetof(UProjectileArmShooterComponent, LoadedArmMin) == 0x000290, "Member 'UProjectileArmShooterComponent::LoadedArmMin' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, ArmAdjustmentMin) == 0x000294, "Member 'UProjectileArmShooterComponent::ArmAdjustmentMin' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, ArmAdjustmentMax) == 0x000298, "Member 'UProjectileArmShooterComponent::ArmAdjustmentMax' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, ArmAdjustmentStep) == 0x00029C, "Member 'UProjectileArmShooterComponent::ArmAdjustmentStep' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, ArmPullSoundAttachSocket) == 0x0002A0, "Member 'UProjectileArmShooterComponent::ArmPullSoundAttachSocket' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, ArmPullSoundCue) == 0x0002A8, "Member 'UProjectileArmShooterComponent::ArmPullSoundCue' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, SecondaryReleaseSoundAttachSocket) == 0x0002B0, "Member 'UProjectileArmShooterComponent::SecondaryReleaseSoundAttachSocket' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, SecondaryReleaseSoundCue) == 0x0002B8, "Member 'UProjectileArmShooterComponent::SecondaryReleaseSoundCue' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, RecoverySoundAttachSocket) == 0x0002C0, "Member 'UProjectileArmShooterComponent::RecoverySoundAttachSocket' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, RecoveryReleaseSoundCue) == 0x0002C8, "Member 'UProjectileArmShooterComponent::RecoveryReleaseSoundCue' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, ArmPullSoundFadeOutDuration) == 0x0002D0, "Member 'UProjectileArmShooterComponent::ArmPullSoundFadeOutDuration' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, ReplicatedArm) == 0x0002D4, "Member 'UProjectileArmShooterComponent::ReplicatedArm' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, ArmFrom) == 0x0002D8, "Member 'UProjectileArmShooterComponent::ArmFrom' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, ArmTarget) == 0x0002DC, "Member 'UProjectileArmShooterComponent::ArmTarget' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, ArmRaisedTimestamp) == 0x0002E0, "Member 'UProjectileArmShooterComponent::ArmRaisedTimestamp' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, ArmLoweredTimestamp) == 0x0002E4, "Member 'UProjectileArmShooterComponent::ArmLoweredTimestamp' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, LastArmTarget) == 0x0002E8, "Member 'UProjectileArmShooterComponent::LastArmTarget' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, FiredController) == 0x0002F0, "Member 'UProjectileArmShooterComponent::FiredController' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, ArmTargetInterpolationSpeed) == 0x0002F8, "Member 'UProjectileArmShooterComponent::ArmTargetInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UProjectileArmShooterComponent, LastArmPullSound) == 0x0002FC, "Member 'UProjectileArmShooterComponent::LastArmPullSound' has a wrong offset!");

// Class Mordhau.ProjectileTurretShooterComponent
// 0x0030 (0x02C0 - 0x0290)
class UProjectileTurretShooterComponent final : public UProjectileShooterComponent
{
public:
	float                                         LoadingSoundFadeOutDuration;                       // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponKickBackLookUp;                              // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationVelocity;                                  // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterpolationSpeed;                        // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReplicatedTurnCap;                                 // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReplicatedLookUpCap;                               // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousActorYaw;                                  // 0x02A8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PreviousPitch;                                     // 0x02AC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UAudioComponent>         LastLoadingSound;                                  // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LookUpCapChanged();
	void OnRep_TurnCapChanged();
	void SetLookUpCap(float Value);
	void SetTurnCap(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileTurretShooterComponent">();
	}
	static class UProjectileTurretShooterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileTurretShooterComponent>();
	}
};
static_assert(alignof(UProjectileTurretShooterComponent) == 0x000010, "Wrong alignment on UProjectileTurretShooterComponent");
static_assert(sizeof(UProjectileTurretShooterComponent) == 0x0002C0, "Wrong size on UProjectileTurretShooterComponent");
static_assert(offsetof(UProjectileTurretShooterComponent, LoadingSoundFadeOutDuration) == 0x000290, "Member 'UProjectileTurretShooterComponent::LoadingSoundFadeOutDuration' has a wrong offset!");
static_assert(offsetof(UProjectileTurretShooterComponent, WeaponKickBackLookUp) == 0x000294, "Member 'UProjectileTurretShooterComponent::WeaponKickBackLookUp' has a wrong offset!");
static_assert(offsetof(UProjectileTurretShooterComponent, RotationVelocity) == 0x000298, "Member 'UProjectileTurretShooterComponent::RotationVelocity' has a wrong offset!");
static_assert(offsetof(UProjectileTurretShooterComponent, RotationInterpolationSpeed) == 0x00029C, "Member 'UProjectileTurretShooterComponent::RotationInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UProjectileTurretShooterComponent, ReplicatedTurnCap) == 0x0002A0, "Member 'UProjectileTurretShooterComponent::ReplicatedTurnCap' has a wrong offset!");
static_assert(offsetof(UProjectileTurretShooterComponent, ReplicatedLookUpCap) == 0x0002A4, "Member 'UProjectileTurretShooterComponent::ReplicatedLookUpCap' has a wrong offset!");
static_assert(offsetof(UProjectileTurretShooterComponent, PreviousActorYaw) == 0x0002A8, "Member 'UProjectileTurretShooterComponent::PreviousActorYaw' has a wrong offset!");
static_assert(offsetof(UProjectileTurretShooterComponent, PreviousPitch) == 0x0002AC, "Member 'UProjectileTurretShooterComponent::PreviousPitch' has a wrong offset!");
static_assert(offsetof(UProjectileTurretShooterComponent, LastLoadingSound) == 0x0002B0, "Member 'UProjectileTurretShooterComponent::LastLoadingSound' has a wrong offset!");

// Class Mordhau.PushableActor
// 0x0080 (0x0460 - 0x03E0)
class APushableActor : public AMordhauActor
{
public:
	bool                                          bIsPushingAllowed;                                 // 0x03E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPullingAllowed;                                 // 0x03E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicateProgress;                                // 0x03E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoMoveIfAlone;                                  // 0x03E3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoMoveSpeed;                                     // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 NonPullableThresholds;                             // 0x03F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Team1Presence;                                     // 0x0400(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Team2Presence;                                     // 0x0404(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Team1PushSpeedByPushers;                           // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Team2PushSpeedByPushers;                           // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopPushingIfContested;                           // 0x0418(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    PushArea;                                          // 0x0420(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProgressStepToAwardScoreFor;                       // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoreAwardedPerProgressStep;                       // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetworkInterpolationSpeed;                         // 0x0430(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NetworkInterpolationSpeedConstant;                 // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNetworkInterpolationConstant;                   // 0x0438(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_439[0x1];                                      // 0x0439(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        ReplicatedProgress;                                // 0x043A(0x0002)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x043C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_440[0x10];                                     // 0x0440(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrowdObstacleComponent*                Obstacle;                                          // 0x0450(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInitialProgressReplication();
	void OnProgressUpdated(float OldProgress);
	void OnRep_ReplicatedProgress();
	void SetProgress(float NewProgress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushableActor">();
	}
	static class APushableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APushableActor>();
	}
};
static_assert(alignof(APushableActor) == 0x000010, "Wrong alignment on APushableActor");
static_assert(sizeof(APushableActor) == 0x000460, "Wrong size on APushableActor");
static_assert(offsetof(APushableActor, bIsPushingAllowed) == 0x0003E0, "Member 'APushableActor::bIsPushingAllowed' has a wrong offset!");
static_assert(offsetof(APushableActor, bIsPullingAllowed) == 0x0003E1, "Member 'APushableActor::bIsPullingAllowed' has a wrong offset!");
static_assert(offsetof(APushableActor, bReplicateProgress) == 0x0003E2, "Member 'APushableActor::bReplicateProgress' has a wrong offset!");
static_assert(offsetof(APushableActor, bAutoMoveIfAlone) == 0x0003E3, "Member 'APushableActor::bAutoMoveIfAlone' has a wrong offset!");
static_assert(offsetof(APushableActor, AutoMoveSpeed) == 0x0003E4, "Member 'APushableActor::AutoMoveSpeed' has a wrong offset!");
static_assert(offsetof(APushableActor, NonPullableThresholds) == 0x0003F0, "Member 'APushableActor::NonPullableThresholds' has a wrong offset!");
static_assert(offsetof(APushableActor, Team1Presence) == 0x000400, "Member 'APushableActor::Team1Presence' has a wrong offset!");
static_assert(offsetof(APushableActor, Team2Presence) == 0x000404, "Member 'APushableActor::Team2Presence' has a wrong offset!");
static_assert(offsetof(APushableActor, Team1PushSpeedByPushers) == 0x000408, "Member 'APushableActor::Team1PushSpeedByPushers' has a wrong offset!");
static_assert(offsetof(APushableActor, Team2PushSpeedByPushers) == 0x000410, "Member 'APushableActor::Team2PushSpeedByPushers' has a wrong offset!");
static_assert(offsetof(APushableActor, bStopPushingIfContested) == 0x000418, "Member 'APushableActor::bStopPushingIfContested' has a wrong offset!");
static_assert(offsetof(APushableActor, PushArea) == 0x000420, "Member 'APushableActor::PushArea' has a wrong offset!");
static_assert(offsetof(APushableActor, ProgressStepToAwardScoreFor) == 0x000428, "Member 'APushableActor::ProgressStepToAwardScoreFor' has a wrong offset!");
static_assert(offsetof(APushableActor, ScoreAwardedPerProgressStep) == 0x00042C, "Member 'APushableActor::ScoreAwardedPerProgressStep' has a wrong offset!");
static_assert(offsetof(APushableActor, NetworkInterpolationSpeed) == 0x000430, "Member 'APushableActor::NetworkInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(APushableActor, NetworkInterpolationSpeedConstant) == 0x000434, "Member 'APushableActor::NetworkInterpolationSpeedConstant' has a wrong offset!");
static_assert(offsetof(APushableActor, bIsNetworkInterpolationConstant) == 0x000438, "Member 'APushableActor::bIsNetworkInterpolationConstant' has a wrong offset!");
static_assert(offsetof(APushableActor, ReplicatedProgress) == 0x00043A, "Member 'APushableActor::ReplicatedProgress' has a wrong offset!");
static_assert(offsetof(APushableActor, Progress) == 0x00043C, "Member 'APushableActor::Progress' has a wrong offset!");
static_assert(offsetof(APushableActor, Obstacle) == 0x000450, "Member 'APushableActor::Obstacle' has a wrong offset!");

// Class Mordhau.QuickthrowDrawMotion
// 0x0020 (0x00C0 - 0x00A0)
class UQuickthrowDrawMotion final : public UMordhauMotion
{
public:
	class AMordhauEquipment*                      RangedEquipment;                                   // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Slot;                                              // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Stage;                                             // 0x00A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FirstStageEnd;                                     // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondStageEnd;                                    // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThirdStageEnd;                                     // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasFiredLocally;                                  // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickthrowDrawMotion">();
	}
	static class UQuickthrowDrawMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickthrowDrawMotion>();
	}
};
static_assert(alignof(UQuickthrowDrawMotion) == 0x000008, "Wrong alignment on UQuickthrowDrawMotion");
static_assert(sizeof(UQuickthrowDrawMotion) == 0x0000C0, "Wrong size on UQuickthrowDrawMotion");
static_assert(offsetof(UQuickthrowDrawMotion, RangedEquipment) == 0x0000A0, "Member 'UQuickthrowDrawMotion::RangedEquipment' has a wrong offset!");
static_assert(offsetof(UQuickthrowDrawMotion, Slot) == 0x0000A8, "Member 'UQuickthrowDrawMotion::Slot' has a wrong offset!");
static_assert(offsetof(UQuickthrowDrawMotion, Stage) == 0x0000A9, "Member 'UQuickthrowDrawMotion::Stage' has a wrong offset!");
static_assert(offsetof(UQuickthrowDrawMotion, FirstStageEnd) == 0x0000AC, "Member 'UQuickthrowDrawMotion::FirstStageEnd' has a wrong offset!");
static_assert(offsetof(UQuickthrowDrawMotion, SecondStageEnd) == 0x0000B0, "Member 'UQuickthrowDrawMotion::SecondStageEnd' has a wrong offset!");
static_assert(offsetof(UQuickthrowDrawMotion, ThirdStageEnd) == 0x0000B4, "Member 'UQuickthrowDrawMotion::ThirdStageEnd' has a wrong offset!");
static_assert(offsetof(UQuickthrowDrawMotion, bHasFiredLocally) == 0x0000B8, "Member 'UQuickthrowDrawMotion::bHasFiredLocally' has a wrong offset!");

// Class Mordhau.QuickthrowReleaseMotion
// 0x0018 (0x00B8 - 0x00A0)
class UQuickthrowReleaseMotion final : public UMordhauMotion
{
public:
	class AMordhauEquipment*                      RangedEquipment;                                   // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauProjectile>      CreatedLocalProjectile;                            // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Stage;                                             // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FirstStageEnd;                                     // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickthrowReleaseMotion">();
	}
	static class UQuickthrowReleaseMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickthrowReleaseMotion>();
	}
};
static_assert(alignof(UQuickthrowReleaseMotion) == 0x000008, "Wrong alignment on UQuickthrowReleaseMotion");
static_assert(sizeof(UQuickthrowReleaseMotion) == 0x0000B8, "Wrong size on UQuickthrowReleaseMotion");
static_assert(offsetof(UQuickthrowReleaseMotion, RangedEquipment) == 0x0000A0, "Member 'UQuickthrowReleaseMotion::RangedEquipment' has a wrong offset!");
static_assert(offsetof(UQuickthrowReleaseMotion, CreatedLocalProjectile) == 0x0000A8, "Member 'UQuickthrowReleaseMotion::CreatedLocalProjectile' has a wrong offset!");
static_assert(offsetof(UQuickthrowReleaseMotion, Stage) == 0x0000B0, "Member 'UQuickthrowReleaseMotion::Stage' has a wrong offset!");
static_assert(offsetof(UQuickthrowReleaseMotion, FirstStageEnd) == 0x0000B4, "Member 'UQuickthrowReleaseMotion::FirstStageEnd' has a wrong offset!");

// Class Mordhau.Quiver
// 0x0048 (0x0070 - 0x0028)
class UQuiver : public UObject
{
public:
	class FName                                   AttachSocketName;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             AttachSocketTransform;                             // 0x0030(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    QuiverMeshes;                                      // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static TArray<class UStaticMesh*> GetQuiverMeshesForClass(TSubclassOf<class UQuiver> QuiverClass);

	class UStaticMesh* FindAppropriateQuiverMesh(uint8 Ammo, uint8 MaxAmmo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Quiver">();
	}
	static class UQuiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuiver>();
	}
};
static_assert(alignof(UQuiver) == 0x000010, "Wrong alignment on UQuiver");
static_assert(sizeof(UQuiver) == 0x000070, "Wrong size on UQuiver");
static_assert(offsetof(UQuiver, AttachSocketName) == 0x000028, "Member 'UQuiver::AttachSocketName' has a wrong offset!");
static_assert(offsetof(UQuiver, AttachSocketTransform) == 0x000030, "Member 'UQuiver::AttachSocketTransform' has a wrong offset!");
static_assert(offsetof(UQuiver, QuiverMeshes) == 0x000060, "Member 'UQuiver::QuiverMeshes' has a wrong offset!");

// Class Mordhau.RagdollFallingMotion
// 0x0008 (0x00A8 - 0x00A0)
class URagdollFallingMotion final : public UMordhauMotion
{
public:
	bool                                          bIsGettingUp;                                      // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RagdollFallingMotion">();
	}
	static class URagdollFallingMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<URagdollFallingMotion>();
	}
};
static_assert(alignof(URagdollFallingMotion) == 0x000008, "Wrong alignment on URagdollFallingMotion");
static_assert(sizeof(URagdollFallingMotion) == 0x0000A8, "Wrong size on URagdollFallingMotion");
static_assert(offsetof(URagdollFallingMotion, bIsGettingUp) == 0x0000A0, "Member 'URagdollFallingMotion::bIsGettingUp' has a wrong offset!");

// Class Mordhau.RangedDrawMotion
// 0x00B0 (0x0150 - 0x00A0)
class URangedDrawMotion : public UMordhauMotion
{
public:
	uint8                                         Pad_A0[0x30];                                      // 0x00A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         RandomValue;                                       // 0x00D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AimRotationOffset;                                 // 0x00D4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0xC];                                       // 0x00E0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AimVisualRotationOffset;                           // 0x00EC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauEquipment>       RangedEquipmentPtr;                                // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           DrawMontage;                                       // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Draw1PMontage;                                     // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DrawEquipmentMontage;                              // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DrawEquipment1PMontage;                            // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CurrentMontage;                                    // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CurrentEquipmentMontage;                           // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        CurrentlyPlayingDraw;                              // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangedDrawMotion">();
	}
	static class URangedDrawMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangedDrawMotion>();
	}
};
static_assert(alignof(URangedDrawMotion) == 0x000008, "Wrong alignment on URangedDrawMotion");
static_assert(sizeof(URangedDrawMotion) == 0x000150, "Wrong size on URangedDrawMotion");
static_assert(offsetof(URangedDrawMotion, RandomValue) == 0x0000D0, "Member 'URangedDrawMotion::RandomValue' has a wrong offset!");
static_assert(offsetof(URangedDrawMotion, AimRotationOffset) == 0x0000D4, "Member 'URangedDrawMotion::AimRotationOffset' has a wrong offset!");
static_assert(offsetof(URangedDrawMotion, AimVisualRotationOffset) == 0x0000EC, "Member 'URangedDrawMotion::AimVisualRotationOffset' has a wrong offset!");
static_assert(offsetof(URangedDrawMotion, RangedEquipmentPtr) == 0x0000F8, "Member 'URangedDrawMotion::RangedEquipmentPtr' has a wrong offset!");
static_assert(offsetof(URangedDrawMotion, DrawMontage) == 0x000108, "Member 'URangedDrawMotion::DrawMontage' has a wrong offset!");
static_assert(offsetof(URangedDrawMotion, Draw1PMontage) == 0x000110, "Member 'URangedDrawMotion::Draw1PMontage' has a wrong offset!");
static_assert(offsetof(URangedDrawMotion, DrawEquipmentMontage) == 0x000118, "Member 'URangedDrawMotion::DrawEquipmentMontage' has a wrong offset!");
static_assert(offsetof(URangedDrawMotion, DrawEquipment1PMontage) == 0x000120, "Member 'URangedDrawMotion::DrawEquipment1PMontage' has a wrong offset!");
static_assert(offsetof(URangedDrawMotion, CurrentMontage) == 0x000128, "Member 'URangedDrawMotion::CurrentMontage' has a wrong offset!");
static_assert(offsetof(URangedDrawMotion, CurrentEquipmentMontage) == 0x000130, "Member 'URangedDrawMotion::CurrentEquipmentMontage' has a wrong offset!");
static_assert(offsetof(URangedDrawMotion, CurrentlyPlayingDraw) == 0x000148, "Member 'URangedDrawMotion::CurrentlyPlayingDraw' has a wrong offset!");

// Class Mordhau.RangedReleaseMotion
// 0x0050 (0x00F0 - 0x00A0)
class URangedReleaseMotion : public UMordhauMotion
{
public:
	TWeakObjectPtr<class AMordhauEquipment>       RangedEquipment;                                   // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AMordhauEquipment>          RangedEquipmentClass;                              // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AMordhauProjectile>      CreatedLocalProjectile;                            // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CurrentMontage;                                    // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CurrentEquipmentMontage;                           // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ReleaseMontage;                                    // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Release1PMontage;                                  // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReleaseEquipmentMontage;                           // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReleaseEquipment1PMontage;                         // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangedReleaseMotion">();
	}
	static class URangedReleaseMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangedReleaseMotion>();
	}
};
static_assert(alignof(URangedReleaseMotion) == 0x000008, "Wrong alignment on URangedReleaseMotion");
static_assert(sizeof(URangedReleaseMotion) == 0x0000F0, "Wrong size on URangedReleaseMotion");
static_assert(offsetof(URangedReleaseMotion, RangedEquipment) == 0x0000A0, "Member 'URangedReleaseMotion::RangedEquipment' has a wrong offset!");
static_assert(offsetof(URangedReleaseMotion, RangedEquipmentClass) == 0x0000A8, "Member 'URangedReleaseMotion::RangedEquipmentClass' has a wrong offset!");
static_assert(offsetof(URangedReleaseMotion, CreatedLocalProjectile) == 0x0000B0, "Member 'URangedReleaseMotion::CreatedLocalProjectile' has a wrong offset!");
static_assert(offsetof(URangedReleaseMotion, CurrentMontage) == 0x0000B8, "Member 'URangedReleaseMotion::CurrentMontage' has a wrong offset!");
static_assert(offsetof(URangedReleaseMotion, CurrentEquipmentMontage) == 0x0000C0, "Member 'URangedReleaseMotion::CurrentEquipmentMontage' has a wrong offset!");
static_assert(offsetof(URangedReleaseMotion, ReleaseMontage) == 0x0000D0, "Member 'URangedReleaseMotion::ReleaseMontage' has a wrong offset!");
static_assert(offsetof(URangedReleaseMotion, Release1PMontage) == 0x0000D8, "Member 'URangedReleaseMotion::Release1PMontage' has a wrong offset!");
static_assert(offsetof(URangedReleaseMotion, ReleaseEquipmentMontage) == 0x0000E0, "Member 'URangedReleaseMotion::ReleaseEquipmentMontage' has a wrong offset!");
static_assert(offsetof(URangedReleaseMotion, ReleaseEquipment1PMontage) == 0x0000E8, "Member 'URangedReleaseMotion::ReleaseEquipment1PMontage' has a wrong offset!");

// Class Mordhau.RconFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class URconFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UPlayFabJsonValue* GenerateRconParameterValue(struct FRconParameter* RconParameter);
	static class UPlayFabJsonObject* GenerateRequestInfoResponseObject(struct FRconRequestInfoResponse* RconRequestInfoResponse);
	static class UPlayFabJsonObject* GenerateResponseObject(struct FRconResponseStruct* RconResponse);
	static class FString GetJsonTypeAsString(EPFJson Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RconFunctionLibrary">();
	}
	static class URconFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<URconFunctionLibrary>();
	}
};
static_assert(alignof(URconFunctionLibrary) == 0x000008, "Wrong alignment on URconFunctionLibrary");
static_assert(sizeof(URconFunctionLibrary) == 0x000028, "Wrong size on URconFunctionLibrary");

// Class Mordhau.RconTypes
// 0x0000 (0x0028 - 0x0028)
class URconTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RconTypes">();
	}
	static class URconTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<URconTypes>();
	}
};
static_assert(alignof(URconTypes) == 0x000008, "Wrong alignment on URconTypes");
static_assert(sizeof(URconTypes) == 0x000028, "Wrong size on URconTypes");

// Class Mordhau.ReloadMotion
// 0x0050 (0x00F0 - 0x00A0)
class UReloadMotion : public UMordhauMotion
{
public:
	TWeakObjectPtr<class AMordhauEquipment>       RangedEquipment;                                   // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CurrentMontage;                                    // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CurrentEquipmentMontage;                           // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReloadMontage;                                     // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Reload1PMontage;                                   // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReloadEquipmentMontage;                            // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Reload1PEquipmentMontage;                          // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         CurrentReloadSound;                                // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReachTime;                                         // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadTime;                                        // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReloadMotion">();
	}
	static class UReloadMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReloadMotion>();
	}
};
static_assert(alignof(UReloadMotion) == 0x000008, "Wrong alignment on UReloadMotion");
static_assert(sizeof(UReloadMotion) == 0x0000F0, "Wrong size on UReloadMotion");
static_assert(offsetof(UReloadMotion, RangedEquipment) == 0x0000A0, "Member 'UReloadMotion::RangedEquipment' has a wrong offset!");
static_assert(offsetof(UReloadMotion, CurrentMontage) == 0x0000A8, "Member 'UReloadMotion::CurrentMontage' has a wrong offset!");
static_assert(offsetof(UReloadMotion, CurrentEquipmentMontage) == 0x0000B0, "Member 'UReloadMotion::CurrentEquipmentMontage' has a wrong offset!");
static_assert(offsetof(UReloadMotion, ReloadMontage) == 0x0000B8, "Member 'UReloadMotion::ReloadMontage' has a wrong offset!");
static_assert(offsetof(UReloadMotion, Reload1PMontage) == 0x0000C0, "Member 'UReloadMotion::Reload1PMontage' has a wrong offset!");
static_assert(offsetof(UReloadMotion, ReloadEquipmentMontage) == 0x0000C8, "Member 'UReloadMotion::ReloadEquipmentMontage' has a wrong offset!");
static_assert(offsetof(UReloadMotion, Reload1PEquipmentMontage) == 0x0000D0, "Member 'UReloadMotion::Reload1PEquipmentMontage' has a wrong offset!");
static_assert(offsetof(UReloadMotion, CurrentReloadSound) == 0x0000D8, "Member 'UReloadMotion::CurrentReloadSound' has a wrong offset!");
static_assert(offsetof(UReloadMotion, ReachTime) == 0x0000E8, "Member 'UReloadMotion::ReachTime' has a wrong offset!");
static_assert(offsetof(UReloadMotion, ReloadTime) == 0x0000EC, "Member 'UReloadMotion::ReloadTime' has a wrong offset!");

// Class Mordhau.SeparatedBodyPart
// 0x0118 (0x0338 - 0x0220)
class ASeparatedBodyPart : public AActor
{
public:
	class ULODSkeletalMeshComponent*              Mesh;                                              // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkeletalMeshAsset;                                 // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APhysicsConstraintActor> PhysicsConstraintActor;                            // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AAdvancedCharacter>      SourceCharacter;                                   // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          HeadPhysicsAsset;                                  // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          LeftArmPhysicsAsset;                               // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          LeftForearmPhysicsAsset;                           // 0x0250(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          LeftHandPhysicsAsset;                              // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          RightArmPhysicsAsset;                              // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          RightForearmPhysicsAsset;                          // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          RightHandPhysicsAsset;                             // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          LeftUpLegPhysicsAsset;                             // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          LeftLegPhysicsAsset;                               // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          LeftFootPhysicsAsset;                              // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          RightUpLegPhysicsAsset;                            // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          RightLegPhysicsAsset;                              // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          RightFootPhysicsAsset;                             // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGoreActor>                 InGoreMesh;                                        // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGoreActor>                 InGoreMeshBlunt;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGoreActor>                 InGoreMeshHead;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FakeRootBone;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AActor>>          InstancedGoreMeshes;                               // 0x02C8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x60];                                     // 0x02D8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeDismemberment(class AMordhauCharacter* Source, class FName bone, const struct FTransform& SourceBoneTransform, bool bIsPartial, bool bIsBluntForce);
	bool IsDismembered(class FName bone);
	void OnCosmeticHit(EMordhauDamageType DamageType, uint8 SubType, const struct FHitResult& Hit, class AActor* Agent);

	bool IsPartiallyDismembered() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeparatedBodyPart">();
	}
	static class ASeparatedBodyPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASeparatedBodyPart>();
	}
};
static_assert(alignof(ASeparatedBodyPart) == 0x000008, "Wrong alignment on ASeparatedBodyPart");
static_assert(sizeof(ASeparatedBodyPart) == 0x000338, "Wrong size on ASeparatedBodyPart");
static_assert(offsetof(ASeparatedBodyPart, Mesh) == 0x000220, "Member 'ASeparatedBodyPart::Mesh' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, SkeletalMeshAsset) == 0x000228, "Member 'ASeparatedBodyPart::SkeletalMeshAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, PhysicsConstraintActor) == 0x000230, "Member 'ASeparatedBodyPart::PhysicsConstraintActor' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, SourceCharacter) == 0x000238, "Member 'ASeparatedBodyPart::SourceCharacter' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, HeadPhysicsAsset) == 0x000240, "Member 'ASeparatedBodyPart::HeadPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, LeftArmPhysicsAsset) == 0x000248, "Member 'ASeparatedBodyPart::LeftArmPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, LeftForearmPhysicsAsset) == 0x000250, "Member 'ASeparatedBodyPart::LeftForearmPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, LeftHandPhysicsAsset) == 0x000258, "Member 'ASeparatedBodyPart::LeftHandPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, RightArmPhysicsAsset) == 0x000260, "Member 'ASeparatedBodyPart::RightArmPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, RightForearmPhysicsAsset) == 0x000268, "Member 'ASeparatedBodyPart::RightForearmPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, RightHandPhysicsAsset) == 0x000270, "Member 'ASeparatedBodyPart::RightHandPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, LeftUpLegPhysicsAsset) == 0x000278, "Member 'ASeparatedBodyPart::LeftUpLegPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, LeftLegPhysicsAsset) == 0x000280, "Member 'ASeparatedBodyPart::LeftLegPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, LeftFootPhysicsAsset) == 0x000288, "Member 'ASeparatedBodyPart::LeftFootPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, RightUpLegPhysicsAsset) == 0x000290, "Member 'ASeparatedBodyPart::RightUpLegPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, RightLegPhysicsAsset) == 0x000298, "Member 'ASeparatedBodyPart::RightLegPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, RightFootPhysicsAsset) == 0x0002A0, "Member 'ASeparatedBodyPart::RightFootPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, InGoreMesh) == 0x0002A8, "Member 'ASeparatedBodyPart::InGoreMesh' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, InGoreMeshBlunt) == 0x0002B0, "Member 'ASeparatedBodyPart::InGoreMeshBlunt' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, InGoreMeshHead) == 0x0002B8, "Member 'ASeparatedBodyPart::InGoreMeshHead' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, FakeRootBone) == 0x0002C0, "Member 'ASeparatedBodyPart::FakeRootBone' has a wrong offset!");
static_assert(offsetof(ASeparatedBodyPart, InstancedGoreMeshes) == 0x0002C8, "Member 'ASeparatedBodyPart::InstancedGoreMeshes' has a wrong offset!");

// Class Mordhau.SeparatedBodyPartAnimInstance
// 0x0020 (0x02E0 - 0x02C0)
class USeparatedBodyPartAnimInstance : public UAnimInstance
{
public:
	class USkeletalMeshComponent*                 CharacterMeshComponent;                            // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeftForeArmDismembered;                         // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRightForeArmDismembered;                        // 0x02C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeftLegDismembered;                             // 0x02C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRightLegDismembered;                            // 0x02C3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeftFootDismembered;                            // 0x02C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRightFootDismembered;                           // 0x02C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLeftHandDismembered;                            // 0x02C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRightHandDismembered;                           // 0x02C7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootIsHead;                                       // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootIsLeftArm;                                    // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootIsLeftForeArm;                                // 0x02CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootIsLeftHand;                                   // 0x02CB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootIsRightArm;                                   // 0x02CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootIsRightForeArm;                               // 0x02CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootIsRightHand;                                  // 0x02CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootIsLeftUpLeg;                                  // 0x02CF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootIsLeftLeg;                                    // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootIsLeftFoot;                                   // 0x02D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootIsRightUpLeg;                                 // 0x02D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootIsRightLeg;                                   // 0x02D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRootIsRightFoot;                                  // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D5[0xB];                                      // 0x02D5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeparatedBodyPartAnimInstance">();
	}
	static class USeparatedBodyPartAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeparatedBodyPartAnimInstance>();
	}
};
static_assert(alignof(USeparatedBodyPartAnimInstance) == 0x000010, "Wrong alignment on USeparatedBodyPartAnimInstance");
static_assert(sizeof(USeparatedBodyPartAnimInstance) == 0x0002E0, "Wrong size on USeparatedBodyPartAnimInstance");
static_assert(offsetof(USeparatedBodyPartAnimInstance, CharacterMeshComponent) == 0x0002B8, "Member 'USeparatedBodyPartAnimInstance::CharacterMeshComponent' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bIsLeftForeArmDismembered) == 0x0002C0, "Member 'USeparatedBodyPartAnimInstance::bIsLeftForeArmDismembered' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bIsRightForeArmDismembered) == 0x0002C1, "Member 'USeparatedBodyPartAnimInstance::bIsRightForeArmDismembered' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bIsLeftLegDismembered) == 0x0002C2, "Member 'USeparatedBodyPartAnimInstance::bIsLeftLegDismembered' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bIsRightLegDismembered) == 0x0002C3, "Member 'USeparatedBodyPartAnimInstance::bIsRightLegDismembered' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bIsLeftFootDismembered) == 0x0002C4, "Member 'USeparatedBodyPartAnimInstance::bIsLeftFootDismembered' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bIsRightFootDismembered) == 0x0002C5, "Member 'USeparatedBodyPartAnimInstance::bIsRightFootDismembered' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bIsLeftHandDismembered) == 0x0002C6, "Member 'USeparatedBodyPartAnimInstance::bIsLeftHandDismembered' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bIsRightHandDismembered) == 0x0002C7, "Member 'USeparatedBodyPartAnimInstance::bIsRightHandDismembered' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bRootIsHead) == 0x0002C8, "Member 'USeparatedBodyPartAnimInstance::bRootIsHead' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bRootIsLeftArm) == 0x0002C9, "Member 'USeparatedBodyPartAnimInstance::bRootIsLeftArm' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bRootIsLeftForeArm) == 0x0002CA, "Member 'USeparatedBodyPartAnimInstance::bRootIsLeftForeArm' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bRootIsLeftHand) == 0x0002CB, "Member 'USeparatedBodyPartAnimInstance::bRootIsLeftHand' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bRootIsRightArm) == 0x0002CC, "Member 'USeparatedBodyPartAnimInstance::bRootIsRightArm' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bRootIsRightForeArm) == 0x0002CD, "Member 'USeparatedBodyPartAnimInstance::bRootIsRightForeArm' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bRootIsRightHand) == 0x0002CE, "Member 'USeparatedBodyPartAnimInstance::bRootIsRightHand' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bRootIsLeftUpLeg) == 0x0002CF, "Member 'USeparatedBodyPartAnimInstance::bRootIsLeftUpLeg' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bRootIsLeftLeg) == 0x0002D0, "Member 'USeparatedBodyPartAnimInstance::bRootIsLeftLeg' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bRootIsLeftFoot) == 0x0002D1, "Member 'USeparatedBodyPartAnimInstance::bRootIsLeftFoot' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bRootIsRightUpLeg) == 0x0002D2, "Member 'USeparatedBodyPartAnimInstance::bRootIsRightUpLeg' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bRootIsRightLeg) == 0x0002D3, "Member 'USeparatedBodyPartAnimInstance::bRootIsRightLeg' has a wrong offset!");
static_assert(offsetof(USeparatedBodyPartAnimInstance, bRootIsRightFoot) == 0x0002D4, "Member 'USeparatedBodyPartAnimInstance::bRootIsRightFoot' has a wrong offset!");

// Class Mordhau.SkeletalMeshCapturePointBanner
// 0x0070 (0x02B8 - 0x0248)
class ASkeletalMeshCapturePointBanner final : public ACapturePointBanner
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        CapturingAudioComponent;                           // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              RaisingSound;                                      // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              LoweringSound;                                     // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddWindActor;                                     // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WindDisabledIfLessThanProgress;                    // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindStrength;                                      // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindSpeed;                                         // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindRadius;                                        // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindMinGustAmount;                                 // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindMaxGustAmount;                                 // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentWindSpeed;                                  // 0x0284(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWindDirectionalSource*                 WindActor;                                         // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        WavingAudioComponent;                              // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AudioVolumeByProgressIn;                           // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AudioVolumeByProgressOut;                          // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AudioPitchByProgressIn;                            // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AudioPitchByProgressOut;                           // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalMeshCapturePointBanner">();
	}
	static class ASkeletalMeshCapturePointBanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkeletalMeshCapturePointBanner>();
	}
};
static_assert(alignof(ASkeletalMeshCapturePointBanner) == 0x000008, "Wrong alignment on ASkeletalMeshCapturePointBanner");
static_assert(sizeof(ASkeletalMeshCapturePointBanner) == 0x0002B8, "Wrong size on ASkeletalMeshCapturePointBanner");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, SkeletalMeshComponent) == 0x000248, "Member 'ASkeletalMeshCapturePointBanner::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, CapturingAudioComponent) == 0x000250, "Member 'ASkeletalMeshCapturePointBanner::CapturingAudioComponent' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, RaisingSound) == 0x000258, "Member 'ASkeletalMeshCapturePointBanner::RaisingSound' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, LoweringSound) == 0x000260, "Member 'ASkeletalMeshCapturePointBanner::LoweringSound' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, bAddWindActor) == 0x000268, "Member 'ASkeletalMeshCapturePointBanner::bAddWindActor' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, WindDisabledIfLessThanProgress) == 0x00026C, "Member 'ASkeletalMeshCapturePointBanner::WindDisabledIfLessThanProgress' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, WindStrength) == 0x000270, "Member 'ASkeletalMeshCapturePointBanner::WindStrength' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, WindSpeed) == 0x000274, "Member 'ASkeletalMeshCapturePointBanner::WindSpeed' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, WindRadius) == 0x000278, "Member 'ASkeletalMeshCapturePointBanner::WindRadius' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, WindMinGustAmount) == 0x00027C, "Member 'ASkeletalMeshCapturePointBanner::WindMinGustAmount' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, WindMaxGustAmount) == 0x000280, "Member 'ASkeletalMeshCapturePointBanner::WindMaxGustAmount' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, CurrentWindSpeed) == 0x000284, "Member 'ASkeletalMeshCapturePointBanner::CurrentWindSpeed' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, WindActor) == 0x000288, "Member 'ASkeletalMeshCapturePointBanner::WindActor' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, WavingAudioComponent) == 0x000290, "Member 'ASkeletalMeshCapturePointBanner::WavingAudioComponent' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, AudioVolumeByProgressIn) == 0x000298, "Member 'ASkeletalMeshCapturePointBanner::AudioVolumeByProgressIn' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, AudioVolumeByProgressOut) == 0x0002A0, "Member 'ASkeletalMeshCapturePointBanner::AudioVolumeByProgressOut' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, AudioPitchByProgressIn) == 0x0002A8, "Member 'ASkeletalMeshCapturePointBanner::AudioPitchByProgressIn' has a wrong offset!");
static_assert(offsetof(ASkeletalMeshCapturePointBanner, AudioPitchByProgressOut) == 0x0002B0, "Member 'ASkeletalMeshCapturePointBanner::AudioPitchByProgressOut' has a wrong offset!");

// Class Mordhau.SkeletalMeshMordhauActor
// 0x0010 (0x03F0 - 0x03E0)
class ASkeletalMeshMordhauActor : public AMordhauActor
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalMeshMordhauActor">();
	}
	static class ASkeletalMeshMordhauActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkeletalMeshMordhauActor>();
	}
};
static_assert(alignof(ASkeletalMeshMordhauActor) == 0x000010, "Wrong alignment on ASkeletalMeshMordhauActor");
static_assert(sizeof(ASkeletalMeshMordhauActor) == 0x0003F0, "Wrong size on ASkeletalMeshMordhauActor");
static_assert(offsetof(ASkeletalMeshMordhauActor, SkeletalMeshComponent) == 0x0003E0, "Member 'ASkeletalMeshMordhauActor::SkeletalMeshComponent' has a wrong offset!");

// Class Mordhau.SlaveProgressDriver
// 0x0000 (0x03E0 - 0x03E0)
class ASlaveProgressDriver final : public AProgressDriver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlaveProgressDriver">();
	}
	static class ASlaveProgressDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASlaveProgressDriver>();
	}
};
static_assert(alignof(ASlaveProgressDriver) == 0x000010, "Wrong alignment on ASlaveProgressDriver");
static_assert(sizeof(ASlaveProgressDriver) == 0x0003E0, "Wrong size on ASlaveProgressDriver");

// Class Mordhau.SpawnGroup
// 0x0018 (0x0238 - 0x0220)
class ASpawnGroup final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AMordhauPlayerStart*>            Spawns;                                            // 0x0228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void SetAreSpawnsEnabled(bool bValue);
	void SetSpawnsTeam(int32 NewTeam);

	bool GetAreSpawnsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnGroup">();
	}
	static class ASpawnGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnGroup>();
	}
};
static_assert(alignof(ASpawnGroup) == 0x000008, "Wrong alignment on ASpawnGroup");
static_assert(sizeof(ASpawnGroup) == 0x000238, "Wrong size on ASpawnGroup");
static_assert(offsetof(ASpawnGroup, Spawns) == 0x000228, "Member 'ASpawnGroup::Spawns' has a wrong offset!");

// Class Mordhau.SplineAudio
// 0x0058 (0x0278 - 0x0220)
class ASplineAudio final : public AActor
{
public:
	float                                         MinDistance;                                       // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumInterpFrames;                                   // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve;                                             // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x28];                                     // 0x0230(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      PC;                                                // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        Root;                                              // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       Spline;                                            // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        AudioComp;                                         // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnActivate();
	void OnDeactivate();
	void SetCurve(class UCurveFloat* InCurve);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineAudio">();
	}
	static class ASplineAudio* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineAudio>();
	}
};
static_assert(alignof(ASplineAudio) == 0x000008, "Wrong alignment on ASplineAudio");
static_assert(sizeof(ASplineAudio) == 0x000278, "Wrong size on ASplineAudio");
static_assert(offsetof(ASplineAudio, MinDistance) == 0x000220, "Member 'ASplineAudio::MinDistance' has a wrong offset!");
static_assert(offsetof(ASplineAudio, NumInterpFrames) == 0x000224, "Member 'ASplineAudio::NumInterpFrames' has a wrong offset!");
static_assert(offsetof(ASplineAudio, Curve) == 0x000228, "Member 'ASplineAudio::Curve' has a wrong offset!");
static_assert(offsetof(ASplineAudio, PC) == 0x000258, "Member 'ASplineAudio::PC' has a wrong offset!");
static_assert(offsetof(ASplineAudio, Root) == 0x000260, "Member 'ASplineAudio::Root' has a wrong offset!");
static_assert(offsetof(ASplineAudio, Spline) == 0x000268, "Member 'ASplineAudio::Spline' has a wrong offset!");
static_assert(offsetof(ASplineAudio, AudioComp) == 0x000270, "Member 'ASplineAudio::AudioComp' has a wrong offset!");

// Class Mordhau.SquadInfo
// 0x0070 (0x00A0 - 0x0030)
class USquadInfo final : public UDataAsset
{
public:
	uint8                                         SquadID;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToSquadPool;                                   // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnMinWave;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnMaxWave;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSquadsPerWave;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Difficulty;                                        // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DelayBeforeSpawn;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      Members;                                           // 0x0048(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         SpawnOrderWeight;                                  // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadInfo">();
	}
	static class USquadInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquadInfo>();
	}
};
static_assert(alignof(USquadInfo) == 0x000008, "Wrong alignment on USquadInfo");
static_assert(sizeof(USquadInfo) == 0x0000A0, "Wrong size on USquadInfo");
static_assert(offsetof(USquadInfo, SquadID) == 0x000030, "Member 'USquadInfo::SquadID' has a wrong offset!");
static_assert(offsetof(USquadInfo, bAddToSquadPool) == 0x000031, "Member 'USquadInfo::bAddToSquadPool' has a wrong offset!");
static_assert(offsetof(USquadInfo, SpawnMinWave) == 0x000034, "Member 'USquadInfo::SpawnMinWave' has a wrong offset!");
static_assert(offsetof(USquadInfo, SpawnMaxWave) == 0x000038, "Member 'USquadInfo::SpawnMaxWave' has a wrong offset!");
static_assert(offsetof(USquadInfo, MaxSquadsPerWave) == 0x00003C, "Member 'USquadInfo::MaxSquadsPerWave' has a wrong offset!");
static_assert(offsetof(USquadInfo, Difficulty) == 0x000040, "Member 'USquadInfo::Difficulty' has a wrong offset!");
static_assert(offsetof(USquadInfo, DelayBeforeSpawn) == 0x000044, "Member 'USquadInfo::DelayBeforeSpawn' has a wrong offset!");
static_assert(offsetof(USquadInfo, Members) == 0x000048, "Member 'USquadInfo::Members' has a wrong offset!");
static_assert(offsetof(USquadInfo, SpawnOrderWeight) == 0x000098, "Member 'USquadInfo::SpawnOrderWeight' has a wrong offset!");

// Class Mordhau.StabMotion
// 0x0018 (0x1118 - 0x1100)
class UStabMotion : public UAttackMotion
{
public:
	struct FRotator                               AnimAngleCueAmount;                                // 0x1100(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_110C[0x4];                                     // 0x110C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AnimAngleCurve;                                    // 0x1110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StabMotion">();
	}
	static class UStabMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStabMotion>();
	}
};
static_assert(alignof(UStabMotion) == 0x000008, "Wrong alignment on UStabMotion");
static_assert(sizeof(UStabMotion) == 0x001118, "Wrong size on UStabMotion");
static_assert(offsetof(UStabMotion, AnimAngleCueAmount) == 0x001100, "Member 'UStabMotion::AnimAngleCueAmount' has a wrong offset!");
static_assert(offsetof(UStabMotion, AnimAngleCurve) == 0x001110, "Member 'UStabMotion::AnimAngleCurve' has a wrong offset!");

// Class Mordhau.StaminaStatComponent
// 0x0018 (0x00F0 - 0x00D8)
class UStaminaStatComponent final : public UStatComponent
{
public:
	bool                                          bPlaysOutOfBreathSound;                            // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BreathingSoundPlayBelowStamina;                    // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreathingSoundMaxDistance;                         // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         LastBreath;                                        // 0x00E4(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterDied(class AAdvancedCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaminaStatComponent">();
	}
	static class UStaminaStatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaminaStatComponent>();
	}
};
static_assert(alignof(UStaminaStatComponent) == 0x000008, "Wrong alignment on UStaminaStatComponent");
static_assert(sizeof(UStaminaStatComponent) == 0x0000F0, "Wrong size on UStaminaStatComponent");
static_assert(offsetof(UStaminaStatComponent, bPlaysOutOfBreathSound) == 0x0000D8, "Member 'UStaminaStatComponent::bPlaysOutOfBreathSound' has a wrong offset!");
static_assert(offsetof(UStaminaStatComponent, BreathingSoundPlayBelowStamina) == 0x0000DC, "Member 'UStaminaStatComponent::BreathingSoundPlayBelowStamina' has a wrong offset!");
static_assert(offsetof(UStaminaStatComponent, BreathingSoundMaxDistance) == 0x0000E0, "Member 'UStaminaStatComponent::BreathingSoundMaxDistance' has a wrong offset!");
static_assert(offsetof(UStaminaStatComponent, LastBreath) == 0x0000E4, "Member 'UStaminaStatComponent::LastBreath' has a wrong offset!");

// Class Mordhau.StaticMeshCapturePointBanner
// 0x0008 (0x0250 - 0x0248)
class AStaticMeshCapturePointBanner final : public ACapturePointBanner
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshCapturePointBanner">();
	}
	static class AStaticMeshCapturePointBanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticMeshCapturePointBanner>();
	}
};
static_assert(alignof(AStaticMeshCapturePointBanner) == 0x000008, "Wrong alignment on AStaticMeshCapturePointBanner");
static_assert(sizeof(AStaticMeshCapturePointBanner) == 0x000250, "Wrong size on AStaticMeshCapturePointBanner");
static_assert(offsetof(AStaticMeshCapturePointBanner, StaticMeshComponent) == 0x000248, "Member 'AStaticMeshCapturePointBanner::StaticMeshComponent' has a wrong offset!");

// Class Mordhau.StaticMeshMordhauActor
// 0x0010 (0x03F0 - 0x03E0)
class AStaticMeshMordhauActor final : public AMordhauActor
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshMordhauActor">();
	}
	static class AStaticMeshMordhauActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticMeshMordhauActor>();
	}
};
static_assert(alignof(AStaticMeshMordhauActor) == 0x000010, "Wrong alignment on AStaticMeshMordhauActor");
static_assert(sizeof(AStaticMeshMordhauActor) == 0x0003F0, "Wrong size on AStaticMeshMordhauActor");
static_assert(offsetof(AStaticMeshMordhauActor, StaticMeshComponent) == 0x0003E0, "Member 'AStaticMeshMordhauActor::StaticMeshComponent' has a wrong offset!");

// Class Mordhau.StunMotion
// 0x0028 (0x00C8 - 0x00A0)
class UStunMotion : public UMordhauMotion
{
public:
	bool                                          bWillDisarm;                                       // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StunGracePeriodExtraTime;                          // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunDuration;                                      // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatineeCameraShake>        StunShakeEffect;                                   // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPerspectiveAnimMontage                Animation;                                         // 0x00B8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StunMotion">();
	}
	static class UStunMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStunMotion>();
	}
};
static_assert(alignof(UStunMotion) == 0x000008, "Wrong alignment on UStunMotion");
static_assert(sizeof(UStunMotion) == 0x0000C8, "Wrong size on UStunMotion");
static_assert(offsetof(UStunMotion, bWillDisarm) == 0x0000A0, "Member 'UStunMotion::bWillDisarm' has a wrong offset!");
static_assert(offsetof(UStunMotion, StunGracePeriodExtraTime) == 0x0000A4, "Member 'UStunMotion::StunGracePeriodExtraTime' has a wrong offset!");
static_assert(offsetof(UStunMotion, StunDuration) == 0x0000A8, "Member 'UStunMotion::StunDuration' has a wrong offset!");
static_assert(offsetof(UStunMotion, StunShakeEffect) == 0x0000B0, "Member 'UStunMotion::StunShakeEffect' has a wrong offset!");
static_assert(offsetof(UStunMotion, Animation) == 0x0000B8, "Member 'UStunMotion::Animation' has a wrong offset!");

// Class Mordhau.TagSystemComponent
// 0x0070 (0x0120 - 0x00B0)
class UTagSystemComponent final : public UActorComponent
{
public:
	struct FGameplayTagContainer                  OwnTags;                                           // 0x00B0(0x0020)(NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Tags;                                              // 0x00D0(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TArray<class UTagSystemComponent*>            ParentTagSystemComponents;                         // 0x00F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UTagSystemComponent*>            ChildrenTagSystemComponents;                       // 0x0100(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTagConditionDelegate>  ConditionDelegates;                                // 0x0110(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void AddAndRemoveTag(const struct FGameplayTag& TagToAdd, const struct FGameplayTag& TagToRemove);
	void AddAndRemoveTags(const struct FGameplayTagContainer& TagsToAdd, const struct FGameplayTagContainer& TagsToRemove);
	void AddTag(const struct FGameplayTag& Tag);
	void AddTags(const struct FGameplayTagContainer& TagContainer);
	void FlashTag(const struct FGameplayTag& Tag);
	void FlashTags(const struct FGameplayTagContainer& TagContainer);
	void RegisterTagConditionDelegate(const struct FGameplayTagCondition& Condition, class UObject* Object, class FName Function);
	void RemoveTag(const struct FGameplayTag& Tag);
	void RemoveTags(const struct FGameplayTagContainer& TagContainer);
	void SetTags(const struct FGameplayTagContainer& TagContainer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TagSystemComponent">();
	}
	static class UTagSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTagSystemComponent>();
	}
};
static_assert(alignof(UTagSystemComponent) == 0x000008, "Wrong alignment on UTagSystemComponent");
static_assert(sizeof(UTagSystemComponent) == 0x000120, "Wrong size on UTagSystemComponent");
static_assert(offsetof(UTagSystemComponent, OwnTags) == 0x0000B0, "Member 'UTagSystemComponent::OwnTags' has a wrong offset!");
static_assert(offsetof(UTagSystemComponent, Tags) == 0x0000D0, "Member 'UTagSystemComponent::Tags' has a wrong offset!");
static_assert(offsetof(UTagSystemComponent, ParentTagSystemComponents) == 0x0000F0, "Member 'UTagSystemComponent::ParentTagSystemComponents' has a wrong offset!");
static_assert(offsetof(UTagSystemComponent, ChildrenTagSystemComponents) == 0x000100, "Member 'UTagSystemComponent::ChildrenTagSystemComponents' has a wrong offset!");
static_assert(offsetof(UTagSystemComponent, ConditionDelegates) == 0x000110, "Member 'UTagSystemComponent::ConditionDelegates' has a wrong offset!");

// Class Mordhau.TeleportCommand
// 0x0000 (0x0080 - 0x0080)
class UTeleportCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeleportCommand">();
	}
	static class UTeleportCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeleportCommand>();
	}
};
static_assert(alignof(UTeleportCommand) == 0x000008, "Wrong alignment on UTeleportCommand");
static_assert(sizeof(UTeleportCommand) == 0x000080, "Wrong size on UTeleportCommand");

// Class Mordhau.TestRconCommand
// 0x0000 (0x0080 - 0x0080)
class UTestRconCommand final : public URconCommand
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestRconCommand">();
	}
	static class UTestRconCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestRconCommand>();
	}
};
static_assert(alignof(UTestRconCommand) == 0x000008, "Wrong alignment on UTestRconCommand");
static_assert(sizeof(UTestRconCommand) == 0x000080, "Wrong size on UTestRconCommand");

// Class Mordhau.ThudderComponent
// 0x0040 (0x00F0 - 0x00B0)
class UThudderComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnThud;                                            // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bOnlyIfBoneIsSimulatingPhysics;                    // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    MonitoredComponent;                                // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MonitoredBone;                                     // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenThuds;                               // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThudMinVelocityThreshold;                          // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextThudTime;                                      // 0x00E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousVelocity;                                  // 0x00E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentVelocity;                                   // 0x00E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasValidVelocity;                                 // 0x00EC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoTick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThudderComponent">();
	}
	static class UThudderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThudderComponent>();
	}
};
static_assert(alignof(UThudderComponent) == 0x000008, "Wrong alignment on UThudderComponent");
static_assert(sizeof(UThudderComponent) == 0x0000F0, "Wrong size on UThudderComponent");
static_assert(offsetof(UThudderComponent, OnThud) == 0x0000B0, "Member 'UThudderComponent::OnThud' has a wrong offset!");
static_assert(offsetof(UThudderComponent, bOnlyIfBoneIsSimulatingPhysics) == 0x0000C0, "Member 'UThudderComponent::bOnlyIfBoneIsSimulatingPhysics' has a wrong offset!");
static_assert(offsetof(UThudderComponent, MonitoredComponent) == 0x0000C8, "Member 'UThudderComponent::MonitoredComponent' has a wrong offset!");
static_assert(offsetof(UThudderComponent, MonitoredBone) == 0x0000D0, "Member 'UThudderComponent::MonitoredBone' has a wrong offset!");
static_assert(offsetof(UThudderComponent, MinTimeBetweenThuds) == 0x0000D8, "Member 'UThudderComponent::MinTimeBetweenThuds' has a wrong offset!");
static_assert(offsetof(UThudderComponent, ThudMinVelocityThreshold) == 0x0000DC, "Member 'UThudderComponent::ThudMinVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UThudderComponent, NextThudTime) == 0x0000E0, "Member 'UThudderComponent::NextThudTime' has a wrong offset!");
static_assert(offsetof(UThudderComponent, PreviousVelocity) == 0x0000E4, "Member 'UThudderComponent::PreviousVelocity' has a wrong offset!");
static_assert(offsetof(UThudderComponent, CurrentVelocity) == 0x0000E8, "Member 'UThudderComponent::CurrentVelocity' has a wrong offset!");
static_assert(offsetof(UThudderComponent, bHasValidVelocity) == 0x0000EC, "Member 'UThudderComponent::bHasValidVelocity' has a wrong offset!");

// Class Mordhau.Turret
// 0x0000 (0x0B10 - 0x0B10)
class ATurret final : public AAdvancedCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Turret">();
	}
	static class ATurret* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATurret>();
	}
};
static_assert(alignof(ATurret) == 0x000010, "Wrong alignment on ATurret");
static_assert(sizeof(ATurret) == 0x000B10, "Wrong size on ATurret");

// Class Mordhau.UpperChestWearable
// 0x0048 (0x0270 - 0x0228)
class UUpperChestWearable : public UMordhauWearable
{
public:
	uint8                                         DefaultLowerChest;                                 // 0x0228(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           LowerChestWearables;                               // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         DefaultArms;                                       // 0x0240(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           ArmsWearables;                                     // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         DefaultShoulders;                                  // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           ShouldersWearables;                                // 0x0260(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void AddArmsWearable(TSoftClassPtr<class UClass> Wearable);
	void AddLowerChestWearable(TSoftClassPtr<class UClass> Wearable);
	void AddShoulderWearable(TSoftClassPtr<class UClass> Wearable);
	TSubclassOf<class UArmsWearable> GetArmsWearable(int32 Index_0);
	TSubclassOf<class UMordhauWearable> GetLowerChestWearable(int32 Index_0);
	TSubclassOf<class UMordhauWearable> GetShouldersWearable(int32 Index_0);

	int32 GetArmsWearablesNum() const;
	int32 GetLowerChestWearablesNum() const;
	int32 GetShouldersWearablesNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpperChestWearable">();
	}
	static class UUpperChestWearable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpperChestWearable>();
	}
};
static_assert(alignof(UUpperChestWearable) == 0x000008, "Wrong alignment on UUpperChestWearable");
static_assert(sizeof(UUpperChestWearable) == 0x000270, "Wrong size on UUpperChestWearable");
static_assert(offsetof(UUpperChestWearable, DefaultLowerChest) == 0x000228, "Member 'UUpperChestWearable::DefaultLowerChest' has a wrong offset!");
static_assert(offsetof(UUpperChestWearable, LowerChestWearables) == 0x000230, "Member 'UUpperChestWearable::LowerChestWearables' has a wrong offset!");
static_assert(offsetof(UUpperChestWearable, DefaultArms) == 0x000240, "Member 'UUpperChestWearable::DefaultArms' has a wrong offset!");
static_assert(offsetof(UUpperChestWearable, ArmsWearables) == 0x000248, "Member 'UUpperChestWearable::ArmsWearables' has a wrong offset!");
static_assert(offsetof(UUpperChestWearable, DefaultShoulders) == 0x000258, "Member 'UUpperChestWearable::DefaultShoulders' has a wrong offset!");
static_assert(offsetof(UUpperChestWearable, ShouldersWearables) == 0x000260, "Member 'UUpperChestWearable::ShouldersWearables' has a wrong offset!");

// Class Mordhau.VelocityBoxComponent
// 0x0040 (0x04B0 - 0x0470)
class UVelocityBoxComponent final : public UBoxComponent
{
public:
	bool                                          bOnlyRunOnAuthority;                               // 0x0468(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_469[0x3];                                      // 0x0469(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TriggerVelocity;                                   // 0x046C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVelocityAxis;                                  // 0x0470(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_471[0x3];                                      // 0x0471(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VelocityAxis;                                      // 0x0474(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVelocityAxisAccountForPawnVelocity;               // 0x0480(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_481[0x7];                                      // 0x0481(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AAdvancedCharacter* Character, float Velocity)> OnTriggered;                                       // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                PreviousLocation;                                  // 0x0498(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentVelocity;                                   // 0x04A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VelocityBoxComponent">();
	}
	static class UVelocityBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVelocityBoxComponent>();
	}
};
static_assert(alignof(UVelocityBoxComponent) == 0x000010, "Wrong alignment on UVelocityBoxComponent");
static_assert(sizeof(UVelocityBoxComponent) == 0x0004B0, "Wrong size on UVelocityBoxComponent");
static_assert(offsetof(UVelocityBoxComponent, bOnlyRunOnAuthority) == 0x000468, "Member 'UVelocityBoxComponent::bOnlyRunOnAuthority' has a wrong offset!");
static_assert(offsetof(UVelocityBoxComponent, TriggerVelocity) == 0x00046C, "Member 'UVelocityBoxComponent::TriggerVelocity' has a wrong offset!");
static_assert(offsetof(UVelocityBoxComponent, bUseVelocityAxis) == 0x000470, "Member 'UVelocityBoxComponent::bUseVelocityAxis' has a wrong offset!");
static_assert(offsetof(UVelocityBoxComponent, VelocityAxis) == 0x000474, "Member 'UVelocityBoxComponent::VelocityAxis' has a wrong offset!");
static_assert(offsetof(UVelocityBoxComponent, bVelocityAxisAccountForPawnVelocity) == 0x000480, "Member 'UVelocityBoxComponent::bVelocityAxisAccountForPawnVelocity' has a wrong offset!");
static_assert(offsetof(UVelocityBoxComponent, OnTriggered) == 0x000488, "Member 'UVelocityBoxComponent::OnTriggered' has a wrong offset!");
static_assert(offsetof(UVelocityBoxComponent, PreviousLocation) == 0x000498, "Member 'UVelocityBoxComponent::PreviousLocation' has a wrong offset!");
static_assert(offsetof(UVelocityBoxComponent, CurrentVelocity) == 0x0004A4, "Member 'UVelocityBoxComponent::CurrentVelocity' has a wrong offset!");

// Class Mordhau.WebhookTypes
// 0x0000 (0x0028 - 0x0028)
class UWebhookTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WebhookTypes">();
	}
	static class UWebhookTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWebhookTypes>();
	}
};
static_assert(alignof(UWebhookTypes) == 0x000008, "Wrong alignment on UWebhookTypes");
static_assert(sizeof(UWebhookTypes) == 0x000028, "Wrong size on UWebhookTypes");

// Class Mordhau.WheeledVehicleAnimInstance
// 0x0010 (0x0390 - 0x0380)
class UWheeledVehicleAnimInstance : public UAdvancedCharacterAnimInstance
{
public:
	float                                         WheelCastDistance;                                 // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_384[0xC];                                      // 0x0384(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WheeledVehicleAnimInstance">();
	}
	static class UWheeledVehicleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWheeledVehicleAnimInstance>();
	}
};
static_assert(alignof(UWheeledVehicleAnimInstance) == 0x000010, "Wrong alignment on UWheeledVehicleAnimInstance");
static_assert(sizeof(UWheeledVehicleAnimInstance) == 0x000390, "Wrong size on UWheeledVehicleAnimInstance");
static_assert(offsetof(UWheeledVehicleAnimInstance, WheelCastDistance) == 0x000380, "Member 'UWheeledVehicleAnimInstance::WheelCastDistance' has a wrong offset!");

// Class Mordhau.WheeledVehicleComponent
// 0x0000 (0x01B0 - 0x01B0)
class UWheeledVehicleComponent : public UMordhauVehicleComponent
{
public:
	class AMordhauWheeledVehicle*                 WheeledVehicle;                                    // 0x01A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WheeledVehicleComponent">();
	}
	static class UWheeledVehicleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWheeledVehicleComponent>();
	}
};
static_assert(alignof(UWheeledVehicleComponent) == 0x000010, "Wrong alignment on UWheeledVehicleComponent");
static_assert(sizeof(UWheeledVehicleComponent) == 0x0001B0, "Wrong size on UWheeledVehicleComponent");
static_assert(offsetof(UWheeledVehicleComponent, WheeledVehicle) == 0x0001A8, "Member 'UWheeledVehicleComponent::WheeledVehicle' has a wrong offset!");

}

