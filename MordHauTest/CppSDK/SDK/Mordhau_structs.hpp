#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mordhau

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "MordhauOnlineSubsystem_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "PlayFab_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK
{

// Enum Mordhau.EMordhauDamageType
// NumValues: 0x0006
enum class EMordhauDamageType : uint8
{
	Generic                                  = 0,
	Melee                                    = 1,
	Ranged                                   = 2,
	Fall                                     = 3,
	Fire                                     = 4,
	EMordhauDamageType_MAX                   = 5,
};

// Enum Mordhau.EFriendSource
// NumValues: 0x0003
enum class EFriendSource : uint8
{
	Platform                                 = 0,
	PlayFab                                  = 1,
	EFriendSource_MAX                        = 2,
};

// Enum Mordhau.EServerList
// NumValues: 0x0006
enum class EServerList : uint8
{
	Internet                                 = 0,
	Favorites                                = 1,
	Recent                                   = 2,
	Friends                                  = 3,
	LAN                                      = 4,
	EServerList_MAX                          = 5,
};

// Enum Mordhau.EAdvancedCharacterFlags
// NumValues: 0x0006
enum class EAdvancedCharacterFlags : uint8
{
	None                                     = 0,
	Airborne                                 = 1,
	Burning                                  = 2,
	RagdollFalling                           = 4,
	Jumped                                   = 8,
	EAdvancedCharacterFlags_MAX              = 9,
};

// Enum Mordhau.EAttackType
// NumValues: 0x0008
enum class EAttackType : uint8
{
	Regular                                  = 0,
	Riposte                                  = 1,
	Combo                                    = 2,
	PostClash                                = 3,
	Morph                                    = 4,
	MissCombo                                = 5,
	PostClashSlow                            = 6,
	EAttackType_MAX                          = 7,
};

// Enum Mordhau.EAttackStage
// NumValues: 0x0004
enum class EAttackStage : uint8
{
	Windup                                   = 0,
	Release                                  = 1,
	Recovery                                 = 2,
	EAttackStage_MAX                         = 3,
};

// Enum Mordhau.EConfigValueType
// NumValues: 0x000A
enum class EConfigValueType : uint8
{
	bool_type                                = 0,
	int_type                                 = 1,
	float_type                               = 2,
	vector_type                              = 3,
	vector2d_type                            = 4,
	rotator_type                             = 5,
	string_type                              = 6,
	color_type                               = 7,
	array_type                               = 8,
	EConfigValueType_MAX                     = 9,
};

// Enum Mordhau.ESwayMethod
// NumValues: 0x0003
enum class ESwayMethod : uint8
{
	Sin                                      = 0,
	Constant                                 = 1,
	ESwayMethod_MAX                          = 2,
};

// Enum Mordhau.EModeSwitchType
// NumValues: 0x0005
enum class EModeSwitchType : uint8
{
	Regular                                  = 0,
	Simple                                   = 1,
	LeftToRightHand                          = 2,
	RightToLeftHand                          = 3,
	EModeSwitchType_MAX                      = 4,
};

// Enum Mordhau.ESwitchStage
// NumValues: 0x0003
enum class ESwitchStage : uint8
{
	Reaching                                 = 0,
	Drawing                                  = 1,
	ESwitchStage_MAX                         = 2,
};

// Enum Mordhau.EFeintType
// NumValues: 0x0004
enum class EFeintType : uint8
{
	Regular                                  = 0,
	Combo                                    = 1,
	Chamber                                  = 2,
	EFeintType_MAX                           = 3,
};

// Enum Mordhau.ERconLogTypes
// NumValues: 0x0008
enum class ERconLogTypes : uint8
{
	fatal                                    = 0,
	error                                    = 1,
	warning                                  = 2,
	display                                  = 3,
	log                                      = 4,
	verbose                                  = 5,
	very_verbose                             = 6,
	ERconLogTypes_MAX                        = 7,
};

// Enum Mordhau.EAIFacingMode
// NumValues: 0x0006
enum class EAIFacingMode : uint8
{
	Movement                                 = 0,
	Location                                 = 1,
	Actor                                    = 2,
	Actor2D                                  = 3,
	Bone                                     = 4,
	EAIFacingMode_MAX                        = 5,
};

// Enum Mordhau.EBeaconRequest
// NumValues: 0x0003
enum class EBeaconRequest : uint8
{
	Ping                                     = 0,
	ReserveSlots                             = 1,
	EBeaconRequest_MAX                       = 2,
};

// Enum Mordhau.EReservationStatus
// NumValues: 0x0004
enum class EReservationStatus : uint8
{
	Success                                  = 0,
	Full                                     = 1,
	Failure                                  = 2,
	EReservationStatus_MAX                   = 3,
};

// Enum Mordhau.EHorseGear
// NumValues: 0x0006
enum class EHorseGear : uint8
{
	Walk                                     = 0,
	Trot                                     = 1,
	Canter                                   = 2,
	Gallop                                   = 3,
	Total                                    = 4,
	EHorseGear_MAX                           = 5,
};

// Enum Mordhau.EMovementRestriction
// NumValues: 0x0005
enum class EMovementRestriction : uint8
{
	None                                     = 0,
	PartialSprint                            = 1,
	Walk                                     = 2,
	NoMovement                               = 3,
	EMovementRestriction_MAX                 = 4,
};

// Enum Mordhau.EPerk
// NumValues: 0x0018
enum class EPerk : uint8
{
	Pugilist                                 = 0,
	Acrobat                                  = 1,
	Fury                                     = 2,
	Peasant                                  = 3,
	Fireproof                                = 4,
	Huntsman                                 = 5,
	Tank                                     = 6,
	Rat                                      = 7,
	Cat                                      = 8,
	Wrecker                                  = 9,
	Smith                                    = 10,
	Dwarf                                    = 11,
	SecondWind                               = 12,
	Bloodlust                                = 13,
	Rush                                     = 14,
	FleshWound                               = 15,
	Scavenger                                = 16,
	Dodge                                    = 17,
	Ranger                                   = 18,
	Mule                                     = 19,
	Butcher                                  = 20,
	Stun                                     = 21,
	Supplied                                 = 22,
	EPerk_MAX                                = 23,
};

// Enum Mordhau.EAttackMove
// NumValues: 0x0009
enum class EAttackMove : uint8
{
	RightStrike                              = 0,
	LeftStrike                               = 1,
	Stab                                     = 2,
	AltStab                                  = 3,
	Kick                                     = 4,
	Bash                                     = 5,
	Couch                                    = 6,
	Ranged                                   = 7,
	EAttackMove_MAX                          = 8,
};

// Enum Mordhau.EProfileValidationFailedReason
// NumValues: 0x0004
enum class EProfileValidationFailedReason : uint8
{
	Unset                                    = 0,
	NotEnoughPoints                          = 1,
	SkillTooLow                              = 2,
	EProfileValidationFailedReason_MAX       = 3,
};

// Enum Mordhau.EMainWearableSlot
// NumValues: 0x0004
enum class EMainWearableSlot : uint8
{
	Head                                     = 0,
	UpperChest                               = 1,
	Legs                                     = 2,
	EMainWearableSlot_MAX                    = 3,
};

// Enum Mordhau.EWearableSlot
// NumValues: 0x000C
enum class EWearableSlot : uint8
{
	Head                                     = 0,
	Coif                                     = 1,
	UpperChest                               = 2,
	LowerChest                               = 3,
	Shoulders                                = 4,
	Arms                                     = 5,
	Hands                                    = 6,
	Legs                                     = 7,
	Feet                                     = 8,
	Total                                    = 9,
	Invalid                                  = 10,
	EWearableSlot_MAX                        = 11,
};

// Enum Mordhau.EItemRarity
// NumValues: 0x0007
enum class EItemRarity : uint8
{
	Common                                   = 0,
	Uncommon                                 = 1,
	Rare                                     = 2,
	Epic                                     = 3,
	Legendary                                = 4,
	Exclusive                                = 5,
	EItemRarity_MAX                          = 6,
};

// Enum Mordhau.EEquipmentCategory
// NumValues: 0x0007
enum class EEquipmentCategory : uint8
{
	Undefined                                = 0,
	OneHanded                                = 1,
	TwoHanded                                = 2,
	Ranged                                   = 3,
	Shield                                   = 4,
	Utility                                  = 5,
	EEquipmentCategory_MAX                   = 6,
};

// Enum Mordhau.EEquipmentType
// NumValues: 0x0009
enum class EEquipmentType : uint8
{
	Undefined                                = 0,
	MeleeNoAltMode                           = 1,
	MeleeWithAltMode                         = 2,
	MeleeThrownAltMode                       = 3,
	ProjectileWeapon                         = 4,
	Shield                                   = 5,
	Thrown                                   = 6,
	Utility                                  = 7,
	EEquipmentType_MAX                       = 8,
};

// Enum Mordhau.EAuxiliaryMeshMode
// NumValues: 0x0006
enum class EAuxiliaryMeshMode : uint8
{
	None                                     = 0,
	Arrow                                    = 1,
	Bolt                                     = 2,
	Scabbard                                 = 3,
	Pommel                                   = 4,
	EAuxiliaryMeshMode_MAX                   = 5,
};

// Enum Mordhau.EQuitGamePreference
// NumValues: 0x0003
enum class EQuitGamePreference : uint8
{
	Quit                                     = 0,
	Background                               = 1,
	EQuitGamePreference_MAX                  = 2,
};

// Enum Mordhau.EPlayerReportResponse
// NumValues: 0x0008
enum class EPlayerReportResponse : uint8
{
	Unknown                                  = 0,
	Success                                  = 1,
	MaxReportsPerTimeframeReached            = 2,
	WasUserAlreadyReportedInAllowedTimeframe = 3,
	NotEnoughTimePassedFromLastReport        = 4,
	InvalidUser                              = 5,
	InvalidReport                            = 6,
	EPlayerReportResponse_MAX                = 7,
};

// Enum Mordhau.EMatchmakingState
// NumValues: 0x0005
enum class EMatchmakingState : uint8
{
	Idle                                     = 0,
	Searching                                = 1,
	Waiting                                  = 2,
	Joining                                  = 3,
	EMatchmakingState_MAX                    = 4,
};

// Enum Mordhau.ERichPresenceStatus
// NumValues: 0x0004
enum class ERichPresenceStatus : uint8
{
	MainMenu                                 = 0,
	LocalMatch                               = 1,
	OnlineMatch                              = 2,
	ERichPresenceStatus_MAX                  = 3,
};

// Enum Mordhau.ELobbyMessage
// NumValues: 0x0005
enum class ELobbyMessage : uint8
{
	Invalid                                  = 0,
	Kick                                     = 1,
	Status                                   = 2,
	Profile                                  = 3,
	ELobbyMessage_MAX                        = 4,
};

// Enum Mordhau.ELoginError
// NumValues: 0x000D
enum class ELoginError : uint8
{
	NoError                                  = 0,
	RequiredPatchAvailable                   = 1,
	RequiredSystemUpdate                     = 2,
	AgeRestrictionFailure                    = 3,
	AccountTypeFailure                       = 4,
	UserNotFound                             = 5,
	UserNotLoggedIn                          = 6,
	GenericFailure                           = 7,
	OnlinePlayRestricted                     = 8,
	NetworkConnectionUnavailable             = 9,
	PSNPlusRequired                          = 10,
	PSNPremiumRequired                       = 11,
	ELoginError_MAX                          = 12,
};

// Enum Mordhau.EOfficialServerVisibility
// NumValues: 0x0003
enum class EOfficialServerVisibility : uint8
{
	ServerBrowser                            = 0,
	Matchmaking                              = 1,
	EOfficialServerVisibility_MAX            = 2,
};

// Enum Mordhau.EClientRequestState
// NumValues: 0x0005
enum class EClientRequestState : uint8
{
	SessionTicket                            = 0,
	Stats                                    = 1,
	Inventory                                = 2,
	Done                                     = 3,
	EClientRequestState_MAX                  = 4,
};

// Enum Mordhau.EServerFilterCategories
// NumValues: 0x0005
enum class EServerFilterCategories : uint8
{
	Server                                   = 0,
	Population                               = 1,
	Modded                                   = 2,
	Password                                 = 3,
	EServerFilterCategories_MAX              = 4,
};

// Enum Mordhau.EItemPlatformFilter
// NumValues: 0x000A
enum class EItemPlatformFilter : uint8
{
	None                                     = 0,
	PC                                       = 1,
	Console                                  = 2,
	Steam                                    = 3,
	Epic                                     = 4,
	Xbox                                     = 5,
	PSN                                      = 6,
	All                                      = 7,
	Undefined                                = 8,
	EItemPlatformFilter_MAX                  = 9,
};

// Enum Mordhau.EBlockedReason
// NumValues: 0x0006
enum class EBlockedReason : uint8
{
	Parry                                    = 0,
	Chamber                                  = 1,
	World                                    = 2,
	Clash                                    = 3,
	Hit                                      = 4,
	EBlockedReason_MAX                       = 5,
};

// Enum Mordhau.EBlockType
// NumValues: 0x0004
enum class EBlockType : uint8
{
	Regular                                  = 0,
	AltRegular                               = 1,
	ShieldWall                               = 2,
	EBlockType_MAX                           = 3,
};

// Enum Mordhau.EMovementModifier
// NumValues: 0x0009
enum class EMovementModifier : uint8
{
	Walk                                     = 0,
	Strafe                                   = 1,
	Backpedal                                = 2,
	PartialSprint                            = 3,
	Sprint                                   = 4,
	Rush                                     = 5,
	Chasing                                  = 6,
	Supersprint                              = 7,
	EMovementModifier_MAX                    = 8,
};

// Enum Mordhau.EServerSort
// NumValues: 0x0009
enum class EServerSort : uint8
{
	ServerNameAscend                         = 0,
	ServerNameDescend                        = 1,
	MapNameAscend                            = 2,
	MapNameDescend                           = 3,
	CountAscend                              = 4,
	CountDescend                             = 5,
	PingAscend                               = 6,
	PingDescend                              = 7,
	EServerSort_MAX                          = 8,
};

// Enum Mordhau.ENewsWidgetState
// NumValues: 0x0004
enum class ENewsWidgetState : uint8
{
	NW_Idle                                  = 0,
	NW_Requesting                            = 1,
	NW_Downloading                           = 2,
	NW_MAX                                   = 3,
};

// Enum Mordhau.ECommandType
// NumValues: 0x000A
enum class ECommandType : uint8
{
	Invalid                                  = 0,
	AddAdmin                                 = 1,
	RemoveAdmin                              = 2,
	Kick                                     = 3,
	Ban                                      = 4,
	Unban                                    = 5,
	Mute                                     = 6,
	Unmute                                   = 7,
	LookupPlayer                             = 8,
	ECommandType_MAX                         = 9,
};

// Enum Mordhau.EScoreFeedReason
// NumValues: 0x0014
enum class EScoreFeedReason : uint8
{
	Kill                                     = 0,
	TeamKill                                 = 1,
	Assist                                   = 2,
	Suicide                                  = 3,
	PlayerDamage                             = 4,
	PlayerTeamDamage                         = 5,
	OtherDamage                              = 6,
	OtherTeamDamage                          = 7,
	Capturing                                = 8,
	Captured                                 = 9,
	Neutralizing                             = 10,
	Neutralized                              = 11,
	Objective                                = 12,
	Heal                                     = 13,
	WaveCleared                              = 14,
	Repair                                   = 15,
	VehicleDamage                            = 16,
	VehicleTeamDamage                        = 17,
	Spawn                                    = 18,
	EScoreFeedReason_MAX                     = 19,
};

// Enum Mordhau.ECameraStyle
// NumValues: 0x0004
enum class ECameraStyle : uint8
{
	FirstPerson                              = 0,
	ThirdPerson                              = 1,
	Fixed                                    = 2,
	ECameraStyle_MAX                         = 3,
};

// Enum Mordhau.EBanType
// NumValues: 0x0003
enum class EBanType : uint8
{
	VoteKick                                 = 0,
	TeamKills                                = 1,
	EBanType_MAX                             = 2,
};

// Enum Mordhau.EAntiCheat
// NumValues: 0x0004
enum class EAntiCheat : uint8
{
	Secure_Only                              = 0,
	Insecure_Only                            = 1,
	Both                                     = 2,
	EAntiCheat_MAX                           = 3,
};

// Enum Mordhau.EStatSetBy
// NumValues: 0x0003
enum class EStatSetBy : uint8
{
	Client                                   = 0,
	Server                                   = 1,
	EStatSetBy_MAX                           = 2,
};

// Enum Mordhau.EActivityType
// NumValues: 0x0005
enum class EActivityType : uint8
{
	None                                     = 0,
	Invasion_and_Frontline                   = 1,
	Horde                                    = 2,
	Brawl                                    = 3,
	EActivityType_MAX                        = 4,
};

// Enum Mordhau.EBroadcastTypes
// NumValues: 0x0009
enum class EBroadcastTypes : uint8
{
	None                                     = 0,
	Chat                                     = 1,
	Killfeed                                 = 2,
	Scorefeed                                = 3,
	MatchState                               = 4,
	Login                                    = 5,
	Custom                                   = 6,
	Punishment                               = 7,
	EBroadcastTypes_MAX                      = 8,
};

// Enum Mordhau.EDownloadableContent
// NumValues: 0x0002
enum class EDownloadableContent : uint8
{
	SupporterPack                            = 0,
	EDownloadableContent_MAX                 = 1,
};

// Enum Mordhau.EInputMode
// NumValues: 0x0005
enum class EInputMode : uint8
{
	GAME_AND_UI                              = 0,
	Game                                     = 1,
	UI_ONLY                                  = 2,
	NONE_SPECIFIED                           = 3,
	EInputMode_MAX                           = 4,
};

// Enum Mordhau.ECallResult
// NumValues: 0x0003
enum class ECallResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
	ECallResult_MAX                          = 2,
};

// Enum Mordhau.ESoundMix
// NumValues: 0x0006
enum class ESoundMix : uint8
{
	Master                                   = 0,
	Effects                                  = 1,
	Music                                    = 2,
	Voice                                    = 3,
	Instruments                              = 4,
	ESoundMix_MAX                            = 5,
};

// Enum Mordhau.EBudgetType
// NumValues: 0x0003
enum class EBudgetType : uint8
{
	Particle                                 = 0,
	Total                                    = 1,
	EBudgetType_MAX                          = 2,
};

// Enum Mordhau.ECameraShakeType
// NumValues: 0x0004
enum class ECameraShakeType : uint8
{
	Default                                  = 0,
	Movement                                 = 1,
	Combat                                   = 2,
	ECameraShakeType_MAX                     = 3,
};

// Enum Mordhau.EDismembermentType
// NumValues: 0x0005
enum class EDismembermentType : uint8
{
	None                                     = 0,
	Blunt                                    = 1,
	Pierce                                   = 2,
	Cut                                      = 3,
	EDismembermentType_MAX                   = 4,
};

// Enum Mordhau.EMotionType
// NumValues: 0x001E
enum class EMotionType : uint8
{
	Idle                                     = 0,
	Attack                                   = 1,
	Parry                                    = 2,
	Flinched                                 = 3,
	Stunned                                  = 4,
	Feinted                                  = 5,
	Blocked                                  = 6,
	Disarmed                                 = 7,
	EquipmentSwitch                          = 8,
	DropEquipment                            = 9,
	Emote                                    = 10,
	EquipmentModeSwitch                      = 11,
	RangedDraw                               = 12,
	RangedRelease                            = 13,
	QuickthrowDraw                           = 14,
	QuickthrowRelease                        = 15,
	InteractWith                             = 16,
	Reload                                   = 17,
	RangedCancel                             = 18,
	CouchedAttack                            = 19,
	PommelDraw                               = 20,
	PommelThrow                              = 21,
	EmoteCancel                              = 22,
	Holster                                  = 23,
	EnterVehicle                             = 24,
	LeaveVehicle                             = 25,
	RagdollFalling                           = 26,
	Climbing                                 = 27,
	Ability                                  = 28,
	EMotionType_MAX                          = 29,
};

// Enum Mordhau.EParryRecoveryType
// NumValues: 0x0004
enum class EParryRecoveryType : uint8
{
	Success                                  = 0,
	Fail                                     = 1,
	Miss                                     = 2,
	EParryRecoveryType_MAX                   = 3,
};

// Enum Mordhau.EParryStage
// NumValues: 0x0003
enum class EParryStage : uint8
{
	Parry                                    = 0,
	Recovery                                 = 1,
	EParryStage_MAX                          = 2,
};

// Enum Mordhau.EWeaponState
// NumValues: 0x0006
enum class EWeaponState : uint8
{
	Loaded                                   = 0,
	Releasing                                = 1,
	Recovery                                 = 2,
	Loading                                  = 3,
	Building                                 = 4,
	EWeaponState_MAX                         = 5,
};

// Enum Mordhau.EVehicleFlags
// NumValues: 0x0003
enum class EVehicleFlags : uint8
{
	None                                     = 0,
	Burning                                  = 2,
	EVehicleFlags_MAX                        = 3,
};

// ScriptStruct Mordhau.MordhauMLFontStlye
// 0x0060 (0x0060 - 0x0000)
struct FMordhauMLFontStlye final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Size;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Typeface;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FontFamily;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ColorRGBA;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Alignment;                                         // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Padding;                                           // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaddingBottom;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMordhauMLFontStlye) == 0x000008, "Wrong alignment on FMordhauMLFontStlye");
static_assert(sizeof(FMordhauMLFontStlye) == 0x000060, "Wrong size on FMordhauMLFontStlye");
static_assert(offsetof(FMordhauMLFontStlye, Name) == 0x000000, "Member 'FMordhauMLFontStlye::Name' has a wrong offset!");
static_assert(offsetof(FMordhauMLFontStlye, Size) == 0x000010, "Member 'FMordhauMLFontStlye::Size' has a wrong offset!");
static_assert(offsetof(FMordhauMLFontStlye, Typeface) == 0x000018, "Member 'FMordhauMLFontStlye::Typeface' has a wrong offset!");
static_assert(offsetof(FMordhauMLFontStlye, FontFamily) == 0x000028, "Member 'FMordhauMLFontStlye::FontFamily' has a wrong offset!");
static_assert(offsetof(FMordhauMLFontStlye, ColorRGBA) == 0x000038, "Member 'FMordhauMLFontStlye::ColorRGBA' has a wrong offset!");
static_assert(offsetof(FMordhauMLFontStlye, Alignment) == 0x000048, "Member 'FMordhauMLFontStlye::Alignment' has a wrong offset!");
static_assert(offsetof(FMordhauMLFontStlye, Padding) == 0x000058, "Member 'FMordhauMLFontStlye::Padding' has a wrong offset!");
static_assert(offsetof(FMordhauMLFontStlye, PaddingBottom) == 0x00005C, "Member 'FMordhauMLFontStlye::PaddingBottom' has a wrong offset!");

// ScriptStruct Mordhau.CharLook
// 0x000C (0x000C - 0x0000)
struct FCharLook final
{
public:
	uint8                                         FacingMode;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Offset2D;                                          // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharLook) == 0x000004, "Wrong alignment on FCharLook");
static_assert(sizeof(FCharLook) == 0x00000C, "Wrong size on FCharLook");
static_assert(offsetof(FCharLook, FacingMode) == 0x000000, "Member 'FCharLook::FacingMode' has a wrong offset!");
static_assert(offsetof(FCharLook, Offset2D) == 0x000004, "Member 'FCharLook::Offset2D' has a wrong offset!");

// ScriptStruct Mordhau.MordhauDamageInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FMordhauDamageInfo final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x008C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EMordhauDamageType                            Type;                                              // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SubType;                                           // 0x008D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DamageSource;                                      // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageAgent;                                       // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsFlinchAnimation;                             // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMordhauDamageInfo) == 0x000008, "Wrong alignment on FMordhauDamageInfo");
static_assert(sizeof(FMordhauDamageInfo) == 0x0000A8, "Wrong size on FMordhauDamageInfo");
static_assert(offsetof(FMordhauDamageInfo, Hit) == 0x000000, "Member 'FMordhauDamageInfo::Hit' has a wrong offset!");
static_assert(offsetof(FMordhauDamageInfo, Type) == 0x00008C, "Member 'FMordhauDamageInfo::Type' has a wrong offset!");
static_assert(offsetof(FMordhauDamageInfo, SubType) == 0x00008D, "Member 'FMordhauDamageInfo::SubType' has a wrong offset!");
static_assert(offsetof(FMordhauDamageInfo, DamageSource) == 0x000090, "Member 'FMordhauDamageInfo::DamageSource' has a wrong offset!");
static_assert(offsetof(FMordhauDamageInfo, DamageAgent) == 0x000098, "Member 'FMordhauDamageInfo::DamageAgent' has a wrong offset!");
static_assert(offsetof(FMordhauDamageInfo, bWantsFlinchAnimation) == 0x0000A0, "Member 'FMordhauDamageInfo::bWantsFlinchAnimation' has a wrong offset!");

// ScriptStruct Mordhau.GameServerFilter
// 0x0048 (0x0048 - 0x0000)
struct FGameServerFilter final
{
public:
	bool                                          bIsNotFull;                                        // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPlayers;                                       // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmpty;                                          // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNotPasswordProtected;                           // 0x0003(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOfficial;                                       // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsModded;                                         // 0x0005(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinOpenSlots;                                      // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QueueName;                                         // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerName;                                        // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EServerRegion                                 Region;                                            // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameServerFilter) == 0x000008, "Wrong alignment on FGameServerFilter");
static_assert(sizeof(FGameServerFilter) == 0x000048, "Wrong size on FGameServerFilter");
static_assert(offsetof(FGameServerFilter, bIsNotFull) == 0x000000, "Member 'FGameServerFilter::bIsNotFull' has a wrong offset!");
static_assert(offsetof(FGameServerFilter, bHasPlayers) == 0x000001, "Member 'FGameServerFilter::bHasPlayers' has a wrong offset!");
static_assert(offsetof(FGameServerFilter, bIsEmpty) == 0x000002, "Member 'FGameServerFilter::bIsEmpty' has a wrong offset!");
static_assert(offsetof(FGameServerFilter, bIsNotPasswordProtected) == 0x000003, "Member 'FGameServerFilter::bIsNotPasswordProtected' has a wrong offset!");
static_assert(offsetof(FGameServerFilter, bIsOfficial) == 0x000004, "Member 'FGameServerFilter::bIsOfficial' has a wrong offset!");
static_assert(offsetof(FGameServerFilter, bIsModded) == 0x000005, "Member 'FGameServerFilter::bIsModded' has a wrong offset!");
static_assert(offsetof(FGameServerFilter, MinOpenSlots) == 0x000008, "Member 'FGameServerFilter::MinOpenSlots' has a wrong offset!");
static_assert(offsetof(FGameServerFilter, QueueName) == 0x000010, "Member 'FGameServerFilter::QueueName' has a wrong offset!");
static_assert(offsetof(FGameServerFilter, ServerName) == 0x000020, "Member 'FGameServerFilter::ServerName' has a wrong offset!");
static_assert(offsetof(FGameServerFilter, GameMode) == 0x000030, "Member 'FGameServerFilter::GameMode' has a wrong offset!");
static_assert(offsetof(FGameServerFilter, Region) == 0x000040, "Member 'FGameServerFilter::Region' has a wrong offset!");

// ScriptStruct Mordhau.MordhauMLHeader
// 0x0030 (0x0030 - 0x0000)
struct FMordhauMLHeader final
{
public:
	class FString                                 Version;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Debug;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Platforms;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMordhauMLHeader) == 0x000008, "Wrong alignment on FMordhauMLHeader");
static_assert(sizeof(FMordhauMLHeader) == 0x000030, "Wrong size on FMordhauMLHeader");
static_assert(offsetof(FMordhauMLHeader, Version) == 0x000000, "Member 'FMordhauMLHeader::Version' has a wrong offset!");
static_assert(offsetof(FMordhauMLHeader, Debug) == 0x000010, "Member 'FMordhauMLHeader::Debug' has a wrong offset!");
static_assert(offsetof(FMordhauMLHeader, Platforms) == 0x000020, "Member 'FMordhauMLHeader::Platforms' has a wrong offset!");

// ScriptStruct Mordhau.MordhauMLImage
// 0x0048 (0x0048 - 0x0000)
struct FMordhauMLImage final
{
public:
	class FString                                 Src;                                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         X;                                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Alignment;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Padding;                                           // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMordhauMLImage) == 0x000008, "Wrong alignment on FMordhauMLImage");
static_assert(sizeof(FMordhauMLImage) == 0x000048, "Wrong size on FMordhauMLImage");
static_assert(offsetof(FMordhauMLImage, Src) == 0x000000, "Member 'FMordhauMLImage::Src' has a wrong offset!");
static_assert(offsetof(FMordhauMLImage, Name) == 0x000010, "Member 'FMordhauMLImage::Name' has a wrong offset!");
static_assert(offsetof(FMordhauMLImage, Width) == 0x000020, "Member 'FMordhauMLImage::Width' has a wrong offset!");
static_assert(offsetof(FMordhauMLImage, Height) == 0x000024, "Member 'FMordhauMLImage::Height' has a wrong offset!");
static_assert(offsetof(FMordhauMLImage, X) == 0x000028, "Member 'FMordhauMLImage::X' has a wrong offset!");
static_assert(offsetof(FMordhauMLImage, Y) == 0x00002C, "Member 'FMordhauMLImage::Y' has a wrong offset!");
static_assert(offsetof(FMordhauMLImage, Alignment) == 0x000030, "Member 'FMordhauMLImage::Alignment' has a wrong offset!");
static_assert(offsetof(FMordhauMLImage, Padding) == 0x000040, "Member 'FMordhauMLImage::Padding' has a wrong offset!");

// ScriptStruct Mordhau.MordhauMLText
// 0x0040 (0x0040 - 0x0000)
struct FMordhauMLText final
{
public:
	class FString                                 Data;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         MultilineData;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 DataFontStyle;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MultilineDataFontStyle;                            // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMordhauMLText) == 0x000008, "Wrong alignment on FMordhauMLText");
static_assert(sizeof(FMordhauMLText) == 0x000040, "Wrong size on FMordhauMLText");
static_assert(offsetof(FMordhauMLText, Data) == 0x000000, "Member 'FMordhauMLText::Data' has a wrong offset!");
static_assert(offsetof(FMordhauMLText, MultilineData) == 0x000010, "Member 'FMordhauMLText::MultilineData' has a wrong offset!");
static_assert(offsetof(FMordhauMLText, DataFontStyle) == 0x000020, "Member 'FMordhauMLText::DataFontStyle' has a wrong offset!");
static_assert(offsetof(FMordhauMLText, MultilineDataFontStyle) == 0x000030, "Member 'FMordhauMLText::MultilineDataFontStyle' has a wrong offset!");

// ScriptStruct Mordhau.MordhauMLWidget
// 0x0088 (0x0088 - 0x0000)
struct FMordhauMLWidget final
{
public:
	struct FMordhauMLImage                        Image;                                             // 0x0000(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMordhauMLText                         Text;                                              // 0x0048(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMordhauMLWidget) == 0x000008, "Wrong alignment on FMordhauMLWidget");
static_assert(sizeof(FMordhauMLWidget) == 0x000088, "Wrong size on FMordhauMLWidget");
static_assert(offsetof(FMordhauMLWidget, Image) == 0x000000, "Member 'FMordhauMLWidget::Image' has a wrong offset!");
static_assert(offsetof(FMordhauMLWidget, Text) == 0x000048, "Member 'FMordhauMLWidget::Text' has a wrong offset!");

// ScriptStruct Mordhau.MordhauML
// 0x0050 (0x0050 - 0x0000)
struct FMordhauML final
{
public:
	struct FMordhauMLHeader                       Header;                                            // 0x0000(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FMordhauMLFontStlye>            FontStyles;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMordhauMLWidget>               Widgets;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMordhauML) == 0x000008, "Wrong alignment on FMordhauML");
static_assert(sizeof(FMordhauML) == 0x000050, "Wrong size on FMordhauML");
static_assert(offsetof(FMordhauML, Header) == 0x000000, "Member 'FMordhauML::Header' has a wrong offset!");
static_assert(offsetof(FMordhauML, FontStyles) == 0x000030, "Member 'FMordhauML::FontStyles' has a wrong offset!");
static_assert(offsetof(FMordhauML, Widgets) == 0x000040, "Member 'FMordhauML::Widgets' has a wrong offset!");

// ScriptStruct Mordhau.FootGroundingLimb
// 0x0210 (0x0210 - 0x0000)
struct alignas(0x10) FFootGroundingLimb final
{
public:
	class FName                                   TraceEndBone;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceStartBone;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDistance;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UpValueLimits;                                     // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             TraceResult;                                       // 0x001C(0x008C)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x134];                                     // 0x00A8(0x0134)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RootSpaceImpactZ;                                  // 0x01DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x01E0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                InternalTranslationOffset;                         // 0x01EC(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TranslationOffset;                                 // 0x01F8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0xC];                                      // 0x0204(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFootGroundingLimb) == 0x000010, "Wrong alignment on FFootGroundingLimb");
static_assert(sizeof(FFootGroundingLimb) == 0x000210, "Wrong size on FFootGroundingLimb");
static_assert(offsetof(FFootGroundingLimb, TraceEndBone) == 0x000000, "Member 'FFootGroundingLimb::TraceEndBone' has a wrong offset!");
static_assert(offsetof(FFootGroundingLimb, TraceStartBone) == 0x000008, "Member 'FFootGroundingLimb::TraceStartBone' has a wrong offset!");
static_assert(offsetof(FFootGroundingLimb, TraceDistance) == 0x000010, "Member 'FFootGroundingLimb::TraceDistance' has a wrong offset!");
static_assert(offsetof(FFootGroundingLimb, UpValueLimits) == 0x000014, "Member 'FFootGroundingLimb::UpValueLimits' has a wrong offset!");
static_assert(offsetof(FFootGroundingLimb, TraceResult) == 0x00001C, "Member 'FFootGroundingLimb::TraceResult' has a wrong offset!");
static_assert(offsetof(FFootGroundingLimb, RootSpaceImpactZ) == 0x0001DC, "Member 'FFootGroundingLimb::RootSpaceImpactZ' has a wrong offset!");
static_assert(offsetof(FFootGroundingLimb, RotationOffset) == 0x0001E0, "Member 'FFootGroundingLimb::RotationOffset' has a wrong offset!");
static_assert(offsetof(FFootGroundingLimb, InternalTranslationOffset) == 0x0001EC, "Member 'FFootGroundingLimb::InternalTranslationOffset' has a wrong offset!");
static_assert(offsetof(FFootGroundingLimb, TranslationOffset) == 0x0001F8, "Member 'FFootGroundingLimb::TranslationOffset' has a wrong offset!");

// ScriptStruct Mordhau.SpawnablePlaneTraceSettings
// 0x0048 (0x0048 - 0x0000)
struct FSpawnablePlaneTraceSettings final
{
public:
	TArray<class UClass*>                         CheckActorsOnPlaneTraceHit;                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      HitTraceObjectTypes;                               // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ForwadDistance;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackDistance;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftDistance;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightDistance;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightForwardPercentage;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftForwardPercentage;                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceAmount;                                       // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnablePlaneTraceSettings) == 0x000008, "Wrong alignment on FSpawnablePlaneTraceSettings");
static_assert(sizeof(FSpawnablePlaneTraceSettings) == 0x000048, "Wrong size on FSpawnablePlaneTraceSettings");
static_assert(offsetof(FSpawnablePlaneTraceSettings, CheckActorsOnPlaneTraceHit) == 0x000000, "Member 'FSpawnablePlaneTraceSettings::CheckActorsOnPlaneTraceHit' has a wrong offset!");
static_assert(offsetof(FSpawnablePlaneTraceSettings, HitTraceObjectTypes) == 0x000010, "Member 'FSpawnablePlaneTraceSettings::HitTraceObjectTypes' has a wrong offset!");
static_assert(offsetof(FSpawnablePlaneTraceSettings, ForwadDistance) == 0x000020, "Member 'FSpawnablePlaneTraceSettings::ForwadDistance' has a wrong offset!");
static_assert(offsetof(FSpawnablePlaneTraceSettings, BackDistance) == 0x000024, "Member 'FSpawnablePlaneTraceSettings::BackDistance' has a wrong offset!");
static_assert(offsetof(FSpawnablePlaneTraceSettings, LeftDistance) == 0x000028, "Member 'FSpawnablePlaneTraceSettings::LeftDistance' has a wrong offset!");
static_assert(offsetof(FSpawnablePlaneTraceSettings, RightDistance) == 0x00002C, "Member 'FSpawnablePlaneTraceSettings::RightDistance' has a wrong offset!");
static_assert(offsetof(FSpawnablePlaneTraceSettings, RightForwardPercentage) == 0x000030, "Member 'FSpawnablePlaneTraceSettings::RightForwardPercentage' has a wrong offset!");
static_assert(offsetof(FSpawnablePlaneTraceSettings, LeftForwardPercentage) == 0x000034, "Member 'FSpawnablePlaneTraceSettings::LeftForwardPercentage' has a wrong offset!");
static_assert(offsetof(FSpawnablePlaneTraceSettings, TraceAmount) == 0x000038, "Member 'FSpawnablePlaneTraceSettings::TraceAmount' has a wrong offset!");

// ScriptStruct Mordhau.CharPhysics
// 0x0024 (0x0024 - 0x0000)
struct FCharPhysics final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharPhysics) == 0x000004, "Wrong alignment on FCharPhysics");
static_assert(sizeof(FCharPhysics) == 0x000024, "Wrong size on FCharPhysics");
static_assert(offsetof(FCharPhysics, Location) == 0x000000, "Member 'FCharPhysics::Location' has a wrong offset!");
static_assert(offsetof(FCharPhysics, Velocity) == 0x00000C, "Member 'FCharPhysics::Velocity' has a wrong offset!");
static_assert(offsetof(FCharPhysics, Rotation) == 0x000018, "Member 'FCharPhysics::Rotation' has a wrong offset!");

// ScriptStruct Mordhau.SkillsCustomization
// 0x0004 (0x0004 - 0x0000)
struct FSkillsCustomization final
{
public:
	uint32                                        Perks;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillsCustomization) == 0x000004, "Wrong alignment on FSkillsCustomization");
static_assert(sizeof(FSkillsCustomization) == 0x000004, "Wrong size on FSkillsCustomization");
static_assert(offsetof(FSkillsCustomization, Perks) == 0x000000, "Member 'FSkillsCustomization::Perks' has a wrong offset!");

// ScriptStruct Mordhau.MordhauFriend
// 0x0068 (0x0068 - 0x0000)
struct FMordhauFriend final
{
public:
	struct FPlayFabPlayer                         Player;                                            // 0x0000(0x0060)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFriendSource                                 Source;                                            // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMordhauFriend) == 0x000008, "Wrong alignment on FMordhauFriend");
static_assert(sizeof(FMordhauFriend) == 0x000068, "Wrong size on FMordhauFriend");
static_assert(offsetof(FMordhauFriend, Player) == 0x000000, "Member 'FMordhauFriend::Player' has a wrong offset!");
static_assert(offsetof(FMordhauFriend, Source) == 0x000060, "Member 'FMordhauFriend::Source' has a wrong offset!");

// ScriptStruct Mordhau.NetBlock
// 0x0010 (0x0010 - 0x0000)
struct FNetBlock final
{
public:
	uint8                                         BlockedReason;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Flags;                                             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BlockedMove;                                       // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Surface;                                           // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  BlockingActor;                                     // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Version;                                           // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetBlock) == 0x000004, "Wrong alignment on FNetBlock");
static_assert(sizeof(FNetBlock) == 0x000010, "Wrong size on FNetBlock");
static_assert(offsetof(FNetBlock, BlockedReason) == 0x000000, "Member 'FNetBlock::BlockedReason' has a wrong offset!");
static_assert(offsetof(FNetBlock, Flags) == 0x000001, "Member 'FNetBlock::Flags' has a wrong offset!");
static_assert(offsetof(FNetBlock, BlockedMove) == 0x000002, "Member 'FNetBlock::BlockedMove' has a wrong offset!");
static_assert(offsetof(FNetBlock, Surface) == 0x000003, "Member 'FNetBlock::Surface' has a wrong offset!");
static_assert(offsetof(FNetBlock, BlockingActor) == 0x000004, "Member 'FNetBlock::BlockingActor' has a wrong offset!");
static_assert(offsetof(FNetBlock, Version) == 0x00000C, "Member 'FNetBlock::Version' has a wrong offset!");

// ScriptStruct Mordhau.AnimNode_TwoHandedIK
// 0x0138 (0x0200 - 0x00C8)
struct FAnimNode_TwoHandedIK final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         IKBone;                                            // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bAllowStretching : 1;                              // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartStretchRatio;                                 // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStretchScale;                                   // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0xC];                                       // 0x00E4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneSocketTarget                      JointTarget;                                       // 0x00F0(0x0060)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                JointTargetLocation;                               // 0x0150(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             JointTargetLocationSpace;                          // 0x015C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMaintainEffectorRelRot : 1;                       // 0x015D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bIsUsingFixedTarget;                               // 0x015E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15F[0x1];                                      // 0x015F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SlidingTransform;                                  // 0x0160(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              SlidingStretchBlendLimits;                         // 0x0190(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FixedTarget;                                       // 0x0198(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         MainHandWeaponBone;                                // 0x01A4(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         MainHandBone;                                      // 0x01B4(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         OffhandThumbFingerBone;                            // 0x01C4(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         OffhandIndexFingerBone;                            // 0x01D4(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         MainHandMiddleFingerBone;                          // 0x01E4(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0xC];                                      // 0x01F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_TwoHandedIK) == 0x000010, "Wrong alignment on FAnimNode_TwoHandedIK");
static_assert(sizeof(FAnimNode_TwoHandedIK) == 0x000200, "Wrong size on FAnimNode_TwoHandedIK");
static_assert(offsetof(FAnimNode_TwoHandedIK, IKBone) == 0x0000C8, "Member 'FAnimNode_TwoHandedIK::IKBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, StartStretchRatio) == 0x0000DC, "Member 'FAnimNode_TwoHandedIK::StartStretchRatio' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, MaxStretchScale) == 0x0000E0, "Member 'FAnimNode_TwoHandedIK::MaxStretchScale' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, JointTarget) == 0x0000F0, "Member 'FAnimNode_TwoHandedIK::JointTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, JointTargetLocation) == 0x000150, "Member 'FAnimNode_TwoHandedIK::JointTargetLocation' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, JointTargetLocationSpace) == 0x00015C, "Member 'FAnimNode_TwoHandedIK::JointTargetLocationSpace' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, bIsUsingFixedTarget) == 0x00015E, "Member 'FAnimNode_TwoHandedIK::bIsUsingFixedTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, SlidingTransform) == 0x000160, "Member 'FAnimNode_TwoHandedIK::SlidingTransform' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, SlidingStretchBlendLimits) == 0x000190, "Member 'FAnimNode_TwoHandedIK::SlidingStretchBlendLimits' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, FixedTarget) == 0x000198, "Member 'FAnimNode_TwoHandedIK::FixedTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, MainHandWeaponBone) == 0x0001A4, "Member 'FAnimNode_TwoHandedIK::MainHandWeaponBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, MainHandBone) == 0x0001B4, "Member 'FAnimNode_TwoHandedIK::MainHandBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, OffhandThumbFingerBone) == 0x0001C4, "Member 'FAnimNode_TwoHandedIK::OffhandThumbFingerBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, OffhandIndexFingerBone) == 0x0001D4, "Member 'FAnimNode_TwoHandedIK::OffhandIndexFingerBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoHandedIK, MainHandMiddleFingerBone) == 0x0001E4, "Member 'FAnimNode_TwoHandedIK::MainHandMiddleFingerBone' has a wrong offset!");

// ScriptStruct Mordhau.BasicServerInfo
// 0x0028 (0x0028 - 0x0000)
struct FBasicServerInfo
{
public:
	class FString                                 ServerName;                                        // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayers;                                        // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerId;                                          // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBasicServerInfo) == 0x000008, "Wrong alignment on FBasicServerInfo");
static_assert(sizeof(FBasicServerInfo) == 0x000028, "Wrong size on FBasicServerInfo");
static_assert(offsetof(FBasicServerInfo, ServerName) == 0x000000, "Member 'FBasicServerInfo::ServerName' has a wrong offset!");
static_assert(offsetof(FBasicServerInfo, MaxPlayers) == 0x000010, "Member 'FBasicServerInfo::MaxPlayers' has a wrong offset!");
static_assert(offsetof(FBasicServerInfo, ServerId) == 0x000018, "Member 'FBasicServerInfo::ServerId' has a wrong offset!");

// ScriptStruct Mordhau.PlayerStatisticValue
// 0x0018 (0x0018 - 0x0000)
struct FPlayerStatisticValue final
{
public:
	class FString                                 StatisticName;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Version;                                           // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerStatisticValue) == 0x000008, "Wrong alignment on FPlayerStatisticValue");
static_assert(sizeof(FPlayerStatisticValue) == 0x000018, "Wrong size on FPlayerStatisticValue");
static_assert(offsetof(FPlayerStatisticValue, StatisticName) == 0x000000, "Member 'FPlayerStatisticValue::StatisticName' has a wrong offset!");
static_assert(offsetof(FPlayerStatisticValue, Value) == 0x000010, "Member 'FPlayerStatisticValue::Value' has a wrong offset!");
static_assert(offsetof(FPlayerStatisticValue, Version) == 0x000014, "Member 'FPlayerStatisticValue::Version' has a wrong offset!");

// ScriptStruct Mordhau.SessionSearchResult
// 0x0108 (0x0108 - 0x0000)
struct alignas(0x08) FSessionSearchResult
{
public:
	uint8                                         Pad_0[0x108];                                      // 0x0000(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSessionSearchResult) == 0x000008, "Wrong alignment on FSessionSearchResult");
static_assert(sizeof(FSessionSearchResult) == 0x000108, "Wrong size on FSessionSearchResult");

// ScriptStruct Mordhau.AnimNode_SpeedWarping
// 0x00B8 (0x0180 - 0x00C8)
struct FAnimNode_SpeedWarping final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         Hips;                                              // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftLegTarget;                                     // 0x00D8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftUpLeg;                                         // 0x00E8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftFoot;                                          // 0x00F8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightLegTarget;                                    // 0x0108(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightUpLeg;                                        // 0x0118(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightFoot;                                         // 0x0128(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalLegLength;                                    // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Axis;                                              // 0x0140(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatSpringState                      SpringState;                                       // 0x014C(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         SpringStiffness;                                   // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringDamping;                                     // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringMass;                                        // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HipsOffsetRemapIn;                                 // 0x0160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HipsOffsetRemapOut;                                // 0x0168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              HipsOffsetClamp;                                   // 0x0170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HipsZOffset;                                       // 0x0178(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x017C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_SpeedWarping) == 0x000008, "Wrong alignment on FAnimNode_SpeedWarping");
static_assert(sizeof(FAnimNode_SpeedWarping) == 0x000180, "Wrong size on FAnimNode_SpeedWarping");
static_assert(offsetof(FAnimNode_SpeedWarping, Hips) == 0x0000C8, "Member 'FAnimNode_SpeedWarping::Hips' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, LeftLegTarget) == 0x0000D8, "Member 'FAnimNode_SpeedWarping::LeftLegTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, LeftUpLeg) == 0x0000E8, "Member 'FAnimNode_SpeedWarping::LeftUpLeg' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, LeftFoot) == 0x0000F8, "Member 'FAnimNode_SpeedWarping::LeftFoot' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, RightLegTarget) == 0x000108, "Member 'FAnimNode_SpeedWarping::RightLegTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, RightUpLeg) == 0x000118, "Member 'FAnimNode_SpeedWarping::RightUpLeg' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, RightFoot) == 0x000128, "Member 'FAnimNode_SpeedWarping::RightFoot' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, Speed) == 0x000138, "Member 'FAnimNode_SpeedWarping::Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, TotalLegLength) == 0x00013C, "Member 'FAnimNode_SpeedWarping::TotalLegLength' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, Axis) == 0x000140, "Member 'FAnimNode_SpeedWarping::Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, SpringState) == 0x00014C, "Member 'FAnimNode_SpeedWarping::SpringState' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, SpringStiffness) == 0x000154, "Member 'FAnimNode_SpeedWarping::SpringStiffness' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, SpringDamping) == 0x000158, "Member 'FAnimNode_SpeedWarping::SpringDamping' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, SpringMass) == 0x00015C, "Member 'FAnimNode_SpeedWarping::SpringMass' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, HipsOffsetRemapIn) == 0x000160, "Member 'FAnimNode_SpeedWarping::HipsOffsetRemapIn' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, HipsOffsetRemapOut) == 0x000168, "Member 'FAnimNode_SpeedWarping::HipsOffsetRemapOut' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, HipsOffsetClamp) == 0x000170, "Member 'FAnimNode_SpeedWarping::HipsOffsetClamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, HipsZOffset) == 0x000178, "Member 'FAnimNode_SpeedWarping::HipsZOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, DeltaTime) == 0x00017C, "Member 'FAnimNode_SpeedWarping::DeltaTime' has a wrong offset!");

// ScriptStruct Mordhau.ServerSearchResult
// 0x0008 (0x0110 - 0x0108)
struct FServerSearchResult final : public FSessionSearchResult
{
public:
	EServerList                                   ServerList;                                        // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FServerSearchResult) == 0x000008, "Wrong alignment on FServerSearchResult");
static_assert(sizeof(FServerSearchResult) == 0x000110, "Wrong size on FServerSearchResult");
static_assert(offsetof(FServerSearchResult, ServerList) == 0x000108, "Member 'FServerSearchResult::ServerList' has a wrong offset!");

// ScriptStruct Mordhau.SphericalLimbBounds
// 0x0034 (0x0034 - 0x0000)
struct FSphericalLimbBounds final
{
public:
	class FName                                   StartSocket;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndSocket;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoneStartCached;                                   // 0x001C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoneEndCached;                                     // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSphericalLimbBounds) == 0x000004, "Wrong alignment on FSphericalLimbBounds");
static_assert(sizeof(FSphericalLimbBounds) == 0x000034, "Wrong size on FSphericalLimbBounds");
static_assert(offsetof(FSphericalLimbBounds, StartSocket) == 0x000000, "Member 'FSphericalLimbBounds::StartSocket' has a wrong offset!");
static_assert(offsetof(FSphericalLimbBounds, EndSocket) == 0x000008, "Member 'FSphericalLimbBounds::EndSocket' has a wrong offset!");
static_assert(offsetof(FSphericalLimbBounds, Radius) == 0x000010, "Member 'FSphericalLimbBounds::Radius' has a wrong offset!");
static_assert(offsetof(FSphericalLimbBounds, AttachSocket) == 0x000014, "Member 'FSphericalLimbBounds::AttachSocket' has a wrong offset!");
static_assert(offsetof(FSphericalLimbBounds, BoneStartCached) == 0x00001C, "Member 'FSphericalLimbBounds::BoneStartCached' has a wrong offset!");
static_assert(offsetof(FSphericalLimbBounds, BoneEndCached) == 0x000028, "Member 'FSphericalLimbBounds::BoneEndCached' has a wrong offset!");

// ScriptStruct Mordhau.PerspectiveFloat
// 0x0008 (0x0008 - 0x0000)
struct FPerspectiveFloat final
{
public:
	float                                         ThirdPerson;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstPerson;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerspectiveFloat) == 0x000004, "Wrong alignment on FPerspectiveFloat");
static_assert(sizeof(FPerspectiveFloat) == 0x000008, "Wrong size on FPerspectiveFloat");
static_assert(offsetof(FPerspectiveFloat, ThirdPerson) == 0x000000, "Member 'FPerspectiveFloat::ThirdPerson' has a wrong offset!");
static_assert(offsetof(FPerspectiveFloat, FirstPerson) == 0x000004, "Member 'FPerspectiveFloat::FirstPerson' has a wrong offset!");

// ScriptStruct Mordhau.SteamPlayFabConversionResult
// 0x0050 (0x0050 - 0x0000)
struct FSteamPlayFabConversionResult final
{
public:
	TMap<class FString, class FString>            SteamIDPlayFabIDMap;                               // 0x0000(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSteamPlayFabConversionResult) == 0x000008, "Wrong alignment on FSteamPlayFabConversionResult");
static_assert(sizeof(FSteamPlayFabConversionResult) == 0x000050, "Wrong size on FSteamPlayFabConversionResult");
static_assert(offsetof(FSteamPlayFabConversionResult, SteamIDPlayFabIDMap) == 0x000000, "Member 'FSteamPlayFabConversionResult::SteamIDPlayFabIDMap' has a wrong offset!");

// ScriptStruct Mordhau.ServerRestrictionInfo
// 0x0010 (0x0010 - 0x0000)
struct FServerRestrictionInfo final
{
public:
	bool                                          bIsBanned;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BanDuration;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuted;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MuteDuration;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FServerRestrictionInfo) == 0x000004, "Wrong alignment on FServerRestrictionInfo");
static_assert(sizeof(FServerRestrictionInfo) == 0x000010, "Wrong size on FServerRestrictionInfo");
static_assert(offsetof(FServerRestrictionInfo, bIsBanned) == 0x000000, "Member 'FServerRestrictionInfo::bIsBanned' has a wrong offset!");
static_assert(offsetof(FServerRestrictionInfo, BanDuration) == 0x000004, "Member 'FServerRestrictionInfo::BanDuration' has a wrong offset!");
static_assert(offsetof(FServerRestrictionInfo, bIsMuted) == 0x000008, "Member 'FServerRestrictionInfo::bIsMuted' has a wrong offset!");
static_assert(offsetof(FServerRestrictionInfo, MuteDuration) == 0x00000C, "Member 'FServerRestrictionInfo::MuteDuration' has a wrong offset!");

// ScriptStruct Mordhau.CharState
// 0x0001 (0x0001 - 0x0000)
struct FCharState final
{
public:
	uint8                                         State;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharState) == 0x000001, "Wrong alignment on FCharState");
static_assert(sizeof(FCharState) == 0x000001, "Wrong size on FCharState");
static_assert(offsetof(FCharState, State) == 0x000000, "Member 'FCharState::State' has a wrong offset!");

// ScriptStruct Mordhau.PrePhysTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FPrePhysTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPrePhysTickFunction) == 0x000008, "Wrong alignment on FPrePhysTickFunction");
static_assert(sizeof(FPrePhysTickFunction) == 0x000030, "Wrong size on FPrePhysTickFunction");

// ScriptStruct Mordhau.SpineSpaceAdditive
// 0x0084 (0x0084 - 0x0000)
struct FSpineSpaceAdditive final
{
public:
	struct FRotator                               head;                                              // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Neck;                                              // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Spine1;                                            // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LeftShoulder;                                      // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LeftArm;                                           // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LeftForearm;                                       // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LeftHand;                                          // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RightShoulder;                                     // 0x0054(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RightArm;                                          // 0x0060(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RightForearm;                                      // 0x006C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RightHand;                                         // 0x0078(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpineSpaceAdditive) == 0x000004, "Wrong alignment on FSpineSpaceAdditive");
static_assert(sizeof(FSpineSpaceAdditive) == 0x000084, "Wrong size on FSpineSpaceAdditive");
static_assert(offsetof(FSpineSpaceAdditive, head) == 0x000000, "Member 'FSpineSpaceAdditive::head' has a wrong offset!");
static_assert(offsetof(FSpineSpaceAdditive, Neck) == 0x00000C, "Member 'FSpineSpaceAdditive::Neck' has a wrong offset!");
static_assert(offsetof(FSpineSpaceAdditive, Spine1) == 0x000018, "Member 'FSpineSpaceAdditive::Spine1' has a wrong offset!");
static_assert(offsetof(FSpineSpaceAdditive, LeftShoulder) == 0x000024, "Member 'FSpineSpaceAdditive::LeftShoulder' has a wrong offset!");
static_assert(offsetof(FSpineSpaceAdditive, LeftArm) == 0x000030, "Member 'FSpineSpaceAdditive::LeftArm' has a wrong offset!");
static_assert(offsetof(FSpineSpaceAdditive, LeftForearm) == 0x00003C, "Member 'FSpineSpaceAdditive::LeftForearm' has a wrong offset!");
static_assert(offsetof(FSpineSpaceAdditive, LeftHand) == 0x000048, "Member 'FSpineSpaceAdditive::LeftHand' has a wrong offset!");
static_assert(offsetof(FSpineSpaceAdditive, RightShoulder) == 0x000054, "Member 'FSpineSpaceAdditive::RightShoulder' has a wrong offset!");
static_assert(offsetof(FSpineSpaceAdditive, RightArm) == 0x000060, "Member 'FSpineSpaceAdditive::RightArm' has a wrong offset!");
static_assert(offsetof(FSpineSpaceAdditive, RightForearm) == 0x00006C, "Member 'FSpineSpaceAdditive::RightForearm' has a wrong offset!");
static_assert(offsetof(FSpineSpaceAdditive, RightHand) == 0x000078, "Member 'FSpineSpaceAdditive::RightHand' has a wrong offset!");

// ScriptStruct Mordhau.AnimNode_AttackAngling
// 0x0138 (0x0200 - 0x00C8)
struct FAnimNode_AttackAngling final : public FAnimNode_SkeletalControlBase
{
public:
	struct FSpineSpaceAdditive                    SpineSpaceAdditivePose;                            // 0x00C8(0x0084)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         head;                                              // 0x014C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Neck;                                              // 0x015C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Spine;                                             // 0x016C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftShoulder;                                      // 0x017C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftArm;                                           // 0x018C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftForearm;                                       // 0x019C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftHand;                                          // 0x01AC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightShoulder;                                     // 0x01BC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightArm;                                          // 0x01CC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightForearm;                                      // 0x01DC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightHand;                                         // 0x01EC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_AttackAngling) == 0x000008, "Wrong alignment on FAnimNode_AttackAngling");
static_assert(sizeof(FAnimNode_AttackAngling) == 0x000200, "Wrong size on FAnimNode_AttackAngling");
static_assert(offsetof(FAnimNode_AttackAngling, SpineSpaceAdditivePose) == 0x0000C8, "Member 'FAnimNode_AttackAngling::SpineSpaceAdditivePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_AttackAngling, head) == 0x00014C, "Member 'FAnimNode_AttackAngling::head' has a wrong offset!");
static_assert(offsetof(FAnimNode_AttackAngling, Neck) == 0x00015C, "Member 'FAnimNode_AttackAngling::Neck' has a wrong offset!");
static_assert(offsetof(FAnimNode_AttackAngling, Spine) == 0x00016C, "Member 'FAnimNode_AttackAngling::Spine' has a wrong offset!");
static_assert(offsetof(FAnimNode_AttackAngling, LeftShoulder) == 0x00017C, "Member 'FAnimNode_AttackAngling::LeftShoulder' has a wrong offset!");
static_assert(offsetof(FAnimNode_AttackAngling, LeftArm) == 0x00018C, "Member 'FAnimNode_AttackAngling::LeftArm' has a wrong offset!");
static_assert(offsetof(FAnimNode_AttackAngling, LeftForearm) == 0x00019C, "Member 'FAnimNode_AttackAngling::LeftForearm' has a wrong offset!");
static_assert(offsetof(FAnimNode_AttackAngling, LeftHand) == 0x0001AC, "Member 'FAnimNode_AttackAngling::LeftHand' has a wrong offset!");
static_assert(offsetof(FAnimNode_AttackAngling, RightShoulder) == 0x0001BC, "Member 'FAnimNode_AttackAngling::RightShoulder' has a wrong offset!");
static_assert(offsetof(FAnimNode_AttackAngling, RightArm) == 0x0001CC, "Member 'FAnimNode_AttackAngling::RightArm' has a wrong offset!");
static_assert(offsetof(FAnimNode_AttackAngling, RightForearm) == 0x0001DC, "Member 'FAnimNode_AttackAngling::RightForearm' has a wrong offset!");
static_assert(offsetof(FAnimNode_AttackAngling, RightHand) == 0x0001EC, "Member 'FAnimNode_AttackAngling::RightHand' has a wrong offset!");

// ScriptStruct Mordhau.AnimNode_BlendBetweenBones
// 0x0048 (0x0110 - 0x00C8)
struct FAnimNode_BlendBetweenBones final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         BoneToModify;                                      // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         BlendBoneA;                                        // 0x00D8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         BlendBoneB;                                        // 0x00E8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ReferenceBlendBone;                                // 0x00F8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BlendBetweenAlpha;                                 // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_BlendBetweenBones) == 0x000008, "Wrong alignment on FAnimNode_BlendBetweenBones");
static_assert(sizeof(FAnimNode_BlendBetweenBones) == 0x000110, "Wrong size on FAnimNode_BlendBetweenBones");
static_assert(offsetof(FAnimNode_BlendBetweenBones, BoneToModify) == 0x0000C8, "Member 'FAnimNode_BlendBetweenBones::BoneToModify' has a wrong offset!");
static_assert(offsetof(FAnimNode_BlendBetweenBones, BlendBoneA) == 0x0000D8, "Member 'FAnimNode_BlendBetweenBones::BlendBoneA' has a wrong offset!");
static_assert(offsetof(FAnimNode_BlendBetweenBones, BlendBoneB) == 0x0000E8, "Member 'FAnimNode_BlendBetweenBones::BlendBoneB' has a wrong offset!");
static_assert(offsetof(FAnimNode_BlendBetweenBones, ReferenceBlendBone) == 0x0000F8, "Member 'FAnimNode_BlendBetweenBones::ReferenceBlendBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_BlendBetweenBones, BlendBetweenAlpha) == 0x000108, "Member 'FAnimNode_BlendBetweenBones::BlendBetweenAlpha' has a wrong offset!");

// ScriptStruct Mordhau.AnimNodePackedDismemberment
// 0x0010 (0x0010 - 0x0000)
struct FAnimNodePackedDismemberment final
{
public:
	TArray<int32>                                 DismemberedBonesIndices;                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNodePackedDismemberment) == 0x000008, "Wrong alignment on FAnimNodePackedDismemberment");
static_assert(sizeof(FAnimNodePackedDismemberment) == 0x000010, "Wrong size on FAnimNodePackedDismemberment");
static_assert(offsetof(FAnimNodePackedDismemberment, DismemberedBonesIndices) == 0x000000, "Member 'FAnimNodePackedDismemberment::DismemberedBonesIndices' has a wrong offset!");

// ScriptStruct Mordhau.AnimNode_Dismemberment
// 0x0010 (0x00D8 - 0x00C8)
struct FAnimNode_Dismemberment final : public FAnimNode_SkeletalControlBase
{
public:
	struct FAnimNodePackedDismemberment           Dismemberment;                                     // 0x00C8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_Dismemberment) == 0x000008, "Wrong alignment on FAnimNode_Dismemberment");
static_assert(sizeof(FAnimNode_Dismemberment) == 0x0000D8, "Wrong size on FAnimNode_Dismemberment");
static_assert(offsetof(FAnimNode_Dismemberment, Dismemberment) == 0x0000C8, "Member 'FAnimNode_Dismemberment::Dismemberment' has a wrong offset!");

// ScriptStruct Mordhau.FacialBoneSetup
// 0x0088 (0x0088 - 0x0000)
struct FFacialBoneSetup final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelectionBoneOverride;                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSymmetrical;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SelectionBiasFactor;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ChildBones;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SymmetryTwinBoneIndex;                             // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SymmetryTwinBoneName;                              // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoneIndex;                                         // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TranslateXRange;                                   // 0x003C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TranslateYRange;                                   // 0x0044(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TranslateZRange;                                   // 0x004C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScaleXRange;                                       // 0x0054(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScaleYRange;                                       // 0x005C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScaleZRange;                                       // 0x0064(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotateXRange;                                      // 0x006C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotateYRange;                                      // 0x0074(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotateZRange;                                      // 0x007C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFacialBoneSetup) == 0x000008, "Wrong alignment on FFacialBoneSetup");
static_assert(sizeof(FFacialBoneSetup) == 0x000088, "Wrong size on FFacialBoneSetup");
static_assert(offsetof(FFacialBoneSetup, BoneName) == 0x000000, "Member 'FFacialBoneSetup::BoneName' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, SelectionBoneOverride) == 0x000008, "Member 'FFacialBoneSetup::SelectionBoneOverride' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, bIsSymmetrical) == 0x000010, "Member 'FFacialBoneSetup::bIsSymmetrical' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, SelectionBiasFactor) == 0x000014, "Member 'FFacialBoneSetup::SelectionBiasFactor' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, ChildBones) == 0x000018, "Member 'FFacialBoneSetup::ChildBones' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, Level) == 0x000028, "Member 'FFacialBoneSetup::Level' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, SymmetryTwinBoneIndex) == 0x00002C, "Member 'FFacialBoneSetup::SymmetryTwinBoneIndex' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, SymmetryTwinBoneName) == 0x000030, "Member 'FFacialBoneSetup::SymmetryTwinBoneName' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, BoneIndex) == 0x000038, "Member 'FFacialBoneSetup::BoneIndex' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, TranslateXRange) == 0x00003C, "Member 'FFacialBoneSetup::TranslateXRange' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, TranslateYRange) == 0x000044, "Member 'FFacialBoneSetup::TranslateYRange' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, TranslateZRange) == 0x00004C, "Member 'FFacialBoneSetup::TranslateZRange' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, ScaleXRange) == 0x000054, "Member 'FFacialBoneSetup::ScaleXRange' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, ScaleYRange) == 0x00005C, "Member 'FFacialBoneSetup::ScaleYRange' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, ScaleZRange) == 0x000064, "Member 'FFacialBoneSetup::ScaleZRange' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, RotateXRange) == 0x00006C, "Member 'FFacialBoneSetup::RotateXRange' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, RotateYRange) == 0x000074, "Member 'FFacialBoneSetup::RotateYRange' has a wrong offset!");
static_assert(offsetof(FFacialBoneSetup, RotateZRange) == 0x00007C, "Member 'FFacialBoneSetup::RotateZRange' has a wrong offset!");

// ScriptStruct Mordhau.AnimNodePackedFaceCustomization
// 0x0020 (0x0020 - 0x0000)
struct FAnimNodePackedFaceCustomization final
{
public:
	TArray<struct FFacialBoneSetup>               FaceCustomizationSetup;                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     FaceCustomizationBonesTransforms;                  // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNodePackedFaceCustomization) == 0x000008, "Wrong alignment on FAnimNodePackedFaceCustomization");
static_assert(sizeof(FAnimNodePackedFaceCustomization) == 0x000020, "Wrong size on FAnimNodePackedFaceCustomization");
static_assert(offsetof(FAnimNodePackedFaceCustomization, FaceCustomizationSetup) == 0x000000, "Member 'FAnimNodePackedFaceCustomization::FaceCustomizationSetup' has a wrong offset!");
static_assert(offsetof(FAnimNodePackedFaceCustomization, FaceCustomizationBonesTransforms) == 0x000010, "Member 'FAnimNodePackedFaceCustomization::FaceCustomizationBonesTransforms' has a wrong offset!");

// ScriptStruct Mordhau.AnimNode_FaceCustomization
// 0x0020 (0x00E8 - 0x00C8)
struct FAnimNode_FaceCustomization final : public FAnimNode_SkeletalControlBase
{
public:
	struct FAnimNodePackedFaceCustomization       FaceCustomization;                                 // 0x00C8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_FaceCustomization) == 0x000008, "Wrong alignment on FAnimNode_FaceCustomization");
static_assert(sizeof(FAnimNode_FaceCustomization) == 0x0000E8, "Wrong size on FAnimNode_FaceCustomization");
static_assert(offsetof(FAnimNode_FaceCustomization, FaceCustomization) == 0x0000C8, "Member 'FAnimNode_FaceCustomization::FaceCustomization' has a wrong offset!");

// ScriptStruct Mordhau.AnimNode_MordhauSpringBone
// 0x0080 (0x0148 - 0x00C8)
struct FAnimNode_MordhauSpringBone final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         bone;                                              // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsRotationSpring;                                 // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRotationFlipped;                                // 0x00D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoneOffset;                                        // 0x00DC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBoneOffsetInComponentSpace;                     // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BoneOffsetRotationProjection;                      // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringStiffness;                                   // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringDamping;                                     // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringMass;                                        // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDisplacement;                                   // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDisplacementLimits;                            // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DisplacementLimitsMin;                             // 0x0104(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DisplacementLimitsMax;                             // 0x0110(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportThreshold;                                 // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoneLocation;                                      // 0x0120(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVectorSpringState                     SpringState;                                       // 0x012C(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0144(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_MordhauSpringBone) == 0x000008, "Wrong alignment on FAnimNode_MordhauSpringBone");
static_assert(sizeof(FAnimNode_MordhauSpringBone) == 0x000148, "Wrong size on FAnimNode_MordhauSpringBone");
static_assert(offsetof(FAnimNode_MordhauSpringBone, bone) == 0x0000C8, "Member 'FAnimNode_MordhauSpringBone::bone' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, bIsRotationSpring) == 0x0000D8, "Member 'FAnimNode_MordhauSpringBone::bIsRotationSpring' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, bIsRotationFlipped) == 0x0000D9, "Member 'FAnimNode_MordhauSpringBone::bIsRotationFlipped' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, BoneOffset) == 0x0000DC, "Member 'FAnimNode_MordhauSpringBone::BoneOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, bIsBoneOffsetInComponentSpace) == 0x0000E8, "Member 'FAnimNode_MordhauSpringBone::bIsBoneOffsetInComponentSpace' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, BoneOffsetRotationProjection) == 0x0000EC, "Member 'FAnimNode_MordhauSpringBone::BoneOffsetRotationProjection' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, SpringStiffness) == 0x0000F0, "Member 'FAnimNode_MordhauSpringBone::SpringStiffness' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, SpringDamping) == 0x0000F4, "Member 'FAnimNode_MordhauSpringBone::SpringDamping' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, SpringMass) == 0x0000F8, "Member 'FAnimNode_MordhauSpringBone::SpringMass' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, MaxDisplacement) == 0x0000FC, "Member 'FAnimNode_MordhauSpringBone::MaxDisplacement' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, bUseDisplacementLimits) == 0x000100, "Member 'FAnimNode_MordhauSpringBone::bUseDisplacementLimits' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, DisplacementLimitsMin) == 0x000104, "Member 'FAnimNode_MordhauSpringBone::DisplacementLimitsMin' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, DisplacementLimitsMax) == 0x000110, "Member 'FAnimNode_MordhauSpringBone::DisplacementLimitsMax' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, TeleportThreshold) == 0x00011C, "Member 'FAnimNode_MordhauSpringBone::TeleportThreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, BoneLocation) == 0x000120, "Member 'FAnimNode_MordhauSpringBone::BoneLocation' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, SpringState) == 0x00012C, "Member 'FAnimNode_MordhauSpringBone::SpringState' has a wrong offset!");
static_assert(offsetof(FAnimNode_MordhauSpringBone, DeltaTime) == 0x000144, "Member 'FAnimNode_MordhauSpringBone::DeltaTime' has a wrong offset!");

// ScriptStruct Mordhau.AnimNode_RotateAroundPivot
// 0x0030 (0x00F8 - 0x00C8)
struct FAnimNode_RotateAroundPivot final : public FAnimNode_SkeletalControlBase
{
public:
	EBoneControlSpace                             Space;                                             // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         BoneToModify;                                      // 0x00CC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x00DC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Pivot;                                             // 0x00E8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_RotateAroundPivot) == 0x000008, "Wrong alignment on FAnimNode_RotateAroundPivot");
static_assert(sizeof(FAnimNode_RotateAroundPivot) == 0x0000F8, "Wrong size on FAnimNode_RotateAroundPivot");
static_assert(offsetof(FAnimNode_RotateAroundPivot, Space) == 0x0000C8, "Member 'FAnimNode_RotateAroundPivot::Space' has a wrong offset!");
static_assert(offsetof(FAnimNode_RotateAroundPivot, BoneToModify) == 0x0000CC, "Member 'FAnimNode_RotateAroundPivot::BoneToModify' has a wrong offset!");
static_assert(offsetof(FAnimNode_RotateAroundPivot, Rotation) == 0x0000DC, "Member 'FAnimNode_RotateAroundPivot::Rotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_RotateAroundPivot, Pivot) == 0x0000E8, "Member 'FAnimNode_RotateAroundPivot::Pivot' has a wrong offset!");

// ScriptStruct Mordhau.AnimNode_SpineSpreader
// 0x0058 (0x0120 - 0x00C8)
struct FAnimNode_SpineSpreader final : public FAnimNode_SkeletalControlBase
{
public:
	float                                         SpreadPercentage;                                  // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         Spine1;                                            // 0x00CC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightShoulder;                                     // 0x00DC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightArm;                                          // 0x00EC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightForearm;                                      // 0x00FC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightHand;                                         // 0x010C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_SpineSpreader) == 0x000008, "Wrong alignment on FAnimNode_SpineSpreader");
static_assert(sizeof(FAnimNode_SpineSpreader) == 0x000120, "Wrong size on FAnimNode_SpineSpreader");
static_assert(offsetof(FAnimNode_SpineSpreader, SpreadPercentage) == 0x0000C8, "Member 'FAnimNode_SpineSpreader::SpreadPercentage' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpineSpreader, Spine1) == 0x0000CC, "Member 'FAnimNode_SpineSpreader::Spine1' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpineSpreader, RightShoulder) == 0x0000DC, "Member 'FAnimNode_SpineSpreader::RightShoulder' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpineSpreader, RightArm) == 0x0000EC, "Member 'FAnimNode_SpineSpreader::RightArm' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpineSpreader, RightForearm) == 0x0000FC, "Member 'FAnimNode_SpineSpreader::RightForearm' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpineSpreader, RightHand) == 0x00010C, "Member 'FAnimNode_SpineSpreader::RightHand' has a wrong offset!");

// ScriptStruct Mordhau.AnimNode_StopBounces
// 0x0150 (0x0218 - 0x00C8)
struct FAnimNode_StopBounces final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         Hips;                                              // 0x00C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftUpLeg;                                         // 0x00D8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftLeg;                                           // 0x00E8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftFoot;                                          // 0x00F8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightUpLeg;                                        // 0x0108(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightLeg;                                          // 0x0118(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightFoot;                                         // 0x0128(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LowerBack;                                         // 0x0138(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Spine;                                             // 0x0148(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Spine1;                                            // 0x0158(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Neck;                                              // 0x0168(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         head;                                              // 0x0178(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftShoulder;                                      // 0x0188(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightShoulder;                                     // 0x0198(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftArm;                                           // 0x01A8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightArm;                                          // 0x01B8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BounceDuckWithBounceWeight;                        // 0x01C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StopBounce;                                        // 0x01D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         NotFirstPersonWithAtmosphericsAndAnimLOD1;         // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotateAroundHipsPivot;                             // 0x01E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftFootTranslation;                               // 0x01F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightFootTranslation;                              // 0x01FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopBounceMediumWeight;                            // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopBounceLightWeight;                             // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InverseHeadWeight;                                 // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_StopBounces) == 0x000008, "Wrong alignment on FAnimNode_StopBounces");
static_assert(sizeof(FAnimNode_StopBounces) == 0x000218, "Wrong size on FAnimNode_StopBounces");
static_assert(offsetof(FAnimNode_StopBounces, Hips) == 0x0000C8, "Member 'FAnimNode_StopBounces::Hips' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, LeftUpLeg) == 0x0000D8, "Member 'FAnimNode_StopBounces::LeftUpLeg' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, LeftLeg) == 0x0000E8, "Member 'FAnimNode_StopBounces::LeftLeg' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, LeftFoot) == 0x0000F8, "Member 'FAnimNode_StopBounces::LeftFoot' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, RightUpLeg) == 0x000108, "Member 'FAnimNode_StopBounces::RightUpLeg' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, RightLeg) == 0x000118, "Member 'FAnimNode_StopBounces::RightLeg' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, RightFoot) == 0x000128, "Member 'FAnimNode_StopBounces::RightFoot' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, LowerBack) == 0x000138, "Member 'FAnimNode_StopBounces::LowerBack' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, Spine) == 0x000148, "Member 'FAnimNode_StopBounces::Spine' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, Spine1) == 0x000158, "Member 'FAnimNode_StopBounces::Spine1' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, Neck) == 0x000168, "Member 'FAnimNode_StopBounces::Neck' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, head) == 0x000178, "Member 'FAnimNode_StopBounces::head' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, LeftShoulder) == 0x000188, "Member 'FAnimNode_StopBounces::LeftShoulder' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, RightShoulder) == 0x000198, "Member 'FAnimNode_StopBounces::RightShoulder' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, LeftArm) == 0x0001A8, "Member 'FAnimNode_StopBounces::LeftArm' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, RightArm) == 0x0001B8, "Member 'FAnimNode_StopBounces::RightArm' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, BounceDuckWithBounceWeight) == 0x0001C8, "Member 'FAnimNode_StopBounces::BounceDuckWithBounceWeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, StopBounce) == 0x0001D4, "Member 'FAnimNode_StopBounces::StopBounce' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, NotFirstPersonWithAtmosphericsAndAnimLOD1) == 0x0001E0, "Member 'FAnimNode_StopBounces::NotFirstPersonWithAtmosphericsAndAnimLOD1' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, RotateAroundHipsPivot) == 0x0001E4, "Member 'FAnimNode_StopBounces::RotateAroundHipsPivot' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, LeftFootTranslation) == 0x0001F0, "Member 'FAnimNode_StopBounces::LeftFootTranslation' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, RightFootTranslation) == 0x0001FC, "Member 'FAnimNode_StopBounces::RightFootTranslation' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, StopBounceMediumWeight) == 0x000208, "Member 'FAnimNode_StopBounces::StopBounceMediumWeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, StopBounceLightWeight) == 0x00020C, "Member 'FAnimNode_StopBounces::StopBounceLightWeight' has a wrong offset!");
static_assert(offsetof(FAnimNode_StopBounces, InverseHeadWeight) == 0x000210, "Member 'FAnimNode_StopBounces::InverseHeadWeight' has a wrong offset!");

// ScriptStruct Mordhau.AnimNode_TwoBoneIKOffset
// 0x0030 (0x0210 - 0x01E0)
struct FAnimNode_TwoBoneIKOffset final : public FAnimNode_TwoBoneIK
{
public:
	struct FVector                                OffsetVector;                                      // 0x01D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotateEndBonePivot;                                // 0x01E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotateEndBoneOffset;                               // 0x01F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseParentZLimit;                                  // 0x01FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD[0x3];                                      // 0x01FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ParentZLimitOffset;                                // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEffectorLocationIsOffset;                         // 0x0204(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_205[0xB];                                      // 0x0205(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_TwoBoneIKOffset) == 0x000010, "Wrong alignment on FAnimNode_TwoBoneIKOffset");
static_assert(sizeof(FAnimNode_TwoBoneIKOffset) == 0x000210, "Wrong size on FAnimNode_TwoBoneIKOffset");
static_assert(offsetof(FAnimNode_TwoBoneIKOffset, OffsetVector) == 0x0001D8, "Member 'FAnimNode_TwoBoneIKOffset::OffsetVector' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoBoneIKOffset, RotateEndBonePivot) == 0x0001E4, "Member 'FAnimNode_TwoBoneIKOffset::RotateEndBonePivot' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoBoneIKOffset, RotateEndBoneOffset) == 0x0001F0, "Member 'FAnimNode_TwoBoneIKOffset::RotateEndBoneOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoBoneIKOffset, bUseParentZLimit) == 0x0001FC, "Member 'FAnimNode_TwoBoneIKOffset::bUseParentZLimit' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoBoneIKOffset, ParentZLimitOffset) == 0x000200, "Member 'FAnimNode_TwoBoneIKOffset::ParentZLimitOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_TwoBoneIKOffset, bEffectorLocationIsOffset) == 0x000204, "Member 'FAnimNode_TwoBoneIKOffset::bEffectorLocationIsOffset' has a wrong offset!");

// ScriptStruct Mordhau.AnimNode_WeightShift
// 0x0050 (0x0118 - 0x00C8)
struct FAnimNode_WeightShift final : public FAnimNode_SkeletalControlBase
{
public:
	EBoneControlSpace                             Space;                                             // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         BoneToModify;                                      // 0x00CC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Bone1ToMaintain;                                   // 0x00DC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Bone2ToMaintain;                                   // 0x00EC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x00FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Pivot;                                             // 0x0108(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_WeightShift) == 0x000008, "Wrong alignment on FAnimNode_WeightShift");
static_assert(sizeof(FAnimNode_WeightShift) == 0x000118, "Wrong size on FAnimNode_WeightShift");
static_assert(offsetof(FAnimNode_WeightShift, Space) == 0x0000C8, "Member 'FAnimNode_WeightShift::Space' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeightShift, BoneToModify) == 0x0000CC, "Member 'FAnimNode_WeightShift::BoneToModify' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeightShift, Bone1ToMaintain) == 0x0000DC, "Member 'FAnimNode_WeightShift::Bone1ToMaintain' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeightShift, Bone2ToMaintain) == 0x0000EC, "Member 'FAnimNode_WeightShift::Bone2ToMaintain' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeightShift, Rotation) == 0x0000FC, "Member 'FAnimNode_WeightShift::Rotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_WeightShift, Pivot) == 0x000108, "Member 'FAnimNode_WeightShift::Pivot' has a wrong offset!");

// ScriptStruct Mordhau.WoundInfo
// 0x0014 (0x0014 - 0x0000)
struct FWoundInfo final
{
public:
	struct FVector2D                              WoundType;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WoundSize;                                         // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWoundInfo) == 0x000004, "Wrong alignment on FWoundInfo");
static_assert(sizeof(FWoundInfo) == 0x000014, "Wrong size on FWoundInfo");
static_assert(offsetof(FWoundInfo, WoundType) == 0x000000, "Member 'FWoundInfo::WoundType' has a wrong offset!");
static_assert(offsetof(FWoundInfo, WoundSize) == 0x000008, "Member 'FWoundInfo::WoundSize' has a wrong offset!");

// ScriptStruct Mordhau.AttackInfo
// 0x0128 (0x0128 - 0x0000)
struct FAttackInfo final
{
public:
	bool                                          bCanCombo;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanMissCombo;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForcesRearingFromFront;                           // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoFlinch;                                         // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoReleaseFlinch;                                  // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlinchSpeedModifier;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlinchDurationModifier;                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Windup;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ComboWindupIncrease;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissComboExtraWindupIncrease;                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Release;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FeintLockOut;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FeintCost;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChamberFeintCost;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChamberCost;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MorphCost;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TurnCaps;                                          // 0x0034(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TurnCapCurve;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            HitEffectIKWeightCurve;                            // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEffectSpeedUpExponent;                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaminaDrain;                                      // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraStaminaDrainVsHeldBlock;                      // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaminaDamage;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Damage;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 HeadBonus;                                         // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 LegBonus;                                          // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         WoodDamage;                                        // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StoneDamage;                                       // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopOnHit;                                        // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrainAllStamOnBlock;                              // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRagdollOnBlock;                                   // 0x009A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B[0x1];                                       // 0x009B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChipDamagePercentageOnBlock;                       // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWillClashWhenParried;                             // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRagdollOnHit;                                     // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDismountsHorseRider;                              // 0x00A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDismountsLadderUser;                              // 0x00A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissStaminaCost;                                   // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStaminaReward;                                  // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissRecovery;                                      // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitKockbackFactor;                                 // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowAttackDirectionFactor;                       // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWoundInfo>                     WoundInfoArray;                                    // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        HitShake;                                          // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMatineeCameraShake>        HitStopShake;                                      // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FName>                             IgnoreBones;                                       // 0x00D8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackInfo) == 0x000008, "Wrong alignment on FAttackInfo");
static_assert(sizeof(FAttackInfo) == 0x000128, "Wrong size on FAttackInfo");
static_assert(offsetof(FAttackInfo, bCanCombo) == 0x000000, "Member 'FAttackInfo::bCanCombo' has a wrong offset!");
static_assert(offsetof(FAttackInfo, bCanMissCombo) == 0x000001, "Member 'FAttackInfo::bCanMissCombo' has a wrong offset!");
static_assert(offsetof(FAttackInfo, bForcesRearingFromFront) == 0x000002, "Member 'FAttackInfo::bForcesRearingFromFront' has a wrong offset!");
static_assert(offsetof(FAttackInfo, bNoFlinch) == 0x000003, "Member 'FAttackInfo::bNoFlinch' has a wrong offset!");
static_assert(offsetof(FAttackInfo, bNoReleaseFlinch) == 0x000004, "Member 'FAttackInfo::bNoReleaseFlinch' has a wrong offset!");
static_assert(offsetof(FAttackInfo, FlinchSpeedModifier) == 0x000008, "Member 'FAttackInfo::FlinchSpeedModifier' has a wrong offset!");
static_assert(offsetof(FAttackInfo, FlinchDurationModifier) == 0x00000C, "Member 'FAttackInfo::FlinchDurationModifier' has a wrong offset!");
static_assert(offsetof(FAttackInfo, Windup) == 0x000010, "Member 'FAttackInfo::Windup' has a wrong offset!");
static_assert(offsetof(FAttackInfo, ComboWindupIncrease) == 0x000014, "Member 'FAttackInfo::ComboWindupIncrease' has a wrong offset!");
static_assert(offsetof(FAttackInfo, MissComboExtraWindupIncrease) == 0x000018, "Member 'FAttackInfo::MissComboExtraWindupIncrease' has a wrong offset!");
static_assert(offsetof(FAttackInfo, Release) == 0x00001C, "Member 'FAttackInfo::Release' has a wrong offset!");
static_assert(offsetof(FAttackInfo, FeintLockOut) == 0x000020, "Member 'FAttackInfo::FeintLockOut' has a wrong offset!");
static_assert(offsetof(FAttackInfo, FeintCost) == 0x000024, "Member 'FAttackInfo::FeintCost' has a wrong offset!");
static_assert(offsetof(FAttackInfo, ChamberFeintCost) == 0x000028, "Member 'FAttackInfo::ChamberFeintCost' has a wrong offset!");
static_assert(offsetof(FAttackInfo, ChamberCost) == 0x00002C, "Member 'FAttackInfo::ChamberCost' has a wrong offset!");
static_assert(offsetof(FAttackInfo, MorphCost) == 0x000030, "Member 'FAttackInfo::MorphCost' has a wrong offset!");
static_assert(offsetof(FAttackInfo, TurnCaps) == 0x000034, "Member 'FAttackInfo::TurnCaps' has a wrong offset!");
static_assert(offsetof(FAttackInfo, TurnCapCurve) == 0x000040, "Member 'FAttackInfo::TurnCapCurve' has a wrong offset!");
static_assert(offsetof(FAttackInfo, HitEffectIKWeightCurve) == 0x000048, "Member 'FAttackInfo::HitEffectIKWeightCurve' has a wrong offset!");
static_assert(offsetof(FAttackInfo, HitEffectSpeedUpExponent) == 0x000050, "Member 'FAttackInfo::HitEffectSpeedUpExponent' has a wrong offset!");
static_assert(offsetof(FAttackInfo, StaminaDrain) == 0x000054, "Member 'FAttackInfo::StaminaDrain' has a wrong offset!");
static_assert(offsetof(FAttackInfo, ExtraStaminaDrainVsHeldBlock) == 0x000058, "Member 'FAttackInfo::ExtraStaminaDrainVsHeldBlock' has a wrong offset!");
static_assert(offsetof(FAttackInfo, StaminaDamage) == 0x00005C, "Member 'FAttackInfo::StaminaDamage' has a wrong offset!");
static_assert(offsetof(FAttackInfo, Damage) == 0x000060, "Member 'FAttackInfo::Damage' has a wrong offset!");
static_assert(offsetof(FAttackInfo, HeadBonus) == 0x000070, "Member 'FAttackInfo::HeadBonus' has a wrong offset!");
static_assert(offsetof(FAttackInfo, LegBonus) == 0x000080, "Member 'FAttackInfo::LegBonus' has a wrong offset!");
static_assert(offsetof(FAttackInfo, WoodDamage) == 0x000090, "Member 'FAttackInfo::WoodDamage' has a wrong offset!");
static_assert(offsetof(FAttackInfo, StoneDamage) == 0x000094, "Member 'FAttackInfo::StoneDamage' has a wrong offset!");
static_assert(offsetof(FAttackInfo, bStopOnHit) == 0x000098, "Member 'FAttackInfo::bStopOnHit' has a wrong offset!");
static_assert(offsetof(FAttackInfo, bDrainAllStamOnBlock) == 0x000099, "Member 'FAttackInfo::bDrainAllStamOnBlock' has a wrong offset!");
static_assert(offsetof(FAttackInfo, bRagdollOnBlock) == 0x00009A, "Member 'FAttackInfo::bRagdollOnBlock' has a wrong offset!");
static_assert(offsetof(FAttackInfo, ChipDamagePercentageOnBlock) == 0x00009C, "Member 'FAttackInfo::ChipDamagePercentageOnBlock' has a wrong offset!");
static_assert(offsetof(FAttackInfo, bWillClashWhenParried) == 0x0000A0, "Member 'FAttackInfo::bWillClashWhenParried' has a wrong offset!");
static_assert(offsetof(FAttackInfo, bRagdollOnHit) == 0x0000A1, "Member 'FAttackInfo::bRagdollOnHit' has a wrong offset!");
static_assert(offsetof(FAttackInfo, bDismountsHorseRider) == 0x0000A2, "Member 'FAttackInfo::bDismountsHorseRider' has a wrong offset!");
static_assert(offsetof(FAttackInfo, bDismountsLadderUser) == 0x0000A3, "Member 'FAttackInfo::bDismountsLadderUser' has a wrong offset!");
static_assert(offsetof(FAttackInfo, MissStaminaCost) == 0x0000A4, "Member 'FAttackInfo::MissStaminaCost' has a wrong offset!");
static_assert(offsetof(FAttackInfo, HitStaminaReward) == 0x0000A8, "Member 'FAttackInfo::HitStaminaReward' has a wrong offset!");
static_assert(offsetof(FAttackInfo, MissRecovery) == 0x0000AC, "Member 'FAttackInfo::MissRecovery' has a wrong offset!");
static_assert(offsetof(FAttackInfo, HitKockbackFactor) == 0x0000B0, "Member 'FAttackInfo::HitKockbackFactor' has a wrong offset!");
static_assert(offsetof(FAttackInfo, FollowAttackDirectionFactor) == 0x0000B4, "Member 'FAttackInfo::FollowAttackDirectionFactor' has a wrong offset!");
static_assert(offsetof(FAttackInfo, WoundInfoArray) == 0x0000B8, "Member 'FAttackInfo::WoundInfoArray' has a wrong offset!");
static_assert(offsetof(FAttackInfo, HitShake) == 0x0000C8, "Member 'FAttackInfo::HitShake' has a wrong offset!");
static_assert(offsetof(FAttackInfo, HitStopShake) == 0x0000D0, "Member 'FAttackInfo::HitStopShake' has a wrong offset!");
static_assert(offsetof(FAttackInfo, IgnoreBones) == 0x0000D8, "Member 'FAttackInfo::IgnoreBones' has a wrong offset!");

// ScriptStruct Mordhau.SpawnablePlaneInfo
// 0x0018 (0x0018 - 0x0000)
struct FSpawnablePlaneInfo final
{
public:
	float                                         Forward;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Backward;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Left;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Right;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightXAxisPercentage;                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftXAxisPercentage;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnablePlaneInfo) == 0x000004, "Wrong alignment on FSpawnablePlaneInfo");
static_assert(sizeof(FSpawnablePlaneInfo) == 0x000018, "Wrong size on FSpawnablePlaneInfo");
static_assert(offsetof(FSpawnablePlaneInfo, Forward) == 0x000000, "Member 'FSpawnablePlaneInfo::Forward' has a wrong offset!");
static_assert(offsetof(FSpawnablePlaneInfo, Backward) == 0x000004, "Member 'FSpawnablePlaneInfo::Backward' has a wrong offset!");
static_assert(offsetof(FSpawnablePlaneInfo, Left) == 0x000008, "Member 'FSpawnablePlaneInfo::Left' has a wrong offset!");
static_assert(offsetof(FSpawnablePlaneInfo, Right) == 0x00000C, "Member 'FSpawnablePlaneInfo::Right' has a wrong offset!");
static_assert(offsetof(FSpawnablePlaneInfo, RightXAxisPercentage) == 0x000010, "Member 'FSpawnablePlaneInfo::RightXAxisPercentage' has a wrong offset!");
static_assert(offsetof(FSpawnablePlaneInfo, LeftXAxisPercentage) == 0x000014, "Member 'FSpawnablePlaneInfo::LeftXAxisPercentage' has a wrong offset!");

// ScriptStruct Mordhau.SpawnablePlaneTraceResult
// 0x0280 (0x0280 - 0x0000)
struct alignas(0x10) FSpawnablePlaneTraceResult final
{
public:
	uint8                                         Pad_0[0x280];                                      // 0x0000(0x0280)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnablePlaneTraceResult) == 0x000010, "Wrong alignment on FSpawnablePlaneTraceResult");
static_assert(sizeof(FSpawnablePlaneTraceResult) == 0x000280, "Wrong size on FSpawnablePlaneTraceResult");

// ScriptStruct Mordhau.SpawnableObjectInfo
// 0x0098 (0x0098 - 0x0000)
struct FSpawnableObjectInfo final
{
public:
	class UStaticMesh*                            Preview;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          PreviewSkeletal;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Cost;                                              // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationOffset;                                    // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffsetPreview;                             // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               NotHitRotationPreviewOffset;                       // 0x002C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                NotHitLocationPreviewOffset;                       // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScalePreview;                                      // 0x0044(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisplayName;                                       // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlacableLimitName;                                 // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaceableLimitMax;                                 // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnActorOffset;                                  // 0x006C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotAttach;                                      // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoxCheckExtents;                                   // 0x007C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxCheckOffset;                                    // 0x0088(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnableObjectInfo) == 0x000008, "Wrong alignment on FSpawnableObjectInfo");
static_assert(sizeof(FSpawnableObjectInfo) == 0x000098, "Wrong size on FSpawnableObjectInfo");
static_assert(offsetof(FSpawnableObjectInfo, Preview) == 0x000000, "Member 'FSpawnableObjectInfo::Preview' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, PreviewSkeletal) == 0x000008, "Member 'FSpawnableObjectInfo::PreviewSkeletal' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, Cost) == 0x000010, "Member 'FSpawnableObjectInfo::Cost' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, RotationOffset) == 0x000014, "Member 'FSpawnableObjectInfo::RotationOffset' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, RotationOffsetPreview) == 0x000020, "Member 'FSpawnableObjectInfo::RotationOffsetPreview' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, NotHitRotationPreviewOffset) == 0x00002C, "Member 'FSpawnableObjectInfo::NotHitRotationPreviewOffset' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, NotHitLocationPreviewOffset) == 0x000038, "Member 'FSpawnableObjectInfo::NotHitLocationPreviewOffset' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, ScalePreview) == 0x000044, "Member 'FSpawnableObjectInfo::ScalePreview' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, ActorClass) == 0x000050, "Member 'FSpawnableObjectInfo::ActorClass' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, DisplayName) == 0x000058, "Member 'FSpawnableObjectInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, PlacableLimitName) == 0x000060, "Member 'FSpawnableObjectInfo::PlacableLimitName' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, PlaceableLimitMax) == 0x000068, "Member 'FSpawnableObjectInfo::PlaceableLimitMax' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, SpawnActorOffset) == 0x00006C, "Member 'FSpawnableObjectInfo::SpawnActorOffset' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, bDoNotAttach) == 0x000078, "Member 'FSpawnableObjectInfo::bDoNotAttach' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, BoxCheckExtents) == 0x00007C, "Member 'FSpawnableObjectInfo::BoxCheckExtents' has a wrong offset!");
static_assert(offsetof(FSpawnableObjectInfo, BoxCheckOffset) == 0x000088, "Member 'FSpawnableObjectInfo::BoxCheckOffset' has a wrong offset!");

// ScriptStruct Mordhau.ECSPostPhysicsTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FECSPostPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FECSPostPhysicsTickFunction) == 0x000008, "Wrong alignment on FECSPostPhysicsTickFunction");
static_assert(sizeof(FECSPostPhysicsTickFunction) == 0x000030, "Wrong size on FECSPostPhysicsTickFunction");

// ScriptStruct Mordhau.ECSDuringPhysicsTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FECSDuringPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FECSDuringPhysicsTickFunction) == 0x000008, "Wrong alignment on FECSDuringPhysicsTickFunction");
static_assert(sizeof(FECSDuringPhysicsTickFunction) == 0x000030, "Wrong size on FECSDuringPhysicsTickFunction");

// ScriptStruct Mordhau.CharMove
// 0x000C (0x000C - 0x0000)
struct FCharMove final
{
public:
	struct FVector                                TargetLocation;                                    // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharMove) == 0x000004, "Wrong alignment on FCharMove");
static_assert(sizeof(FCharMove) == 0x00000C, "Wrong size on FCharMove");
static_assert(offsetof(FCharMove, TargetLocation) == 0x000000, "Member 'FCharMove::TargetLocation' has a wrong offset!");

// ScriptStruct Mordhau.HorseGearInfo
// 0x0018 (0x0018 - 0x0000)
struct FHorseGearInfo final
{
public:
	float                                         MaxSpeed;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAcceleration;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowJump;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanRiderRegenHealth;                              // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanRiderRegenStamina;                             // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanHorseRegen;                                    // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatineeCameraShake>        HeadBobShake;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHorseGearInfo) == 0x000008, "Wrong alignment on FHorseGearInfo");
static_assert(sizeof(FHorseGearInfo) == 0x000018, "Wrong size on FHorseGearInfo");
static_assert(offsetof(FHorseGearInfo, MaxSpeed) == 0x000000, "Member 'FHorseGearInfo::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FHorseGearInfo, MaxAcceleration) == 0x000004, "Member 'FHorseGearInfo::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(FHorseGearInfo, bAllowJump) == 0x000008, "Member 'FHorseGearInfo::bAllowJump' has a wrong offset!");
static_assert(offsetof(FHorseGearInfo, bCanRiderRegenHealth) == 0x000009, "Member 'FHorseGearInfo::bCanRiderRegenHealth' has a wrong offset!");
static_assert(offsetof(FHorseGearInfo, bCanRiderRegenStamina) == 0x00000A, "Member 'FHorseGearInfo::bCanRiderRegenStamina' has a wrong offset!");
static_assert(offsetof(FHorseGearInfo, bCanHorseRegen) == 0x00000B, "Member 'FHorseGearInfo::bCanHorseRegen' has a wrong offset!");
static_assert(offsetof(FHorseGearInfo, HeadBobShake) == 0x000010, "Member 'FHorseGearInfo::HeadBobShake' has a wrong offset!");

// ScriptStruct Mordhau.WearableMaterials
// 0x0028 (0x0028 - 0x0000)
struct FWearableMaterials final
{
public:
	class UMaterialInterface*                     Masked;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaskedBlood;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Opaque;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     OpaqueBlood;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     IconGenerate;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWearableMaterials) == 0x000008, "Wrong alignment on FWearableMaterials");
static_assert(sizeof(FWearableMaterials) == 0x000028, "Wrong size on FWearableMaterials");
static_assert(offsetof(FWearableMaterials, Masked) == 0x000000, "Member 'FWearableMaterials::Masked' has a wrong offset!");
static_assert(offsetof(FWearableMaterials, MaskedBlood) == 0x000008, "Member 'FWearableMaterials::MaskedBlood' has a wrong offset!");
static_assert(offsetof(FWearableMaterials, Opaque) == 0x000010, "Member 'FWearableMaterials::Opaque' has a wrong offset!");
static_assert(offsetof(FWearableMaterials, OpaqueBlood) == 0x000018, "Member 'FWearableMaterials::OpaqueBlood' has a wrong offset!");
static_assert(offsetof(FWearableMaterials, IconGenerate) == 0x000020, "Member 'FWearableMaterials::IconGenerate' has a wrong offset!");

// ScriptStruct Mordhau.PerceptionInfo
// 0x0008 (0x0008 - 0x0000)
struct FPerceptionInfo final
{
public:
	bool                                          bSight;                                            // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHearing;                                          // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamage;                                           // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Team;                                              // 0x0003(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateTime;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerceptionInfo) == 0x000004, "Wrong alignment on FPerceptionInfo");
static_assert(sizeof(FPerceptionInfo) == 0x000008, "Wrong size on FPerceptionInfo");
static_assert(offsetof(FPerceptionInfo, bSight) == 0x000000, "Member 'FPerceptionInfo::bSight' has a wrong offset!");
static_assert(offsetof(FPerceptionInfo, bHearing) == 0x000001, "Member 'FPerceptionInfo::bHearing' has a wrong offset!");
static_assert(offsetof(FPerceptionInfo, bDamage) == 0x000002, "Member 'FPerceptionInfo::bDamage' has a wrong offset!");
static_assert(offsetof(FPerceptionInfo, Team) == 0x000003, "Member 'FPerceptionInfo::Team' has a wrong offset!");
static_assert(offsetof(FPerceptionInfo, UpdateTime) == 0x000004, "Member 'FPerceptionInfo::UpdateTime' has a wrong offset!");

// ScriptStruct Mordhau.CharacterInventory
// 0x0020 (0x0020 - 0x0000)
struct FCharacterInventory final
{
public:
	class AMordhauEquipment*                      RightHand;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMordhauEquipment*                      LeftHand;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AMordhauEquipment*>              Equipment;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterInventory) == 0x000008, "Wrong alignment on FCharacterInventory");
static_assert(sizeof(FCharacterInventory) == 0x000020, "Wrong size on FCharacterInventory");
static_assert(offsetof(FCharacterInventory, RightHand) == 0x000000, "Member 'FCharacterInventory::RightHand' has a wrong offset!");
static_assert(offsetof(FCharacterInventory, LeftHand) == 0x000008, "Member 'FCharacterInventory::LeftHand' has a wrong offset!");
static_assert(offsetof(FCharacterInventory, Equipment) == 0x000010, "Member 'FCharacterInventory::Equipment' has a wrong offset!");

// ScriptStruct Mordhau.DamageRecord
// 0x0010 (0x0010 - 0x0000)
struct FDamageRecord final
{
public:
	TWeakObjectPtr<class AController>             Source;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageRecord) == 0x000004, "Wrong alignment on FDamageRecord");
static_assert(sizeof(FDamageRecord) == 0x000010, "Wrong size on FDamageRecord");
static_assert(offsetof(FDamageRecord, Source) == 0x000000, "Member 'FDamageRecord::Source' has a wrong offset!");
static_assert(offsetof(FDamageRecord, Time) == 0x000008, "Member 'FDamageRecord::Time' has a wrong offset!");
static_assert(offsetof(FDamageRecord, Damage) == 0x00000C, "Member 'FDamageRecord::Damage' has a wrong offset!");

// ScriptStruct Mordhau.EmoteEntry
// 0x0008 (0x0008 - 0x0000)
struct FEmoteEntry final
{
public:
	TSubclassOf<class UEmoteMotion>               EmoteMotion;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmoteEntry) == 0x000008, "Wrong alignment on FEmoteEntry");
static_assert(sizeof(FEmoteEntry) == 0x000008, "Wrong size on FEmoteEntry");
static_assert(offsetof(FEmoteEntry, EmoteMotion) == 0x000000, "Member 'FEmoteEntry::EmoteMotion' has a wrong offset!");

// ScriptStruct Mordhau.HighMidLowSpineSpaceAdditive
// 0x018C (0x018C - 0x0000)
struct FHighMidLowSpineSpaceAdditive final
{
public:
	struct FSpineSpaceAdditive                    High;                                              // 0x0000(0x0084)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpineSpaceAdditive                    Mid;                                               // 0x0084(0x0084)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FSpineSpaceAdditive                    Low;                                               // 0x0108(0x0084)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHighMidLowSpineSpaceAdditive) == 0x000004, "Wrong alignment on FHighMidLowSpineSpaceAdditive");
static_assert(sizeof(FHighMidLowSpineSpaceAdditive) == 0x00018C, "Wrong size on FHighMidLowSpineSpaceAdditive");
static_assert(offsetof(FHighMidLowSpineSpaceAdditive, High) == 0x000000, "Member 'FHighMidLowSpineSpaceAdditive::High' has a wrong offset!");
static_assert(offsetof(FHighMidLowSpineSpaceAdditive, Mid) == 0x000084, "Member 'FHighMidLowSpineSpaceAdditive::Mid' has a wrong offset!");
static_assert(offsetof(FHighMidLowSpineSpaceAdditive, Low) == 0x000108, "Member 'FHighMidLowSpineSpaceAdditive::Low' has a wrong offset!");

// ScriptStruct Mordhau.AnglingSpineSpaceAdditive
// 0x0318 (0x0318 - 0x0000)
struct FAnglingSpineSpaceAdditive final
{
public:
	struct FHighMidLowSpineSpaceAdditive          Right;                                             // 0x0000(0x018C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FHighMidLowSpineSpaceAdditive          Left;                                              // 0x018C(0x018C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnglingSpineSpaceAdditive) == 0x000004, "Wrong alignment on FAnglingSpineSpaceAdditive");
static_assert(sizeof(FAnglingSpineSpaceAdditive) == 0x000318, "Wrong size on FAnglingSpineSpaceAdditive");
static_assert(offsetof(FAnglingSpineSpaceAdditive, Right) == 0x000000, "Member 'FAnglingSpineSpaceAdditive::Right' has a wrong offset!");
static_assert(offsetof(FAnglingSpineSpaceAdditive, Left) == 0x00018C, "Member 'FAnglingSpineSpaceAdditive::Left' has a wrong offset!");

// ScriptStruct Mordhau.VehicleTransitionInfo
// 0x0010 (0x0010 - 0x0000)
struct FVehicleTransitionInfo final
{
public:
	class UAnimSequence*                          Animation;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleTransitionInfo) == 0x000008, "Wrong alignment on FVehicleTransitionInfo");
static_assert(sizeof(FVehicleTransitionInfo) == 0x000010, "Wrong size on FVehicleTransitionInfo");
static_assert(offsetof(FVehicleTransitionInfo, Animation) == 0x000000, "Member 'FVehicleTransitionInfo::Animation' has a wrong offset!");
static_assert(offsetof(FVehicleTransitionInfo, Duration) == 0x000008, "Member 'FVehicleTransitionInfo::Duration' has a wrong offset!");
static_assert(offsetof(FVehicleTransitionInfo, BlendTime) == 0x00000C, "Member 'FVehicleTransitionInfo::BlendTime' has a wrong offset!");

// ScriptStruct Mordhau.WearableCustomization
// 0x0040 (0x0040 - 0x0000)
struct FWearableCustomization final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 Colors;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 Team1Colors;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 Team2Colors;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pattern;                                           // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWearableCustomization) == 0x000008, "Wrong alignment on FWearableCustomization");
static_assert(sizeof(FWearableCustomization) == 0x000040, "Wrong size on FWearableCustomization");
static_assert(offsetof(FWearableCustomization, ID) == 0x000000, "Member 'FWearableCustomization::ID' has a wrong offset!");
static_assert(offsetof(FWearableCustomization, Colors) == 0x000008, "Member 'FWearableCustomization::Colors' has a wrong offset!");
static_assert(offsetof(FWearableCustomization, Team1Colors) == 0x000018, "Member 'FWearableCustomization::Team1Colors' has a wrong offset!");
static_assert(offsetof(FWearableCustomization, Team2Colors) == 0x000028, "Member 'FWearableCustomization::Team2Colors' has a wrong offset!");
static_assert(offsetof(FWearableCustomization, Pattern) == 0x000038, "Member 'FWearableCustomization::Pattern' has a wrong offset!");

// ScriptStruct Mordhau.EquipmentCustomization
// 0x0030 (0x0030 - 0x0000)
struct FEquipmentCustomization final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 Colors;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 Parts;                                             // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pattern;                                           // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Skin;                                              // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEquipmentCustomization) == 0x000008, "Wrong alignment on FEquipmentCustomization");
static_assert(sizeof(FEquipmentCustomization) == 0x000030, "Wrong size on FEquipmentCustomization");
static_assert(offsetof(FEquipmentCustomization, ID) == 0x000000, "Member 'FEquipmentCustomization::ID' has a wrong offset!");
static_assert(offsetof(FEquipmentCustomization, Colors) == 0x000008, "Member 'FEquipmentCustomization::Colors' has a wrong offset!");
static_assert(offsetof(FEquipmentCustomization, Parts) == 0x000018, "Member 'FEquipmentCustomization::Parts' has a wrong offset!");
static_assert(offsetof(FEquipmentCustomization, Pattern) == 0x000028, "Member 'FEquipmentCustomization::Pattern' has a wrong offset!");
static_assert(offsetof(FEquipmentCustomization, Skin) == 0x000029, "Member 'FEquipmentCustomization::Skin' has a wrong offset!");

// ScriptStruct Mordhau.CharacterGearCustomization
// 0x0020 (0x0020 - 0x0000)
struct FCharacterGearCustomization final
{
public:
	TArray<struct FWearableCustomization>         Wearables;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEquipmentCustomization>        Equipment;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterGearCustomization) == 0x000008, "Wrong alignment on FCharacterGearCustomization");
static_assert(sizeof(FCharacterGearCustomization) == 0x000020, "Wrong size on FCharacterGearCustomization");
static_assert(offsetof(FCharacterGearCustomization, Wearables) == 0x000000, "Member 'FCharacterGearCustomization::Wearables' has a wrong offset!");
static_assert(offsetof(FCharacterGearCustomization, Equipment) == 0x000010, "Member 'FCharacterGearCustomization::Equipment' has a wrong offset!");

// ScriptStruct Mordhau.AppearanceCustomization
// 0x0028 (0x0028 - 0x0000)
struct FAppearanceCustomization final
{
public:
	int32                                         Emblem;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 EmblemColors;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         MetalRoughnessScale;                               // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MetalTint;                                         // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Age;                                               // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Voice;                                             // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VoicePitch;                                        // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFemale;                                         // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Fat;                                               // 0x001E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Skinny;                                            // 0x001F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Strong;                                            // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SkinColor;                                         // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Face;                                              // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EyeColor;                                          // 0x0023(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HairColor;                                         // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Hair;                                              // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FacialHair;                                        // 0x0026(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Eyebrows;                                          // 0x0027(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAppearanceCustomization) == 0x000008, "Wrong alignment on FAppearanceCustomization");
static_assert(sizeof(FAppearanceCustomization) == 0x000028, "Wrong size on FAppearanceCustomization");
static_assert(offsetof(FAppearanceCustomization, Emblem) == 0x000000, "Member 'FAppearanceCustomization::Emblem' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, EmblemColors) == 0x000008, "Member 'FAppearanceCustomization::EmblemColors' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, MetalRoughnessScale) == 0x000018, "Member 'FAppearanceCustomization::MetalRoughnessScale' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, MetalTint) == 0x000019, "Member 'FAppearanceCustomization::MetalTint' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, Age) == 0x00001A, "Member 'FAppearanceCustomization::Age' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, Voice) == 0x00001B, "Member 'FAppearanceCustomization::Voice' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, VoicePitch) == 0x00001C, "Member 'FAppearanceCustomization::VoicePitch' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, bIsFemale) == 0x00001D, "Member 'FAppearanceCustomization::bIsFemale' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, Fat) == 0x00001E, "Member 'FAppearanceCustomization::Fat' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, Skinny) == 0x00001F, "Member 'FAppearanceCustomization::Skinny' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, Strong) == 0x000020, "Member 'FAppearanceCustomization::Strong' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, SkinColor) == 0x000021, "Member 'FAppearanceCustomization::SkinColor' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, Face) == 0x000022, "Member 'FAppearanceCustomization::Face' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, EyeColor) == 0x000023, "Member 'FAppearanceCustomization::EyeColor' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, HairColor) == 0x000024, "Member 'FAppearanceCustomization::HairColor' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, Hair) == 0x000025, "Member 'FAppearanceCustomization::Hair' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, FacialHair) == 0x000026, "Member 'FAppearanceCustomization::FacialHair' has a wrong offset!");
static_assert(offsetof(FAppearanceCustomization, Eyebrows) == 0x000027, "Member 'FAppearanceCustomization::Eyebrows' has a wrong offset!");

// ScriptStruct Mordhau.FaceCustomization
// 0x0030 (0x0030 - 0x0000)
struct FFaceCustomization final
{
public:
	TArray<uint16>                                Translate;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                Rotate;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint16>                                Scale;                                             // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFaceCustomization) == 0x000008, "Wrong alignment on FFaceCustomization");
static_assert(sizeof(FFaceCustomization) == 0x000030, "Wrong size on FFaceCustomization");
static_assert(offsetof(FFaceCustomization, Translate) == 0x000000, "Member 'FFaceCustomization::Translate' has a wrong offset!");
static_assert(offsetof(FFaceCustomization, Rotate) == 0x000010, "Member 'FFaceCustomization::Rotate' has a wrong offset!");
static_assert(offsetof(FFaceCustomization, Scale) == 0x000020, "Member 'FFaceCustomization::Scale' has a wrong offset!");

// ScriptStruct Mordhau.CharacterProfile
// 0x00B8 (0x00B8 - 0x0000)
struct FCharacterProfile final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCharacterGearCustomization            GearCustomization;                                 // 0x0018(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAppearanceCustomization               AppearanceCustomization;                           // 0x0038(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFaceCustomization                     FaceCustomization;                                 // 0x0060(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSkillsCustomization                   SkillsCustomization;                               // 0x0090(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Category;                                          // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayFabId;                                         // 0x00A8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterProfile) == 0x000008, "Wrong alignment on FCharacterProfile");
static_assert(sizeof(FCharacterProfile) == 0x0000B8, "Wrong size on FCharacterProfile");
static_assert(offsetof(FCharacterProfile, Name) == 0x000000, "Member 'FCharacterProfile::Name' has a wrong offset!");
static_assert(offsetof(FCharacterProfile, GearCustomization) == 0x000018, "Member 'FCharacterProfile::GearCustomization' has a wrong offset!");
static_assert(offsetof(FCharacterProfile, AppearanceCustomization) == 0x000038, "Member 'FCharacterProfile::AppearanceCustomization' has a wrong offset!");
static_assert(offsetof(FCharacterProfile, FaceCustomization) == 0x000060, "Member 'FCharacterProfile::FaceCustomization' has a wrong offset!");
static_assert(offsetof(FCharacterProfile, SkillsCustomization) == 0x000090, "Member 'FCharacterProfile::SkillsCustomization' has a wrong offset!");
static_assert(offsetof(FCharacterProfile, Category) == 0x000098, "Member 'FCharacterProfile::Category' has a wrong offset!");
static_assert(offsetof(FCharacterProfile, PlayFabId) == 0x0000A8, "Member 'FCharacterProfile::PlayFabId' has a wrong offset!");

// ScriptStruct Mordhau.PlayerProfile
// 0x00C8 (0x00C8 - 0x0000)
struct FPlayerProfile final
{
public:
	int32                                         Rank;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RankDisplayType;                                   // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Banner;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterProfile                      Character;                                         // 0x0010(0x00B8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerProfile) == 0x000008, "Wrong alignment on FPlayerProfile");
static_assert(sizeof(FPlayerProfile) == 0x0000C8, "Wrong size on FPlayerProfile");
static_assert(offsetof(FPlayerProfile, Rank) == 0x000000, "Member 'FPlayerProfile::Rank' has a wrong offset!");
static_assert(offsetof(FPlayerProfile, RankDisplayType) == 0x000004, "Member 'FPlayerProfile::RankDisplayType' has a wrong offset!");
static_assert(offsetof(FPlayerProfile, Banner) == 0x000008, "Member 'FPlayerProfile::Banner' has a wrong offset!");
static_assert(offsetof(FPlayerProfile, Character) == 0x000010, "Member 'FPlayerProfile::Character' has a wrong offset!");

// ScriptStruct Mordhau.RepArraySkillsWithVersion
// 0x0008 (0x0008 - 0x0000)
struct FRepArraySkillsWithVersion final
{
public:
	struct FSkillsCustomization                   Skills;                                            // 0x0000(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Version;                                           // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepArraySkillsWithVersion) == 0x000004, "Wrong alignment on FRepArraySkillsWithVersion");
static_assert(sizeof(FRepArraySkillsWithVersion) == 0x000008, "Wrong size on FRepArraySkillsWithVersion");
static_assert(offsetof(FRepArraySkillsWithVersion, Skills) == 0x000000, "Member 'FRepArraySkillsWithVersion::Skills' has a wrong offset!");
static_assert(offsetof(FRepArraySkillsWithVersion, Version) == 0x000004, "Member 'FRepArraySkillsWithVersion::Version' has a wrong offset!");

// ScriptStruct Mordhau.RepArrayAppearanceWithVersion
// 0x0030 (0x0030 - 0x0000)
struct FRepArrayAppearanceWithVersion final
{
public:
	struct FAppearanceCustomization               Appearance;                                        // 0x0000(0x0028)(NativeAccessSpecifierPublic)
	uint8                                         Version;                                           // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepArrayAppearanceWithVersion) == 0x000008, "Wrong alignment on FRepArrayAppearanceWithVersion");
static_assert(sizeof(FRepArrayAppearanceWithVersion) == 0x000030, "Wrong size on FRepArrayAppearanceWithVersion");
static_assert(offsetof(FRepArrayAppearanceWithVersion, Appearance) == 0x000000, "Member 'FRepArrayAppearanceWithVersion::Appearance' has a wrong offset!");
static_assert(offsetof(FRepArrayAppearanceWithVersion, Version) == 0x000028, "Member 'FRepArrayAppearanceWithVersion::Version' has a wrong offset!");

// ScriptStruct Mordhau.PatternInfo
// 0x0010 (0x0010 - 0x0000)
struct FPatternInfo final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasColor1;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasColor2;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasColor3;                                        // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPatternInfo) == 0x000008, "Wrong alignment on FPatternInfo");
static_assert(sizeof(FPatternInfo) == 0x000010, "Wrong size on FPatternInfo");
static_assert(offsetof(FPatternInfo, Texture) == 0x000000, "Member 'FPatternInfo::Texture' has a wrong offset!");
static_assert(offsetof(FPatternInfo, bHasColor1) == 0x000008, "Member 'FPatternInfo::bHasColor1' has a wrong offset!");
static_assert(offsetof(FPatternInfo, bHasColor2) == 0x000009, "Member 'FPatternInfo::bHasColor2' has a wrong offset!");
static_assert(offsetof(FPatternInfo, bHasColor3) == 0x00000A, "Member 'FPatternInfo::bHasColor3' has a wrong offset!");

// ScriptStruct Mordhau.RepArrayByteWithVersion
// 0x0018 (0x0018 - 0x0000)
struct FRepArrayByteWithVersion final
{
public:
	TArray<uint8>                                 Array;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Version;                                           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepArrayByteWithVersion) == 0x000008, "Wrong alignment on FRepArrayByteWithVersion");
static_assert(sizeof(FRepArrayByteWithVersion) == 0x000018, "Wrong size on FRepArrayByteWithVersion");
static_assert(offsetof(FRepArrayByteWithVersion, Array) == 0x000000, "Member 'FRepArrayByteWithVersion::Array' has a wrong offset!");
static_assert(offsetof(FRepArrayByteWithVersion, Version) == 0x000010, "Member 'FRepArrayByteWithVersion::Version' has a wrong offset!");

// ScriptStruct Mordhau.RepFaceArrayShortWithVersion
// 0x0018 (0x0018 - 0x0000)
struct FRepFaceArrayShortWithVersion final
{
public:
	TArray<uint16>                                Array;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Version;                                           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepFaceArrayShortWithVersion) == 0x000008, "Wrong alignment on FRepFaceArrayShortWithVersion");
static_assert(sizeof(FRepFaceArrayShortWithVersion) == 0x000018, "Wrong size on FRepFaceArrayShortWithVersion");
static_assert(offsetof(FRepFaceArrayShortWithVersion, Array) == 0x000000, "Member 'FRepFaceArrayShortWithVersion::Array' has a wrong offset!");
static_assert(offsetof(FRepFaceArrayShortWithVersion, Version) == 0x000010, "Member 'FRepFaceArrayShortWithVersion::Version' has a wrong offset!");

// ScriptStruct Mordhau.EquipmentPartEntry
// 0x0028 (0x0028 - 0x0000)
struct FEquipmentPartEntry final
{
public:
	class FText                                   PartName;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UMordhauEquipmentPart>> Parts;                                             // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipmentPartEntry) == 0x000008, "Wrong alignment on FEquipmentPartEntry");
static_assert(sizeof(FEquipmentPartEntry) == 0x000028, "Wrong size on FEquipmentPartEntry");
static_assert(offsetof(FEquipmentPartEntry, PartName) == 0x000000, "Member 'FEquipmentPartEntry::PartName' has a wrong offset!");
static_assert(offsetof(FEquipmentPartEntry, Parts) == 0x000018, "Member 'FEquipmentPartEntry::Parts' has a wrong offset!");

// ScriptStruct Mordhau.EquipmentSkinEntry
// 0x0058 (0x0058 - 0x0000)
struct FEquipmentSkinEntry final
{
public:
	class FText                                   SkinName;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             SkinIcon;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEquipmentPartEntry>            PartTypes;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ColorTables;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPatternInfo>                   Patterns;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          ShadowPhAt;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipmentSkinEntry) == 0x000008, "Wrong alignment on FEquipmentSkinEntry");
static_assert(sizeof(FEquipmentSkinEntry) == 0x000058, "Wrong size on FEquipmentSkinEntry");
static_assert(offsetof(FEquipmentSkinEntry, SkinName) == 0x000000, "Member 'FEquipmentSkinEntry::SkinName' has a wrong offset!");
static_assert(offsetof(FEquipmentSkinEntry, SkinIcon) == 0x000018, "Member 'FEquipmentSkinEntry::SkinIcon' has a wrong offset!");
static_assert(offsetof(FEquipmentSkinEntry, PartTypes) == 0x000020, "Member 'FEquipmentSkinEntry::PartTypes' has a wrong offset!");
static_assert(offsetof(FEquipmentSkinEntry, ColorTables) == 0x000030, "Member 'FEquipmentSkinEntry::ColorTables' has a wrong offset!");
static_assert(offsetof(FEquipmentSkinEntry, Patterns) == 0x000040, "Member 'FEquipmentSkinEntry::Patterns' has a wrong offset!");
static_assert(offsetof(FEquipmentSkinEntry, ShadowPhAt) == 0x000050, "Member 'FEquipmentSkinEntry::ShadowPhAt' has a wrong offset!");

// ScriptStruct Mordhau.EquipmentHolsterInfo
// 0x0060 (0x0060 - 0x0000)
struct FEquipmentHolsterInfo final
{
public:
	class FName                                   HolsterSocket;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenIn1P;                                       // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           DrawAnimation;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DrawAnimation1P;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AltModeDrawAnimation1P;                            // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0030(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipmentHolsterInfo) == 0x000010, "Wrong alignment on FEquipmentHolsterInfo");
static_assert(sizeof(FEquipmentHolsterInfo) == 0x000060, "Wrong size on FEquipmentHolsterInfo");
static_assert(offsetof(FEquipmentHolsterInfo, HolsterSocket) == 0x000000, "Member 'FEquipmentHolsterInfo::HolsterSocket' has a wrong offset!");
static_assert(offsetof(FEquipmentHolsterInfo, bHidden) == 0x000008, "Member 'FEquipmentHolsterInfo::bHidden' has a wrong offset!");
static_assert(offsetof(FEquipmentHolsterInfo, bHiddenIn1P) == 0x000009, "Member 'FEquipmentHolsterInfo::bHiddenIn1P' has a wrong offset!");
static_assert(offsetof(FEquipmentHolsterInfo, DrawAnimation) == 0x000010, "Member 'FEquipmentHolsterInfo::DrawAnimation' has a wrong offset!");
static_assert(offsetof(FEquipmentHolsterInfo, DrawAnimation1P) == 0x000018, "Member 'FEquipmentHolsterInfo::DrawAnimation1P' has a wrong offset!");
static_assert(offsetof(FEquipmentHolsterInfo, AltModeDrawAnimation1P) == 0x000020, "Member 'FEquipmentHolsterInfo::AltModeDrawAnimation1P' has a wrong offset!");
static_assert(offsetof(FEquipmentHolsterInfo, Offset) == 0x000030, "Member 'FEquipmentHolsterInfo::Offset' has a wrong offset!");

// ScriptStruct Mordhau.MatchmakingTicket
// 0x0020 (0x0020 - 0x0000)
struct FMatchmakingTicket final
{
public:
	class FString                                 QueueName;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TicketId;                                          // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchmakingTicket) == 0x000008, "Wrong alignment on FMatchmakingTicket");
static_assert(sizeof(FMatchmakingTicket) == 0x000020, "Wrong size on FMatchmakingTicket");
static_assert(offsetof(FMatchmakingTicket, QueueName) == 0x000000, "Member 'FMatchmakingTicket::QueueName' has a wrong offset!");
static_assert(offsetof(FMatchmakingTicket, TicketId) == 0x000010, "Member 'FMatchmakingTicket::TicketId' has a wrong offset!");

// ScriptStruct Mordhau.RichPresence
// 0x0028 (0x0028 - 0x0000)
struct FRichPresence final
{
public:
	ERichPresenceStatus                           Status;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameMode;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRichPresence) == 0x000008, "Wrong alignment on FRichPresence");
static_assert(sizeof(FRichPresence) == 0x000028, "Wrong size on FRichPresence");
static_assert(offsetof(FRichPresence, Status) == 0x000000, "Member 'FRichPresence::Status' has a wrong offset!");
static_assert(offsetof(FRichPresence, GameMode) == 0x000008, "Member 'FRichPresence::GameMode' has a wrong offset!");
static_assert(offsetof(FRichPresence, MapName) == 0x000018, "Member 'FRichPresence::MapName' has a wrong offset!");

// ScriptStruct Mordhau.UserReportEntry
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FUserReportEntry final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUserReportEntry) == 0x000008, "Wrong alignment on FUserReportEntry");
static_assert(sizeof(FUserReportEntry) == 0x000070, "Wrong size on FUserReportEntry");

// ScriptStruct Mordhau.LoginErrorMessage
// 0x0048 (0x0048 - 0x0000)
struct FLoginErrorMessage final
{
public:
	class FText                                   Default;                                           // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Playstation;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Xbox;                                              // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoginErrorMessage) == 0x000008, "Wrong alignment on FLoginErrorMessage");
static_assert(sizeof(FLoginErrorMessage) == 0x000048, "Wrong size on FLoginErrorMessage");
static_assert(offsetof(FLoginErrorMessage, Default) == 0x000000, "Member 'FLoginErrorMessage::Default' has a wrong offset!");
static_assert(offsetof(FLoginErrorMessage, Playstation) == 0x000018, "Member 'FLoginErrorMessage::Playstation' has a wrong offset!");
static_assert(offsetof(FLoginErrorMessage, Xbox) == 0x000030, "Member 'FLoginErrorMessage::Xbox' has a wrong offset!");

// ScriptStruct Mordhau.PlayerMessageStruct
// 0x0028 (0x0028 - 0x0000)
struct FPlayerMessageStruct final
{
public:
	class FString                                 MessageBody;                                       // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MessagePrefix;                                     // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerTeam;                                        // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerMessageStruct) == 0x000008, "Wrong alignment on FPlayerMessageStruct");
static_assert(sizeof(FPlayerMessageStruct) == 0x000028, "Wrong size on FPlayerMessageStruct");
static_assert(offsetof(FPlayerMessageStruct, MessageBody) == 0x000000, "Member 'FPlayerMessageStruct::MessageBody' has a wrong offset!");
static_assert(offsetof(FPlayerMessageStruct, MessagePrefix) == 0x000010, "Member 'FPlayerMessageStruct::MessagePrefix' has a wrong offset!");
static_assert(offsetof(FPlayerMessageStruct, PlayerTeam) == 0x000020, "Member 'FPlayerMessageStruct::PlayerTeam' has a wrong offset!");

// ScriptStruct Mordhau.PlayerChatMessagesContainer
// 0x0018 (0x0018 - 0x0000)
struct FPlayerChatMessagesContainer final
{
public:
	TArray<struct FPlayerMessageStruct>           Messages;                                          // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerChatMessagesContainer) == 0x000008, "Wrong alignment on FPlayerChatMessagesContainer");
static_assert(sizeof(FPlayerChatMessagesContainer) == 0x000018, "Wrong size on FPlayerChatMessagesContainer");
static_assert(offsetof(FPlayerChatMessagesContainer, Messages) == 0x000000, "Member 'FPlayerChatMessagesContainer::Messages' has a wrong offset!");

// ScriptStruct Mordhau.ChatCommandStruct
// 0x0020 (0x0020 - 0x0000)
struct FChatCommandStruct final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Type;                                              // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresAdmin;                                    // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBroadcastCommand;                                 // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChatCommandStruct) == 0x000008, "Wrong alignment on FChatCommandStruct");
static_assert(sizeof(FChatCommandStruct) == 0x000020, "Wrong size on FChatCommandStruct");
static_assert(offsetof(FChatCommandStruct, Name) == 0x000000, "Member 'FChatCommandStruct::Name' has a wrong offset!");
static_assert(offsetof(FChatCommandStruct, Type) == 0x000010, "Member 'FChatCommandStruct::Type' has a wrong offset!");
static_assert(offsetof(FChatCommandStruct, bRequiresAdmin) == 0x000018, "Member 'FChatCommandStruct::bRequiresAdmin' has a wrong offset!");
static_assert(offsetof(FChatCommandStruct, bBroadcastCommand) == 0x000019, "Member 'FChatCommandStruct::bBroadcastCommand' has a wrong offset!");

// ScriptStruct Mordhau.RconEventStruct
// 0x0020 (0x0020 - 0x0000)
struct FRconEventStruct final
{
public:
	class FString                                 EventName;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRconEventStruct) == 0x000008, "Wrong alignment on FRconEventStruct");
static_assert(sizeof(FRconEventStruct) == 0x000020, "Wrong size on FRconEventStruct");
static_assert(offsetof(FRconEventStruct, EventName) == 0x000000, "Member 'FRconEventStruct::EventName' has a wrong offset!");

// ScriptStruct Mordhau.GameStatePostPhysicsTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FGameStatePostPhysicsTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameStatePostPhysicsTickFunction) == 0x000008, "Wrong alignment on FGameStatePostPhysicsTickFunction");
static_assert(sizeof(FGameStatePostPhysicsTickFunction) == 0x000030, "Wrong size on FGameStatePostPhysicsTickFunction");

// ScriptStruct Mordhau.GameStateLastDemotableTickFunction
// 0x0008 (0x0030 - 0x0028)
struct FGameStateLastDemotableTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameStateLastDemotableTickFunction) == 0x000008, "Wrong alignment on FGameStateLastDemotableTickFunction");
static_assert(sizeof(FGameStateLastDemotableTickFunction) == 0x000030, "Wrong size on FGameStateLastDemotableTickFunction");

// ScriptStruct Mordhau.GroupSoundPlayer
// 0x0018 (0x0018 - 0x0000)
struct FGroupSoundPlayer final
{
public:
	TWeakObjectPtr<class UAudioComponent>         CurrentlyPlayingSound;                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Entries;                                           // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroupSoundPlayer) == 0x000004, "Wrong alignment on FGroupSoundPlayer");
static_assert(sizeof(FGroupSoundPlayer) == 0x000018, "Wrong size on FGroupSoundPlayer");
static_assert(offsetof(FGroupSoundPlayer, CurrentlyPlayingSound) == 0x000000, "Member 'FGroupSoundPlayer::CurrentlyPlayingSound' has a wrong offset!");
static_assert(offsetof(FGroupSoundPlayer, Location) == 0x000008, "Member 'FGroupSoundPlayer::Location' has a wrong offset!");
static_assert(offsetof(FGroupSoundPlayer, Entries) == 0x000014, "Member 'FGroupSoundPlayer::Entries' has a wrong offset!");

// ScriptStruct Mordhau.GroupSoundEntry
// 0x0010 (0x0010 - 0x0000)
struct FGroupSoundEntry final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroupSoundEntry) == 0x000004, "Wrong alignment on FGroupSoundEntry");
static_assert(sizeof(FGroupSoundEntry) == 0x000010, "Wrong size on FGroupSoundEntry");
static_assert(offsetof(FGroupSoundEntry, Location) == 0x000000, "Member 'FGroupSoundEntry::Location' has a wrong offset!");
static_assert(offsetof(FGroupSoundEntry, Time) == 0x00000C, "Member 'FGroupSoundEntry::Time' has a wrong offset!");

// ScriptStruct Mordhau.GroupSoundGroup
// 0x0080 (0x0080 - 0x0000)
struct FGroupSoundGroup final
{
public:
	TArray<struct FGroupSoundPlayer>              GroupSoundPlayers;                                 // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class AActor*, struct FGroupSoundEntry>  SoundEntries;                                      // 0x0010(0x0050)(NativeAccessSpecifierPublic)
	int32                                         SoundGroupsNum;                                    // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EntryMaxAge;                                       // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinEntriesToPlaySound;                             // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              SoundCue;                                          // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundGroupMergeDistance;                           // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroupSoundGroup) == 0x000008, "Wrong alignment on FGroupSoundGroup");
static_assert(sizeof(FGroupSoundGroup) == 0x000080, "Wrong size on FGroupSoundGroup");
static_assert(offsetof(FGroupSoundGroup, GroupSoundPlayers) == 0x000000, "Member 'FGroupSoundGroup::GroupSoundPlayers' has a wrong offset!");
static_assert(offsetof(FGroupSoundGroup, SoundEntries) == 0x000010, "Member 'FGroupSoundGroup::SoundEntries' has a wrong offset!");
static_assert(offsetof(FGroupSoundGroup, SoundGroupsNum) == 0x000060, "Member 'FGroupSoundGroup::SoundGroupsNum' has a wrong offset!");
static_assert(offsetof(FGroupSoundGroup, EntryMaxAge) == 0x000064, "Member 'FGroupSoundGroup::EntryMaxAge' has a wrong offset!");
static_assert(offsetof(FGroupSoundGroup, MinEntriesToPlaySound) == 0x000068, "Member 'FGroupSoundGroup::MinEntriesToPlaySound' has a wrong offset!");
static_assert(offsetof(FGroupSoundGroup, SoundCue) == 0x000070, "Member 'FGroupSoundGroup::SoundCue' has a wrong offset!");
static_assert(offsetof(FGroupSoundGroup, FadeOutDuration) == 0x000078, "Member 'FGroupSoundGroup::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(FGroupSoundGroup, SoundGroupMergeDistance) == 0x00007C, "Member 'FGroupSoundGroup::SoundGroupMergeDistance' has a wrong offset!");

// ScriptStruct Mordhau.LineTraceMemoryEntry
// 0x0024 (0x0024 - 0x0000)
struct FLineTraceMemoryEntry final
{
public:
	struct FVector                                TraceStart;                                        // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEnd;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyTime;                                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Owner;                                             // 0x001C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLineTraceMemoryEntry) == 0x000004, "Wrong alignment on FLineTraceMemoryEntry");
static_assert(sizeof(FLineTraceMemoryEntry) == 0x000024, "Wrong size on FLineTraceMemoryEntry");
static_assert(offsetof(FLineTraceMemoryEntry, TraceStart) == 0x000000, "Member 'FLineTraceMemoryEntry::TraceStart' has a wrong offset!");
static_assert(offsetof(FLineTraceMemoryEntry, TraceEnd) == 0x00000C, "Member 'FLineTraceMemoryEntry::TraceEnd' has a wrong offset!");
static_assert(offsetof(FLineTraceMemoryEntry, DestroyTime) == 0x000018, "Member 'FLineTraceMemoryEntry::DestroyTime' has a wrong offset!");
static_assert(offsetof(FLineTraceMemoryEntry, Owner) == 0x00001C, "Member 'FLineTraceMemoryEntry::Owner' has a wrong offset!");

// ScriptStruct Mordhau.CapturePointGroup
// 0x0010 (0x0010 - 0x0000)
struct FCapturePointGroup final
{
public:
	TArray<class AControlPoint*>                  CapturePoints;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCapturePointGroup) == 0x000008, "Wrong alignment on FCapturePointGroup");
static_assert(sizeof(FCapturePointGroup) == 0x000010, "Wrong size on FCapturePointGroup");
static_assert(offsetof(FCapturePointGroup, CapturePoints) == 0x000000, "Member 'FCapturePointGroup::CapturePoints' has a wrong offset!");

// ScriptStruct Mordhau.MatchRewards
// 0x0068 (0x0068 - 0x0000)
struct FMatchRewards final
{
public:
	struct FPlayFabMatch                          Match;                                             // 0x0000(0x0060)(NativeAccessSpecifierPublic)
	int32                                         Gold;                                              // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP;                                                // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchRewards) == 0x000008, "Wrong alignment on FMatchRewards");
static_assert(sizeof(FMatchRewards) == 0x000068, "Wrong size on FMatchRewards");
static_assert(offsetof(FMatchRewards, Match) == 0x000000, "Member 'FMatchRewards::Match' has a wrong offset!");
static_assert(offsetof(FMatchRewards, Gold) == 0x000060, "Member 'FMatchRewards::Gold' has a wrong offset!");
static_assert(offsetof(FMatchRewards, XP) == 0x000064, "Member 'FMatchRewards::XP' has a wrong offset!");

// ScriptStruct Mordhau.UnlockRecipe
// 0x0078 (0x0078 - 0x0000)
struct FUnlockRecipe final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredGold;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredXP;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         RequiredItems;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 RequiredDLC;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         UnlockedItems;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Platform;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemClass;                                         // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Tags;                                              // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnlockRecipe) == 0x000008, "Wrong alignment on FUnlockRecipe");
static_assert(sizeof(FUnlockRecipe) == 0x000078, "Wrong size on FUnlockRecipe");
static_assert(offsetof(FUnlockRecipe, ItemId) == 0x000000, "Member 'FUnlockRecipe::ItemId' has a wrong offset!");
static_assert(offsetof(FUnlockRecipe, RequiredGold) == 0x000010, "Member 'FUnlockRecipe::RequiredGold' has a wrong offset!");
static_assert(offsetof(FUnlockRecipe, RequiredXP) == 0x000014, "Member 'FUnlockRecipe::RequiredXP' has a wrong offset!");
static_assert(offsetof(FUnlockRecipe, RequiredItems) == 0x000018, "Member 'FUnlockRecipe::RequiredItems' has a wrong offset!");
static_assert(offsetof(FUnlockRecipe, RequiredDLC) == 0x000028, "Member 'FUnlockRecipe::RequiredDLC' has a wrong offset!");
static_assert(offsetof(FUnlockRecipe, UnlockedItems) == 0x000038, "Member 'FUnlockRecipe::UnlockedItems' has a wrong offset!");
static_assert(offsetof(FUnlockRecipe, Platform) == 0x000048, "Member 'FUnlockRecipe::Platform' has a wrong offset!");
static_assert(offsetof(FUnlockRecipe, ItemClass) == 0x000058, "Member 'FUnlockRecipe::ItemClass' has a wrong offset!");
static_assert(offsetof(FUnlockRecipe, Tags) == 0x000068, "Member 'FUnlockRecipe::Tags' has a wrong offset!");

// ScriptStruct Mordhau.BlockResult
// 0x0009 (0x0009 - 0x0000)
struct FBlockResult final
{
public:
	EBlockedReason                                Reason;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStun;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisarm;                                         // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRanged;                                         // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCancel;                                         // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPartyFlag;                                        // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresSelfBlockEvent;                           // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClashOnParry;                                     // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Surface;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockResult) == 0x000001, "Wrong alignment on FBlockResult");
static_assert(sizeof(FBlockResult) == 0x000009, "Wrong size on FBlockResult");
static_assert(offsetof(FBlockResult, Reason) == 0x000000, "Member 'FBlockResult::Reason' has a wrong offset!");
static_assert(offsetof(FBlockResult, bIsStun) == 0x000001, "Member 'FBlockResult::bIsStun' has a wrong offset!");
static_assert(offsetof(FBlockResult, bIsDisarm) == 0x000002, "Member 'FBlockResult::bIsDisarm' has a wrong offset!");
static_assert(offsetof(FBlockResult, bIsRanged) == 0x000003, "Member 'FBlockResult::bIsRanged' has a wrong offset!");
static_assert(offsetof(FBlockResult, bIsCancel) == 0x000004, "Member 'FBlockResult::bIsCancel' has a wrong offset!");
static_assert(offsetof(FBlockResult, bPartyFlag) == 0x000005, "Member 'FBlockResult::bPartyFlag' has a wrong offset!");
static_assert(offsetof(FBlockResult, bRequiresSelfBlockEvent) == 0x000006, "Member 'FBlockResult::bRequiresSelfBlockEvent' has a wrong offset!");
static_assert(offsetof(FBlockResult, bClashOnParry) == 0x000007, "Member 'FBlockResult::bClashOnParry' has a wrong offset!");
static_assert(offsetof(FBlockResult, Surface) == 0x000008, "Member 'FBlockResult::Surface' has a wrong offset!");

// ScriptStruct Mordhau.CondensedUserLagReport
// 0x0028 (0x0028 - 0x0000)
struct FCondensedUserLagReport final
{
public:
	int32                                         GroupCount;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         GroupTimestamp;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        CombinedInBytesPerSec;                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        CombinedOutBytesPerSec;                            // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        CombinedTickRate;                                  // 0x0020(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        CombinedPlayerCount;                               // 0x0022(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTimeDifference;                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCondensedUserLagReport) == 0x000008, "Wrong alignment on FCondensedUserLagReport");
static_assert(sizeof(FCondensedUserLagReport) == 0x000028, "Wrong size on FCondensedUserLagReport");
static_assert(offsetof(FCondensedUserLagReport, GroupCount) == 0x000000, "Member 'FCondensedUserLagReport::GroupCount' has a wrong offset!");
static_assert(offsetof(FCondensedUserLagReport, GroupTimestamp) == 0x000008, "Member 'FCondensedUserLagReport::GroupTimestamp' has a wrong offset!");
static_assert(offsetof(FCondensedUserLagReport, CombinedInBytesPerSec) == 0x000010, "Member 'FCondensedUserLagReport::CombinedInBytesPerSec' has a wrong offset!");
static_assert(offsetof(FCondensedUserLagReport, CombinedOutBytesPerSec) == 0x000018, "Member 'FCondensedUserLagReport::CombinedOutBytesPerSec' has a wrong offset!");
static_assert(offsetof(FCondensedUserLagReport, CombinedTickRate) == 0x000020, "Member 'FCondensedUserLagReport::CombinedTickRate' has a wrong offset!");
static_assert(offsetof(FCondensedUserLagReport, CombinedPlayerCount) == 0x000022, "Member 'FCondensedUserLagReport::CombinedPlayerCount' has a wrong offset!");
static_assert(offsetof(FCondensedUserLagReport, MaxTimeDifference) == 0x000024, "Member 'FCondensedUserLagReport::MaxTimeDifference' has a wrong offset!");

// ScriptStruct Mordhau.UserLagReport
// 0x0018 (0x0018 - 0x0000)
struct FUserLagReport final
{
public:
	int64                                         Timestamp;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        InBytesPerSecond;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        OutBytesPerSecond;                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AvgTickRate;                                       // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PlayerCount;                                       // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUserLagReport) == 0x000008, "Wrong alignment on FUserLagReport");
static_assert(sizeof(FUserLagReport) == 0x000018, "Wrong size on FUserLagReport");
static_assert(offsetof(FUserLagReport, Timestamp) == 0x000000, "Member 'FUserLagReport::Timestamp' has a wrong offset!");
static_assert(offsetof(FUserLagReport, InBytesPerSecond) == 0x000008, "Member 'FUserLagReport::InBytesPerSecond' has a wrong offset!");
static_assert(offsetof(FUserLagReport, OutBytesPerSecond) == 0x00000C, "Member 'FUserLagReport::OutBytesPerSecond' has a wrong offset!");
static_assert(offsetof(FUserLagReport, AvgTickRate) == 0x000010, "Member 'FUserLagReport::AvgTickRate' has a wrong offset!");
static_assert(offsetof(FUserLagReport, PlayerCount) == 0x000011, "Member 'FUserLagReport::PlayerCount' has a wrong offset!");

// ScriptStruct Mordhau.AdminFlag
// 0x0040 (0x0040 - 0x0000)
struct FAdminFlag final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Flag;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Commands;                                          // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAdminFlag) == 0x000008, "Wrong alignment on FAdminFlag");
static_assert(sizeof(FAdminFlag) == 0x000040, "Wrong size on FAdminFlag");
static_assert(offsetof(FAdminFlag, Name) == 0x000000, "Member 'FAdminFlag::Name' has a wrong offset!");
static_assert(offsetof(FAdminFlag, Flag) == 0x000010, "Member 'FAdminFlag::Flag' has a wrong offset!");
static_assert(offsetof(FAdminFlag, Description) == 0x000020, "Member 'FAdminFlag::Description' has a wrong offset!");
static_assert(offsetof(FAdminFlag, Commands) == 0x000030, "Member 'FAdminFlag::Commands' has a wrong offset!");

// ScriptStruct Mordhau.ServerInfo
// 0x0050 (0x0078 - 0x0028)
struct FServerInfo final : public FBasicServerInfo
{
public:
	class FString                                 HostName;                                          // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HostId;                                            // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InstanceId;                                        // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FServerInfo) == 0x000008, "Wrong alignment on FServerInfo");
static_assert(sizeof(FServerInfo) == 0x000078, "Wrong size on FServerInfo");
static_assert(offsetof(FServerInfo, HostName) == 0x000028, "Member 'FServerInfo::HostName' has a wrong offset!");
static_assert(offsetof(FServerInfo, GameMode) == 0x000038, "Member 'FServerInfo::GameMode' has a wrong offset!");
static_assert(offsetof(FServerInfo, MapName) == 0x000048, "Member 'FServerInfo::MapName' has a wrong offset!");
static_assert(offsetof(FServerInfo, HostId) == 0x000058, "Member 'FServerInfo::HostId' has a wrong offset!");
static_assert(offsetof(FServerInfo, InstanceId) == 0x000068, "Member 'FServerInfo::InstanceId' has a wrong offset!");

// ScriptStruct Mordhau.PlayerCountArray
// 0x0010 (0x0010 - 0x0000)
struct FPlayerCountArray final
{
public:
	TArray<int32>                                 Values;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCountArray) == 0x000008, "Wrong alignment on FPlayerCountArray");
static_assert(sizeof(FPlayerCountArray) == 0x000010, "Wrong size on FPlayerCountArray");
static_assert(offsetof(FPlayerCountArray, Values) == 0x000000, "Member 'FPlayerCountArray::Values' has a wrong offset!");

// ScriptStruct Mordhau.ServerStats
// 0x0018 (0x0018 - 0x0000)
struct FServerStats final
{
public:
	uint8                                         TargetTickRate;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MinTickRate;                                       // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxTickRate;                                       // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AvgTickRate;                                       // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        InBytesPerSecond;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        OutBytesPerSecond;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ConfiguredInternetSpeed;                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        NumPlayers;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxPlayers;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FServerStats) == 0x000004, "Wrong alignment on FServerStats");
static_assert(sizeof(FServerStats) == 0x000018, "Wrong size on FServerStats");
static_assert(offsetof(FServerStats, TargetTickRate) == 0x000000, "Member 'FServerStats::TargetTickRate' has a wrong offset!");
static_assert(offsetof(FServerStats, MinTickRate) == 0x000001, "Member 'FServerStats::MinTickRate' has a wrong offset!");
static_assert(offsetof(FServerStats, MaxTickRate) == 0x000002, "Member 'FServerStats::MaxTickRate' has a wrong offset!");
static_assert(offsetof(FServerStats, AvgTickRate) == 0x000003, "Member 'FServerStats::AvgTickRate' has a wrong offset!");
static_assert(offsetof(FServerStats, InBytesPerSecond) == 0x000004, "Member 'FServerStats::InBytesPerSecond' has a wrong offset!");
static_assert(offsetof(FServerStats, OutBytesPerSecond) == 0x000008, "Member 'FServerStats::OutBytesPerSecond' has a wrong offset!");
static_assert(offsetof(FServerStats, ConfiguredInternetSpeed) == 0x00000C, "Member 'FServerStats::ConfiguredInternetSpeed' has a wrong offset!");
static_assert(offsetof(FServerStats, NumPlayers) == 0x000010, "Member 'FServerStats::NumPlayers' has a wrong offset!");
static_assert(offsetof(FServerStats, MaxPlayers) == 0x000014, "Member 'FServerStats::MaxPlayers' has a wrong offset!");

// ScriptStruct Mordhau.NetDamage
// 0x0024 (0x0024 - 0x0000)
struct FNetDamage final
{
public:
	uint8                                         PackedType;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bone;                                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PackedFlags;                                       // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    Point;                                             // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  DamageSource;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  DamageAgent;                                       // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Version;                                           // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetDamage) == 0x000004, "Wrong alignment on FNetDamage");
static_assert(sizeof(FNetDamage) == 0x000024, "Wrong size on FNetDamage");
static_assert(offsetof(FNetDamage, PackedType) == 0x000000, "Member 'FNetDamage::PackedType' has a wrong offset!");
static_assert(offsetof(FNetDamage, bone) == 0x000001, "Member 'FNetDamage::bone' has a wrong offset!");
static_assert(offsetof(FNetDamage, PackedFlags) == 0x000002, "Member 'FNetDamage::PackedFlags' has a wrong offset!");
static_assert(offsetof(FNetDamage, Point) == 0x000004, "Member 'FNetDamage::Point' has a wrong offset!");
static_assert(offsetof(FNetDamage, DamageSource) == 0x000010, "Member 'FNetDamage::DamageSource' has a wrong offset!");
static_assert(offsetof(FNetDamage, DamageAgent) == 0x000018, "Member 'FNetDamage::DamageAgent' has a wrong offset!");
static_assert(offsetof(FNetDamage, Version) == 0x000020, "Member 'FNetDamage::Version' has a wrong offset!");

// ScriptStruct Mordhau.ObjectiveArray
// 0x0010 (0x0010 - 0x0000)
struct FObjectiveArray final
{
public:
	TArray<class AActor*>                         Objective;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveArray) == 0x000008, "Wrong alignment on FObjectiveArray");
static_assert(sizeof(FObjectiveArray) == 0x000010, "Wrong size on FObjectiveArray");
static_assert(offsetof(FObjectiveArray, Objective) == 0x000000, "Member 'FObjectiveArray::Objective' has a wrong offset!");

// ScriptStruct Mordhau.Objective
// 0x0030 (0x0030 - 0x0000)
struct FObjective final
{
public:
	TArray<struct FObjectiveArray>                Objectives;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	TArray<class FText>                           ObjectiveText;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	TArray<bool>                                  Reverse;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjective) == 0x000008, "Wrong alignment on FObjective");
static_assert(sizeof(FObjective) == 0x000030, "Wrong size on FObjective");
static_assert(offsetof(FObjective, Objectives) == 0x000000, "Member 'FObjective::Objectives' has a wrong offset!");
static_assert(offsetof(FObjective, ObjectiveText) == 0x000010, "Member 'FObjective::ObjectiveText' has a wrong offset!");
static_assert(offsetof(FObjective, Reverse) == 0x000020, "Member 'FObjective::Reverse' has a wrong offset!");

// ScriptStruct Mordhau.MordhauConsoleCommand
// 0x0030 (0x0030 - 0x0000)
struct FMordhauConsoleCommand final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HelpText;                                          // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(TArray<class FString>& Params)> Callback;                                          // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMordhauConsoleCommand) == 0x000008, "Wrong alignment on FMordhauConsoleCommand");
static_assert(sizeof(FMordhauConsoleCommand) == 0x000030, "Wrong size on FMordhauConsoleCommand");
static_assert(offsetof(FMordhauConsoleCommand, Name) == 0x000000, "Member 'FMordhauConsoleCommand::Name' has a wrong offset!");
static_assert(offsetof(FMordhauConsoleCommand, HelpText) == 0x000010, "Member 'FMordhauConsoleCommand::HelpText' has a wrong offset!");
static_assert(offsetof(FMordhauConsoleCommand, Callback) == 0x000020, "Member 'FMordhauConsoleCommand::Callback' has a wrong offset!");

// ScriptStruct Mordhau.PlayerCommand
// 0x0030 (0x0030 - 0x0000)
struct FPlayerCommand final
{
public:
	ECommandType                                  Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UniquePlayerID;                                    // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntParam;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringParam;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCommand) == 0x000008, "Wrong alignment on FPlayerCommand");
static_assert(sizeof(FPlayerCommand) == 0x000030, "Wrong size on FPlayerCommand");
static_assert(offsetof(FPlayerCommand, Type) == 0x000000, "Member 'FPlayerCommand::Type' has a wrong offset!");
static_assert(offsetof(FPlayerCommand, UniquePlayerID) == 0x000008, "Member 'FPlayerCommand::UniquePlayerID' has a wrong offset!");
static_assert(offsetof(FPlayerCommand, IntParam) == 0x000018, "Member 'FPlayerCommand::IntParam' has a wrong offset!");
static_assert(offsetof(FPlayerCommand, StringParam) == 0x000020, "Member 'FPlayerCommand::StringParam' has a wrong offset!");

// ScriptStruct Mordhau.ReplicatedProjectileInfo
// 0x0034 (0x0034 - 0x0000)
struct FReplicatedProjectileInfo final
{
public:
	struct FVector_NetQuantize100                 Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 Orientation;                                       // 0x000C(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              HitNormal;                                         // 0x0018(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceForce;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Creator;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HitSurface;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasStopped;                                       // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasHitWorld;                                      // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         HitCounter;                                        // 0x0033(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedProjectileInfo) == 0x000004, "Wrong alignment on FReplicatedProjectileInfo");
static_assert(sizeof(FReplicatedProjectileInfo) == 0x000034, "Wrong size on FReplicatedProjectileInfo");
static_assert(offsetof(FReplicatedProjectileInfo, Location) == 0x000000, "Member 'FReplicatedProjectileInfo::Location' has a wrong offset!");
static_assert(offsetof(FReplicatedProjectileInfo, Orientation) == 0x00000C, "Member 'FReplicatedProjectileInfo::Orientation' has a wrong offset!");
static_assert(offsetof(FReplicatedProjectileInfo, HitNormal) == 0x000018, "Member 'FReplicatedProjectileInfo::HitNormal' has a wrong offset!");
static_assert(offsetof(FReplicatedProjectileInfo, BounceForce) == 0x000024, "Member 'FReplicatedProjectileInfo::BounceForce' has a wrong offset!");
static_assert(offsetof(FReplicatedProjectileInfo, Creator) == 0x000028, "Member 'FReplicatedProjectileInfo::Creator' has a wrong offset!");
static_assert(offsetof(FReplicatedProjectileInfo, HitSurface) == 0x000030, "Member 'FReplicatedProjectileInfo::HitSurface' has a wrong offset!");
static_assert(offsetof(FReplicatedProjectileInfo, bHasStopped) == 0x000031, "Member 'FReplicatedProjectileInfo::bHasStopped' has a wrong offset!");
static_assert(offsetof(FReplicatedProjectileInfo, bHasHitWorld) == 0x000032, "Member 'FReplicatedProjectileInfo::bHasHitWorld' has a wrong offset!");
static_assert(offsetof(FReplicatedProjectileInfo, HitCounter) == 0x000033, "Member 'FReplicatedProjectileInfo::HitCounter' has a wrong offset!");

// ScriptStruct Mordhau.ServerAddress
// 0x0008 (0x0008 - 0x0000)
struct FServerAddress final
{
public:
	uint32                                        IP;                                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Port;                                              // 0x0004(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FServerAddress) == 0x000004, "Wrong alignment on FServerAddress");
static_assert(sizeof(FServerAddress) == 0x000008, "Wrong size on FServerAddress");
static_assert(offsetof(FServerAddress, IP) == 0x000000, "Member 'FServerAddress::IP' has a wrong offset!");
static_assert(offsetof(FServerAddress, Port) == 0x000004, "Member 'FServerAddress::Port' has a wrong offset!");

// ScriptStruct Mordhau.LobbySearchResult
// 0x0000 (0x0108 - 0x0108)
struct FLobbySearchResult final : public FSessionSearchResult
{
};
static_assert(alignof(FLobbySearchResult) == 0x000008, "Wrong alignment on FLobbySearchResult");
static_assert(sizeof(FLobbySearchResult) == 0x000108, "Wrong size on FLobbySearchResult");

// ScriptStruct Mordhau.FindServerSessionsFilter
// 0x0048 (0x0048 - 0x0000)
struct FFindServerSessionsFilter final
{
public:
	bool                                          bIsNotFull;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPlayers;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmpty;                                          // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNotPasswordProtected;                           // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDevBuild;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOfficial;                                       // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsConsoleServer;                                  // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EServerVisibility                             Visibility;                                        // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsModded;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinOpenSlots;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinSlots;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSlots;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPing;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerName;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EServerRegion                                 Region;                                            // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFindServerSessionsFilter) == 0x000008, "Wrong alignment on FFindServerSessionsFilter");
static_assert(sizeof(FFindServerSessionsFilter) == 0x000048, "Wrong size on FFindServerSessionsFilter");
static_assert(offsetof(FFindServerSessionsFilter, bIsNotFull) == 0x000000, "Member 'FFindServerSessionsFilter::bIsNotFull' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, bHasPlayers) == 0x000001, "Member 'FFindServerSessionsFilter::bHasPlayers' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, bIsEmpty) == 0x000002, "Member 'FFindServerSessionsFilter::bIsEmpty' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, bIsNotPasswordProtected) == 0x000003, "Member 'FFindServerSessionsFilter::bIsNotPasswordProtected' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, bIsDevBuild) == 0x000004, "Member 'FFindServerSessionsFilter::bIsDevBuild' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, bIsOfficial) == 0x000005, "Member 'FFindServerSessionsFilter::bIsOfficial' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, bIsConsoleServer) == 0x000006, "Member 'FFindServerSessionsFilter::bIsConsoleServer' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, Visibility) == 0x000007, "Member 'FFindServerSessionsFilter::Visibility' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, bIsModded) == 0x000008, "Member 'FFindServerSessionsFilter::bIsModded' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, MinOpenSlots) == 0x00000C, "Member 'FFindServerSessionsFilter::MinOpenSlots' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, MinSlots) == 0x000010, "Member 'FFindServerSessionsFilter::MinSlots' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, MaxSlots) == 0x000014, "Member 'FFindServerSessionsFilter::MaxSlots' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, MaxPing) == 0x000018, "Member 'FFindServerSessionsFilter::MaxPing' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, ServerName) == 0x000020, "Member 'FFindServerSessionsFilter::ServerName' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, GameMode) == 0x000030, "Member 'FFindServerSessionsFilter::GameMode' has a wrong offset!");
static_assert(offsetof(FFindServerSessionsFilter, Region) == 0x000040, "Member 'FFindServerSessionsFilter::Region' has a wrong offset!");

// ScriptStruct Mordhau.VisibilityMap
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FVisibilityMap final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVisibilityMap) == 0x000008, "Wrong alignment on FVisibilityMap");
static_assert(sizeof(FVisibilityMap) == 0x000058, "Wrong size on FVisibilityMap");

// ScriptStruct Mordhau.VisibilityList
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FVisibilityList final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVisibilityList) == 0x000008, "Wrong alignment on FVisibilityList");
static_assert(sizeof(FVisibilityList) == 0x000050, "Wrong size on FVisibilityList");

// ScriptStruct Mordhau.MordhauColorItemTable
// 0x0028 (0x0028 - 0x0000)
struct FMordhauColorItemTable final
{
public:
	class FText                                   TableName;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UMordhauColor>>      Entries;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMordhauColorItemTable) == 0x000008, "Wrong alignment on FMordhauColorItemTable");
static_assert(sizeof(FMordhauColorItemTable) == 0x000028, "Wrong size on FMordhauColorItemTable");
static_assert(offsetof(FMordhauColorItemTable, TableName) == 0x000000, "Member 'FMordhauColorItemTable::TableName' has a wrong offset!");
static_assert(offsetof(FMordhauColorItemTable, Entries) == 0x000018, "Member 'FMordhauColorItemTable::Entries' has a wrong offset!");

// ScriptStruct Mordhau.ColorTableEntry
// 0x0038 (0x0038 - 0x0000)
struct FColorTableEntry final
{
public:
	class FText                                   EntryName;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DisplayedColor;                                    // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FColorTableEntry) == 0x000008, "Wrong alignment on FColorTableEntry");
static_assert(sizeof(FColorTableEntry) == 0x000038, "Wrong size on FColorTableEntry");
static_assert(offsetof(FColorTableEntry, EntryName) == 0x000000, "Member 'FColorTableEntry::EntryName' has a wrong offset!");
static_assert(offsetof(FColorTableEntry, Color) == 0x000018, "Member 'FColorTableEntry::Color' has a wrong offset!");
static_assert(offsetof(FColorTableEntry, DisplayedColor) == 0x000028, "Member 'FColorTableEntry::DisplayedColor' has a wrong offset!");

// ScriptStruct Mordhau.MordhauColorTable
// 0x0028 (0x0028 - 0x0000)
struct FMordhauColorTable final
{
public:
	class FText                                   TableName;                                         // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FColorTableEntry>               Entries;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMordhauColorTable) == 0x000008, "Wrong alignment on FMordhauColorTable");
static_assert(sizeof(FMordhauColorTable) == 0x000028, "Wrong size on FMordhauColorTable");
static_assert(offsetof(FMordhauColorTable, TableName) == 0x000000, "Member 'FMordhauColorTable::TableName' has a wrong offset!");
static_assert(offsetof(FMordhauColorTable, Entries) == 0x000018, "Member 'FMordhauColorTable::Entries' has a wrong offset!");

// ScriptStruct Mordhau.Achievement
// 0x0008 (0x0008 - 0x0000)
struct FAchievement final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAchievement) == 0x000004, "Wrong alignment on FAchievement");
static_assert(sizeof(FAchievement) == 0x000008, "Wrong size on FAchievement");
static_assert(offsetof(FAchievement, Name) == 0x000000, "Member 'FAchievement::Name' has a wrong offset!");

// ScriptStruct Mordhau.Stat
// 0x000C (0x000C - 0x0000)
struct FStat final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatSetBy                                    SetBy;                                             // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStat) == 0x000004, "Wrong alignment on FStat");
static_assert(sizeof(FStat) == 0x00000C, "Wrong size on FStat");
static_assert(offsetof(FStat, Name) == 0x000000, "Member 'FStat::Name' has a wrong offset!");
static_assert(offsetof(FStat, SetBy) == 0x000008, "Member 'FStat::SetBy' has a wrong offset!");

// ScriptStruct Mordhau.DismemberedBoneData
// 0x0020 (0x0020 - 0x0000)
struct FDismemberedBoneData final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPartial;                                        // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBluntForce;                                     // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ForceDir;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Agent;                                             // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDismemberedBoneData) == 0x000004, "Wrong alignment on FDismemberedBoneData");
static_assert(sizeof(FDismemberedBoneData) == 0x000020, "Wrong size on FDismemberedBoneData");
static_assert(offsetof(FDismemberedBoneData, BoneName) == 0x000000, "Member 'FDismemberedBoneData::BoneName' has a wrong offset!");
static_assert(offsetof(FDismemberedBoneData, bIsPartial) == 0x000008, "Member 'FDismemberedBoneData::bIsPartial' has a wrong offset!");
static_assert(offsetof(FDismemberedBoneData, bIsBluntForce) == 0x000009, "Member 'FDismemberedBoneData::bIsBluntForce' has a wrong offset!");
static_assert(offsetof(FDismemberedBoneData, ForceDir) == 0x00000C, "Member 'FDismemberedBoneData::ForceDir' has a wrong offset!");
static_assert(offsetof(FDismemberedBoneData, Agent) == 0x000018, "Member 'FDismemberedBoneData::Agent' has a wrong offset!");

// ScriptStruct Mordhau.DismemberedQueue
// 0x0060 (0x0060 - 0x0000)
struct FDismemberedQueue final
{
public:
	TSet<class FName>                             BoneSet;                                           // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FDismemberedBoneData>           DismemberedBonesQueue;                             // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDismemberedQueue) == 0x000008, "Wrong alignment on FDismemberedQueue");
static_assert(sizeof(FDismemberedQueue) == 0x000060, "Wrong size on FDismemberedQueue");
static_assert(offsetof(FDismemberedQueue, BoneSet) == 0x000000, "Member 'FDismemberedQueue::BoneSet' has a wrong offset!");
static_assert(offsetof(FDismemberedQueue, DismemberedBonesQueue) == 0x000050, "Member 'FDismemberedQueue::DismemberedBonesQueue' has a wrong offset!");

// ScriptStruct Mordhau.MapInfo
// 0x0020 (0x0020 - 0x0000)
struct FMapInfo final
{
public:
	class FString                                 GameModeMapName;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameModeMetadata*                      GameModeMetadata;                                  // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapMetadata*                           MapMetadata;                                       // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapInfo) == 0x000008, "Wrong alignment on FMapInfo");
static_assert(sizeof(FMapInfo) == 0x000020, "Wrong size on FMapInfo");
static_assert(offsetof(FMapInfo, GameModeMapName) == 0x000000, "Member 'FMapInfo::GameModeMapName' has a wrong offset!");
static_assert(offsetof(FMapInfo, GameModeMetadata) == 0x000010, "Member 'FMapInfo::GameModeMetadata' has a wrong offset!");
static_assert(offsetof(FMapInfo, MapMetadata) == 0x000018, "Member 'FMapInfo::MapMetadata' has a wrong offset!");

// ScriptStruct Mordhau.SoundClassInfo
// 0x0018 (0x0018 - 0x0000)
struct FSoundClassInfo final
{
public:
	class USoundClass*                            SoundClass;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundMix*>                      SoundMixes;                                        // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundClassInfo) == 0x000008, "Wrong alignment on FSoundClassInfo");
static_assert(sizeof(FSoundClassInfo) == 0x000018, "Wrong size on FSoundClassInfo");
static_assert(offsetof(FSoundClassInfo, SoundClass) == 0x000000, "Member 'FSoundClassInfo::SoundClass' has a wrong offset!");
static_assert(offsetof(FSoundClassInfo, SoundMixes) == 0x000008, "Member 'FSoundClassInfo::SoundMixes' has a wrong offset!");

// ScriptStruct Mordhau.SoundMixInfo
// 0x0018 (0x0018 - 0x0000)
struct FSoundMixInfo final
{
public:
	class USoundMix*                              SoundMix;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundClass*>                    SoundClasses;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundMixInfo) == 0x000008, "Wrong alignment on FSoundMixInfo");
static_assert(sizeof(FSoundMixInfo) == 0x000018, "Wrong size on FSoundMixInfo");
static_assert(offsetof(FSoundMixInfo, SoundMix) == 0x000000, "Member 'FSoundMixInfo::SoundMix' has a wrong offset!");
static_assert(offsetof(FSoundMixInfo, SoundClasses) == 0x000008, "Member 'FSoundMixInfo::SoundClasses' has a wrong offset!");

// ScriptStruct Mordhau.FloatAndVector
// 0x0010 (0x0010 - 0x0000)
struct FFloatAndVector final
{
public:
	float                                         Float;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Vector;                                            // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatAndVector) == 0x000004, "Wrong alignment on FFloatAndVector");
static_assert(sizeof(FFloatAndVector) == 0x000010, "Wrong size on FFloatAndVector");
static_assert(offsetof(FFloatAndVector, Float) == 0x000000, "Member 'FFloatAndVector::Float' has a wrong offset!");
static_assert(offsetof(FFloatAndVector, Vector) == 0x000004, "Member 'FFloatAndVector::Vector' has a wrong offset!");

// ScriptStruct Mordhau.DecalInfo
// 0x0018 (0x0018 - 0x0000)
struct FDecalInfo final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Size;                                              // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDecalInfo) == 0x000008, "Wrong alignment on FDecalInfo");
static_assert(sizeof(FDecalInfo) == 0x000018, "Wrong size on FDecalInfo");
static_assert(offsetof(FDecalInfo, Material) == 0x000000, "Member 'FDecalInfo::Material' has a wrong offset!");
static_assert(offsetof(FDecalInfo, Size) == 0x000008, "Member 'FDecalInfo::Size' has a wrong offset!");

// ScriptStruct Mordhau.WoundMaterialData
// 0x0038 (0x0038 - 0x0000)
struct FWoundMaterialData final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpVector;                                          // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightVector;                                       // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForwardVector;                                     // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WoundType;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWoundMaterialData) == 0x000004, "Wrong alignment on FWoundMaterialData");
static_assert(sizeof(FWoundMaterialData) == 0x000038, "Wrong size on FWoundMaterialData");
static_assert(offsetof(FWoundMaterialData, Location) == 0x000000, "Member 'FWoundMaterialData::Location' has a wrong offset!");
static_assert(offsetof(FWoundMaterialData, UpVector) == 0x00000C, "Member 'FWoundMaterialData::UpVector' has a wrong offset!");
static_assert(offsetof(FWoundMaterialData, RightVector) == 0x000018, "Member 'FWoundMaterialData::RightVector' has a wrong offset!");
static_assert(offsetof(FWoundMaterialData, ForwardVector) == 0x000024, "Member 'FWoundMaterialData::ForwardVector' has a wrong offset!");
static_assert(offsetof(FWoundMaterialData, WoundType) == 0x000030, "Member 'FWoundMaterialData::WoundType' has a wrong offset!");

// ScriptStruct Mordhau.MordhauDamageEvent
// 0x0018 (0x00C8 - 0x00B0)
struct FMordhauDamageEvent final : public FPointDamageEvent
{
public:
	EMordhauDamageType                            Type;                                              // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SubType;                                           // 0x00B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x2];                                       // 0x00B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  DamageSource;                                      // 0x00B4(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  DamageAgent;                                       // 0x00BC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsFlinchAnimation;                             // 0x00C4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMordhauDamageEvent) == 0x000008, "Wrong alignment on FMordhauDamageEvent");
static_assert(sizeof(FMordhauDamageEvent) == 0x0000C8, "Wrong size on FMordhauDamageEvent");
static_assert(offsetof(FMordhauDamageEvent, Type) == 0x0000B0, "Member 'FMordhauDamageEvent::Type' has a wrong offset!");
static_assert(offsetof(FMordhauDamageEvent, SubType) == 0x0000B1, "Member 'FMordhauDamageEvent::SubType' has a wrong offset!");
static_assert(offsetof(FMordhauDamageEvent, DamageSource) == 0x0000B4, "Member 'FMordhauDamageEvent::DamageSource' has a wrong offset!");
static_assert(offsetof(FMordhauDamageEvent, DamageAgent) == 0x0000BC, "Member 'FMordhauDamageEvent::DamageAgent' has a wrong offset!");
static_assert(offsetof(FMordhauDamageEvent, bWantsFlinchAnimation) == 0x0000C4, "Member 'FMordhauDamageEvent::bWantsFlinchAnimation' has a wrong offset!");

// ScriptStruct Mordhau.ActorSetAndArray
// 0x0060 (0x0060 - 0x0000)
struct FActorSetAndArray final
{
public:
	TSet<class AActor*>                           Set;                                               // 0x0000(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         Array;                                             // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FActorSetAndArray) == 0x000008, "Wrong alignment on FActorSetAndArray");
static_assert(sizeof(FActorSetAndArray) == 0x000060, "Wrong size on FActorSetAndArray");
static_assert(offsetof(FActorSetAndArray, Set) == 0x000000, "Member 'FActorSetAndArray::Set' has a wrong offset!");
static_assert(offsetof(FActorSetAndArray, Array) == 0x000050, "Member 'FActorSetAndArray::Array' has a wrong offset!");

// ScriptStruct Mordhau.ActorTraceEntry
// 0x0058 (0x0058 - 0x0000)
struct FActorTraceEntry final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class FName>                             BonesHit;                                          // 0x0008(0x0050)(NativeAccessSpecifierPrivate)
};
static_assert(alignof(FActorTraceEntry) == 0x000008, "Wrong alignment on FActorTraceEntry");
static_assert(sizeof(FActorTraceEntry) == 0x000058, "Wrong size on FActorTraceEntry");
static_assert(offsetof(FActorTraceEntry, Actor) == 0x000000, "Member 'FActorTraceEntry::Actor' has a wrong offset!");
static_assert(offsetof(FActorTraceEntry, BonesHit) == 0x000008, "Member 'FActorTraceEntry::BonesHit' has a wrong offset!");

// ScriptStruct Mordhau.ActorTraceData
// 0x0068 (0x0068 - 0x0000)
struct FActorTraceData final
{
public:
	bool                                          bIgnoreFurtherTraces;                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAllowedToAddForce;                              // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           Set;                                               // 0x0008(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FActorTraceEntry>               ActorTraceEntryArray;                              // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FActorTraceData) == 0x000008, "Wrong alignment on FActorTraceData");
static_assert(sizeof(FActorTraceData) == 0x000068, "Wrong size on FActorTraceData");
static_assert(offsetof(FActorTraceData, bIgnoreFurtherTraces) == 0x000000, "Member 'FActorTraceData::bIgnoreFurtherTraces' has a wrong offset!");
static_assert(offsetof(FActorTraceData, bIsAllowedToAddForce) == 0x000001, "Member 'FActorTraceData::bIsAllowedToAddForce' has a wrong offset!");
static_assert(offsetof(FActorTraceData, Set) == 0x000008, "Member 'FActorTraceData::Set' has a wrong offset!");
static_assert(offsetof(FActorTraceData, ActorTraceEntryArray) == 0x000058, "Member 'FActorTraceData::ActorTraceEntryArray' has a wrong offset!");

// ScriptStruct Mordhau.PermutationValuePair
// 0x0008 (0x0008 - 0x0000)
struct FPermutationValuePair final
{
public:
	int32                                         Permutation;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPermutationValuePair) == 0x000004, "Wrong alignment on FPermutationValuePair");
static_assert(sizeof(FPermutationValuePair) == 0x000008, "Wrong size on FPermutationValuePair");
static_assert(offsetof(FPermutationValuePair, Permutation) == 0x000000, "Member 'FPermutationValuePair::Permutation' has a wrong offset!");
static_assert(offsetof(FPermutationValuePair, Value) == 0x000004, "Member 'FPermutationValuePair::Value' has a wrong offset!");

// ScriptStruct Mordhau.ArrayOfActor
// 0x0010 (0x0010 - 0x0000)
struct FArrayOfActor final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrayOfActor) == 0x000008, "Wrong alignment on FArrayOfActor");
static_assert(sizeof(FArrayOfActor) == 0x000010, "Wrong size on FArrayOfActor");
static_assert(offsetof(FArrayOfActor, Actors) == 0x000000, "Member 'FArrayOfActor::Actors' has a wrong offset!");

// ScriptStruct Mordhau.NetMotion
// 0x0006 (0x0006 - 0x0000)
struct FNetMotion final
{
public:
	uint8                                         ID;                                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MotionType;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MotionParam0;                                      // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MotionParam1;                                      // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MotionParam2;                                      // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MotionDynamicParam;                                // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNetMotion) == 0x000001, "Wrong alignment on FNetMotion");
static_assert(sizeof(FNetMotion) == 0x000006, "Wrong size on FNetMotion");
static_assert(offsetof(FNetMotion, ID) == 0x000000, "Member 'FNetMotion::ID' has a wrong offset!");
static_assert(offsetof(FNetMotion, MotionType) == 0x000001, "Member 'FNetMotion::MotionType' has a wrong offset!");
static_assert(offsetof(FNetMotion, MotionParam0) == 0x000002, "Member 'FNetMotion::MotionParam0' has a wrong offset!");
static_assert(offsetof(FNetMotion, MotionParam1) == 0x000003, "Member 'FNetMotion::MotionParam1' has a wrong offset!");
static_assert(offsetof(FNetMotion, MotionParam2) == 0x000004, "Member 'FNetMotion::MotionParam2' has a wrong offset!");
static_assert(offsetof(FNetMotion, MotionDynamicParam) == 0x000005, "Member 'FNetMotion::MotionDynamicParam' has a wrong offset!");

// ScriptStruct Mordhau.PerspectiveVector2D
// 0x0010 (0x0010 - 0x0000)
struct FPerspectiveVector2D final
{
public:
	struct FVector2D                              ThirdPerson;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FirstPerson;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerspectiveVector2D) == 0x000004, "Wrong alignment on FPerspectiveVector2D");
static_assert(sizeof(FPerspectiveVector2D) == 0x000010, "Wrong size on FPerspectiveVector2D");
static_assert(offsetof(FPerspectiveVector2D, ThirdPerson) == 0x000000, "Member 'FPerspectiveVector2D::ThirdPerson' has a wrong offset!");
static_assert(offsetof(FPerspectiveVector2D, FirstPerson) == 0x000008, "Member 'FPerspectiveVector2D::FirstPerson' has a wrong offset!");

// ScriptStruct Mordhau.PerspectiveAnglingSpineSpaceAdditive
// 0x0630 (0x0630 - 0x0000)
struct FPerspectiveAnglingSpineSpaceAdditive final
{
public:
	struct FAnglingSpineSpaceAdditive             ThirdPerson;                                       // 0x0000(0x0318)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnglingSpineSpaceAdditive             FirstPerson;                                       // 0x0318(0x0318)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerspectiveAnglingSpineSpaceAdditive) == 0x000004, "Wrong alignment on FPerspectiveAnglingSpineSpaceAdditive");
static_assert(sizeof(FPerspectiveAnglingSpineSpaceAdditive) == 0x000630, "Wrong size on FPerspectiveAnglingSpineSpaceAdditive");
static_assert(offsetof(FPerspectiveAnglingSpineSpaceAdditive, ThirdPerson) == 0x000000, "Member 'FPerspectiveAnglingSpineSpaceAdditive::ThirdPerson' has a wrong offset!");
static_assert(offsetof(FPerspectiveAnglingSpineSpaceAdditive, FirstPerson) == 0x000318, "Member 'FPerspectiveAnglingSpineSpaceAdditive::FirstPerson' has a wrong offset!");

// ScriptStruct Mordhau.PerspectiveHighMidLowSpineSpaceAdditive
// 0x0318 (0x0318 - 0x0000)
struct FPerspectiveHighMidLowSpineSpaceAdditive final
{
public:
	struct FHighMidLowSpineSpaceAdditive          ThirdPerson;                                       // 0x0000(0x018C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FHighMidLowSpineSpaceAdditive          FirstPerson;                                       // 0x018C(0x018C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerspectiveHighMidLowSpineSpaceAdditive) == 0x000004, "Wrong alignment on FPerspectiveHighMidLowSpineSpaceAdditive");
static_assert(sizeof(FPerspectiveHighMidLowSpineSpaceAdditive) == 0x000318, "Wrong size on FPerspectiveHighMidLowSpineSpaceAdditive");
static_assert(offsetof(FPerspectiveHighMidLowSpineSpaceAdditive, ThirdPerson) == 0x000000, "Member 'FPerspectiveHighMidLowSpineSpaceAdditive::ThirdPerson' has a wrong offset!");
static_assert(offsetof(FPerspectiveHighMidLowSpineSpaceAdditive, FirstPerson) == 0x00018C, "Member 'FPerspectiveHighMidLowSpineSpaceAdditive::FirstPerson' has a wrong offset!");

// ScriptStruct Mordhau.PerspectiveBool
// 0x0002 (0x0002 - 0x0000)
struct FPerspectiveBool final
{
public:
	bool                                          ThirdPerson;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FirstPerson;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerspectiveBool) == 0x000001, "Wrong alignment on FPerspectiveBool");
static_assert(sizeof(FPerspectiveBool) == 0x000002, "Wrong size on FPerspectiveBool");
static_assert(offsetof(FPerspectiveBool, ThirdPerson) == 0x000000, "Member 'FPerspectiveBool::ThirdPerson' has a wrong offset!");
static_assert(offsetof(FPerspectiveBool, FirstPerson) == 0x000001, "Member 'FPerspectiveBool::FirstPerson' has a wrong offset!");

// ScriptStruct Mordhau.PerspectiveBlendSpaceBase
// 0x0010 (0x0010 - 0x0000)
struct FPerspectiveBlendSpaceBase final
{
public:
	class UBlendSpaceBase*                        ThirdPerson;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        FirstPerson;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerspectiveBlendSpaceBase) == 0x000008, "Wrong alignment on FPerspectiveBlendSpaceBase");
static_assert(sizeof(FPerspectiveBlendSpaceBase) == 0x000010, "Wrong size on FPerspectiveBlendSpaceBase");
static_assert(offsetof(FPerspectiveBlendSpaceBase, ThirdPerson) == 0x000000, "Member 'FPerspectiveBlendSpaceBase::ThirdPerson' has a wrong offset!");
static_assert(offsetof(FPerspectiveBlendSpaceBase, FirstPerson) == 0x000008, "Member 'FPerspectiveBlendSpaceBase::FirstPerson' has a wrong offset!");

// ScriptStruct Mordhau.PerspectiveAnimSequenceBase
// 0x0010 (0x0010 - 0x0000)
struct FPerspectiveAnimSequenceBase final
{
public:
	class UAnimSequenceBase*                      ThirdPerson;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      FirstPerson;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerspectiveAnimSequenceBase) == 0x000008, "Wrong alignment on FPerspectiveAnimSequenceBase");
static_assert(sizeof(FPerspectiveAnimSequenceBase) == 0x000010, "Wrong size on FPerspectiveAnimSequenceBase");
static_assert(offsetof(FPerspectiveAnimSequenceBase, ThirdPerson) == 0x000000, "Member 'FPerspectiveAnimSequenceBase::ThirdPerson' has a wrong offset!");
static_assert(offsetof(FPerspectiveAnimSequenceBase, FirstPerson) == 0x000008, "Member 'FPerspectiveAnimSequenceBase::FirstPerson' has a wrong offset!");

// ScriptStruct Mordhau.PerspectiveAnimSequenceBaseArray
// 0x0010 (0x0010 - 0x0000)
struct FPerspectiveAnimSequenceBaseArray final
{
public:
	TArray<struct FPerspectiveAnimSequenceBase>   Array;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerspectiveAnimSequenceBaseArray) == 0x000008, "Wrong alignment on FPerspectiveAnimSequenceBaseArray");
static_assert(sizeof(FPerspectiveAnimSequenceBaseArray) == 0x000010, "Wrong size on FPerspectiveAnimSequenceBaseArray");
static_assert(offsetof(FPerspectiveAnimSequenceBaseArray, Array) == 0x000000, "Member 'FPerspectiveAnimSequenceBaseArray::Array' has a wrong offset!");

// ScriptStruct Mordhau.PerspectiveAnimSequence
// 0x0010 (0x0010 - 0x0000)
struct FPerspectiveAnimSequence final
{
public:
	class UAnimSequence*                          ThirdPerson;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          FirstPerson;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerspectiveAnimSequence) == 0x000008, "Wrong alignment on FPerspectiveAnimSequence");
static_assert(sizeof(FPerspectiveAnimSequence) == 0x000010, "Wrong size on FPerspectiveAnimSequence");
static_assert(offsetof(FPerspectiveAnimSequence, ThirdPerson) == 0x000000, "Member 'FPerspectiveAnimSequence::ThirdPerson' has a wrong offset!");
static_assert(offsetof(FPerspectiveAnimSequence, FirstPerson) == 0x000008, "Member 'FPerspectiveAnimSequence::FirstPerson' has a wrong offset!");

// ScriptStruct Mordhau.PerspectiveAnimMontage
// 0x0010 (0x0010 - 0x0000)
struct FPerspectiveAnimMontage final
{
public:
	class UAnimMontage*                           ThirdPerson;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FirstPerson;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerspectiveAnimMontage) == 0x000008, "Wrong alignment on FPerspectiveAnimMontage");
static_assert(sizeof(FPerspectiveAnimMontage) == 0x000010, "Wrong size on FPerspectiveAnimMontage");
static_assert(offsetof(FPerspectiveAnimMontage, ThirdPerson) == 0x000000, "Member 'FPerspectiveAnimMontage::ThirdPerson' has a wrong offset!");
static_assert(offsetof(FPerspectiveAnimMontage, FirstPerson) == 0x000008, "Member 'FPerspectiveAnimMontage::FirstPerson' has a wrong offset!");

// ScriptStruct Mordhau.PerspectiveCurveFloat
// 0x0010 (0x0010 - 0x0000)
struct FPerspectiveCurveFloat final
{
public:
	class UCurveFloat*                            ThirdPerson;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FirstPerson;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerspectiveCurveFloat) == 0x000008, "Wrong alignment on FPerspectiveCurveFloat");
static_assert(sizeof(FPerspectiveCurveFloat) == 0x000010, "Wrong size on FPerspectiveCurveFloat");
static_assert(offsetof(FPerspectiveCurveFloat, ThirdPerson) == 0x000000, "Member 'FPerspectiveCurveFloat::ThirdPerson' has a wrong offset!");
static_assert(offsetof(FPerspectiveCurveFloat, FirstPerson) == 0x000008, "Member 'FPerspectiveCurveFloat::FirstPerson' has a wrong offset!");

// ScriptStruct Mordhau.RconResponseStruct
// 0x0048 (0x0048 - 0x0000)
struct FRconResponseStruct final
{
public:
	class UPlayFabJsonObject*                     RootObject;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayFabJsonObject*                     DataObject;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CommandName;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Type;                                              // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FailureReason;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRconResponseStruct) == 0x000008, "Wrong alignment on FRconResponseStruct");
static_assert(sizeof(FRconResponseStruct) == 0x000048, "Wrong size on FRconResponseStruct");
static_assert(offsetof(FRconResponseStruct, RootObject) == 0x000000, "Member 'FRconResponseStruct::RootObject' has a wrong offset!");
static_assert(offsetof(FRconResponseStruct, DataObject) == 0x000008, "Member 'FRconResponseStruct::DataObject' has a wrong offset!");
static_assert(offsetof(FRconResponseStruct, CommandName) == 0x000010, "Member 'FRconResponseStruct::CommandName' has a wrong offset!");
static_assert(offsetof(FRconResponseStruct, Type) == 0x000020, "Member 'FRconResponseStruct::Type' has a wrong offset!");
static_assert(offsetof(FRconResponseStruct, bSuccess) == 0x000030, "Member 'FRconResponseStruct::bSuccess' has a wrong offset!");
static_assert(offsetof(FRconResponseStruct, FailureReason) == 0x000038, "Member 'FRconResponseStruct::FailureReason' has a wrong offset!");

// ScriptStruct Mordhau.PlayerlistPlayer
// 0x0040 (0x0040 - 0x0000)
struct FPlayerlistPlayer final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Team;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayFabId;                                         // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Platform;                                          // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsABot;                                           // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerlistPlayer) == 0x000008, "Wrong alignment on FPlayerlistPlayer");
static_assert(sizeof(FPlayerlistPlayer) == 0x000040, "Wrong size on FPlayerlistPlayer");
static_assert(offsetof(FPlayerlistPlayer, Name) == 0x000000, "Member 'FPlayerlistPlayer::Name' has a wrong offset!");
static_assert(offsetof(FPlayerlistPlayer, Team) == 0x000010, "Member 'FPlayerlistPlayer::Team' has a wrong offset!");
static_assert(offsetof(FPlayerlistPlayer, PlayFabId) == 0x000018, "Member 'FPlayerlistPlayer::PlayFabId' has a wrong offset!");
static_assert(offsetof(FPlayerlistPlayer, Platform) == 0x000028, "Member 'FPlayerlistPlayer::Platform' has a wrong offset!");
static_assert(offsetof(FPlayerlistPlayer, bIsABot) == 0x000038, "Member 'FPlayerlistPlayer::bIsABot' has a wrong offset!");

// ScriptStruct Mordhau.PlayerlistResponse
// 0x0068 (0x0068 - 0x0000)
struct FPlayerlistResponse final
{
public:
	struct FRconResponseStruct                    BaseResponse;                                      // 0x0000(0x0048)(NativeAccessSpecifierPublic)
	TArray<struct FPlayerlistPlayer>              Players;                                           // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PlayerCount;                                       // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BotCount;                                          // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVerbose;                                          // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeBots;                                      // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerlistResponse) == 0x000008, "Wrong alignment on FPlayerlistResponse");
static_assert(sizeof(FPlayerlistResponse) == 0x000068, "Wrong size on FPlayerlistResponse");
static_assert(offsetof(FPlayerlistResponse, BaseResponse) == 0x000000, "Member 'FPlayerlistResponse::BaseResponse' has a wrong offset!");
static_assert(offsetof(FPlayerlistResponse, Players) == 0x000048, "Member 'FPlayerlistResponse::Players' has a wrong offset!");
static_assert(offsetof(FPlayerlistResponse, PlayerCount) == 0x000058, "Member 'FPlayerlistResponse::PlayerCount' has a wrong offset!");
static_assert(offsetof(FPlayerlistResponse, BotCount) == 0x00005C, "Member 'FPlayerlistResponse::BotCount' has a wrong offset!");
static_assert(offsetof(FPlayerlistResponse, bVerbose) == 0x000060, "Member 'FPlayerlistResponse::bVerbose' has a wrong offset!");
static_assert(offsetof(FPlayerlistResponse, bIncludeBots) == 0x000061, "Member 'FPlayerlistResponse::bIncludeBots' has a wrong offset!");

// ScriptStruct Mordhau.RconParameter
// 0x0028 (0x0028 - 0x0000)
struct FRconParameter final
{
public:
	class FString                                 ParameterName;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParameterDescription;                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiredParameter;                                // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPFJson                                       ExpectedJsonType;                                  // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRconParameter) == 0x000008, "Wrong alignment on FRconParameter");
static_assert(sizeof(FRconParameter) == 0x000028, "Wrong size on FRconParameter");
static_assert(offsetof(FRconParameter, ParameterName) == 0x000000, "Member 'FRconParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(FRconParameter, ParameterDescription) == 0x000010, "Member 'FRconParameter::ParameterDescription' has a wrong offset!");
static_assert(offsetof(FRconParameter, bRequiredParameter) == 0x000020, "Member 'FRconParameter::bRequiredParameter' has a wrong offset!");
static_assert(offsetof(FRconParameter, ExpectedJsonType) == 0x000021, "Member 'FRconParameter::ExpectedJsonType' has a wrong offset!");

// ScriptStruct Mordhau.RconCommandInfo
// 0x0050 (0x0050 - 0x0000)
struct FRconCommandInfo final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Author;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Aliases;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRconParameter>                 Parameters;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRconCommandInfo) == 0x000008, "Wrong alignment on FRconCommandInfo");
static_assert(sizeof(FRconCommandInfo) == 0x000050, "Wrong size on FRconCommandInfo");
static_assert(offsetof(FRconCommandInfo, Name) == 0x000000, "Member 'FRconCommandInfo::Name' has a wrong offset!");
static_assert(offsetof(FRconCommandInfo, Description) == 0x000010, "Member 'FRconCommandInfo::Description' has a wrong offset!");
static_assert(offsetof(FRconCommandInfo, Author) == 0x000020, "Member 'FRconCommandInfo::Author' has a wrong offset!");
static_assert(offsetof(FRconCommandInfo, Aliases) == 0x000030, "Member 'FRconCommandInfo::Aliases' has a wrong offset!");
static_assert(offsetof(FRconCommandInfo, Parameters) == 0x000040, "Member 'FRconCommandInfo::Parameters' has a wrong offset!");

// ScriptStruct Mordhau.RconRequestInfoResponse
// 0x0058 (0x0058 - 0x0000)
struct FRconRequestInfoResponse final
{
public:
	struct FRconCommandInfo                       CommandInfo;                                       // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bSuccess;                                          // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRconRequestInfoResponse) == 0x000008, "Wrong alignment on FRconRequestInfoResponse");
static_assert(sizeof(FRconRequestInfoResponse) == 0x000058, "Wrong size on FRconRequestInfoResponse");
static_assert(offsetof(FRconRequestInfoResponse, CommandInfo) == 0x000000, "Member 'FRconRequestInfoResponse::CommandInfo' has a wrong offset!");
static_assert(offsetof(FRconRequestInfoResponse, bSuccess) == 0x000050, "Member 'FRconRequestInfoResponse::bSuccess' has a wrong offset!");

// ScriptStruct Mordhau.RconFlag
// 0x0040 (0x0040 - 0x0000)
struct FRconFlag final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URconCommand*>                   CommandObjects;                                    // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRconFlag) == 0x000008, "Wrong alignment on FRconFlag");
static_assert(sizeof(FRconFlag) == 0x000040, "Wrong size on FRconFlag");
static_assert(offsetof(FRconFlag, CommandObjects) == 0x000030, "Member 'FRconFlag::CommandObjects' has a wrong offset!");

// ScriptStruct Mordhau.GameplayTagCondition
// 0x0040 (0x0040 - 0x0000)
struct FGameplayTagCondition final
{
public:
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x0000(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockedTags;                                       // 0x0020(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagCondition) == 0x000008, "Wrong alignment on FGameplayTagCondition");
static_assert(sizeof(FGameplayTagCondition) == 0x000040, "Wrong size on FGameplayTagCondition");
static_assert(offsetof(FGameplayTagCondition, RequiredTags) == 0x000000, "Member 'FGameplayTagCondition::RequiredTags' has a wrong offset!");
static_assert(offsetof(FGameplayTagCondition, BlockedTags) == 0x000020, "Member 'FGameplayTagCondition::BlockedTags' has a wrong offset!");

// ScriptStruct Mordhau.GameplayTagConditionDelegate
// 0x0058 (0x0058 - 0x0000)
struct FGameplayTagConditionDelegate final
{
public:
	struct FGameplayTagCondition                  Condition;                                         // 0x0000(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTagSystemComponent* TagSystemComponent, bool bIsConditionSatisfied)> Delegate;                                          // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsConditionSatisfied;                             // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameplayTagConditionDelegate) == 0x000008, "Wrong alignment on FGameplayTagConditionDelegate");
static_assert(sizeof(FGameplayTagConditionDelegate) == 0x000058, "Wrong size on FGameplayTagConditionDelegate");
static_assert(offsetof(FGameplayTagConditionDelegate, Condition) == 0x000000, "Member 'FGameplayTagConditionDelegate::Condition' has a wrong offset!");
static_assert(offsetof(FGameplayTagConditionDelegate, Delegate) == 0x000040, "Member 'FGameplayTagConditionDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(FGameplayTagConditionDelegate, bIsConditionSatisfied) == 0x000050, "Member 'FGameplayTagConditionDelegate::bIsConditionSatisfied' has a wrong offset!");

// ScriptStruct Mordhau.NetState
// 0x0028 (0x0028 - 0x0000)
struct FNetState final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalTimestamp;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 position;                                          // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	uint16                                        Pitch;                                             // 0x0020(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Yaw;                                               // 0x0022(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Roll;                                              // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNetState) == 0x000004, "Wrong alignment on FNetState");
static_assert(sizeof(FNetState) == 0x000028, "Wrong size on FNetState");
static_assert(offsetof(FNetState, Timestamp) == 0x000000, "Member 'FNetState::Timestamp' has a wrong offset!");
static_assert(offsetof(FNetState, LocalTimestamp) == 0x000004, "Member 'FNetState::LocalTimestamp' has a wrong offset!");
static_assert(offsetof(FNetState, position) == 0x000008, "Member 'FNetState::position' has a wrong offset!");
static_assert(offsetof(FNetState, Rotation) == 0x000014, "Member 'FNetState::Rotation' has a wrong offset!");
static_assert(offsetof(FNetState, Pitch) == 0x000020, "Member 'FNetState::Pitch' has a wrong offset!");
static_assert(offsetof(FNetState, Yaw) == 0x000022, "Member 'FNetState::Yaw' has a wrong offset!");
static_assert(offsetof(FNetState, Roll) == 0x000024, "Member 'FNetState::Roll' has a wrong offset!");

// ScriptStruct Mordhau.EmbedFooterField
// 0x0010 (0x0010 - 0x0000)
struct FEmbedFooterField final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmbedFooterField) == 0x000008, "Wrong alignment on FEmbedFooterField");
static_assert(sizeof(FEmbedFooterField) == 0x000010, "Wrong size on FEmbedFooterField");
static_assert(offsetof(FEmbedFooterField, Text) == 0x000000, "Member 'FEmbedFooterField::Text' has a wrong offset!");

// ScriptStruct Mordhau.EmbedAuthorField
// 0x0010 (0x0010 - 0x0000)
struct FEmbedAuthorField final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmbedAuthorField) == 0x000008, "Wrong alignment on FEmbedAuthorField");
static_assert(sizeof(FEmbedAuthorField) == 0x000010, "Wrong size on FEmbedAuthorField");
static_assert(offsetof(FEmbedAuthorField, Name) == 0x000000, "Member 'FEmbedAuthorField::Name' has a wrong offset!");

// ScriptStruct Mordhau.EmbedFieldField
// 0x0028 (0x0028 - 0x0000)
struct FEmbedFieldField final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInline;                                           // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmbedFieldField) == 0x000008, "Wrong alignment on FEmbedFieldField");
static_assert(sizeof(FEmbedFieldField) == 0x000028, "Wrong size on FEmbedFieldField");
static_assert(offsetof(FEmbedFieldField, Name) == 0x000000, "Member 'FEmbedFieldField::Name' has a wrong offset!");
static_assert(offsetof(FEmbedFieldField, Value) == 0x000010, "Member 'FEmbedFieldField::Value' has a wrong offset!");
static_assert(offsetof(FEmbedFieldField, bInline) == 0x000020, "Member 'FEmbedFieldField::bInline' has a wrong offset!");

// ScriptStruct Mordhau.DiscordEmbed
// 0x0070 (0x0070 - 0x0000)
struct FDiscordEmbed final
{
public:
	class FString                                 Title;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Color;                                             // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Timestamp;                                         // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEmbedFooterField                      Footer;                                            // 0x0040(0x0010)(NativeAccessSpecifierPublic)
	struct FEmbedAuthorField                      Author;                                            // 0x0050(0x0010)(NativeAccessSpecifierPublic)
	TArray<struct FEmbedFieldField>               Fields;                                            // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDiscordEmbed) == 0x000008, "Wrong alignment on FDiscordEmbed");
static_assert(sizeof(FDiscordEmbed) == 0x000070, "Wrong size on FDiscordEmbed");
static_assert(offsetof(FDiscordEmbed, Title) == 0x000000, "Member 'FDiscordEmbed::Title' has a wrong offset!");
static_assert(offsetof(FDiscordEmbed, Description) == 0x000010, "Member 'FDiscordEmbed::Description' has a wrong offset!");
static_assert(offsetof(FDiscordEmbed, Color) == 0x000020, "Member 'FDiscordEmbed::Color' has a wrong offset!");
static_assert(offsetof(FDiscordEmbed, Timestamp) == 0x000030, "Member 'FDiscordEmbed::Timestamp' has a wrong offset!");
static_assert(offsetof(FDiscordEmbed, Footer) == 0x000040, "Member 'FDiscordEmbed::Footer' has a wrong offset!");
static_assert(offsetof(FDiscordEmbed, Author) == 0x000050, "Member 'FDiscordEmbed::Author' has a wrong offset!");
static_assert(offsetof(FDiscordEmbed, Fields) == 0x000060, "Member 'FDiscordEmbed::Fields' has a wrong offset!");

// ScriptStruct Mordhau.DiscordMessage
// 0x0030 (0x0030 - 0x0000)
struct FDiscordMessage final
{
public:
	TArray<struct FDiscordEmbed>                  Embeds;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Content;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Username;                                          // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDiscordMessage) == 0x000008, "Wrong alignment on FDiscordMessage");
static_assert(sizeof(FDiscordMessage) == 0x000030, "Wrong size on FDiscordMessage");
static_assert(offsetof(FDiscordMessage, Embeds) == 0x000000, "Member 'FDiscordMessage::Embeds' has a wrong offset!");
static_assert(offsetof(FDiscordMessage, Content) == 0x000010, "Member 'FDiscordMessage::Content' has a wrong offset!");
static_assert(offsetof(FDiscordMessage, Username) == 0x000020, "Member 'FDiscordMessage::Username' has a wrong offset!");

// ScriptStruct Mordhau.ReportMessage
// 0x0028 (0x0028 - 0x0000)
struct FReportMessage final
{
public:
	class FString                                 Body;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Team;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReportMessage) == 0x000008, "Wrong alignment on FReportMessage");
static_assert(sizeof(FReportMessage) == 0x000028, "Wrong size on FReportMessage");
static_assert(offsetof(FReportMessage, Body) == 0x000000, "Member 'FReportMessage::Body' has a wrong offset!");
static_assert(offsetof(FReportMessage, Prefix) == 0x000010, "Member 'FReportMessage::Prefix' has a wrong offset!");
static_assert(offsetof(FReportMessage, Team) == 0x000020, "Member 'FReportMessage::Team' has a wrong offset!");

// ScriptStruct Mordhau.PlayerReport
// 0x0090 (0x0090 - 0x0000)
struct FPlayerReport final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReporteePlayFabID;                                 // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReporterPlayFabID;                                 // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReportType;                                        // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Timestamp;                                         // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerName;                                        // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ScreenshotFilename;                                // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 KillsDeathsTksTD;                                  // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FReportMessage>                 Messages;                                          // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerReport) == 0x000008, "Wrong alignment on FPlayerReport");
static_assert(sizeof(FPlayerReport) == 0x000090, "Wrong size on FPlayerReport");
static_assert(offsetof(FPlayerReport, PlayerName) == 0x000000, "Member 'FPlayerReport::PlayerName' has a wrong offset!");
static_assert(offsetof(FPlayerReport, ReporteePlayFabID) == 0x000010, "Member 'FPlayerReport::ReporteePlayFabID' has a wrong offset!");
static_assert(offsetof(FPlayerReport, ReporterPlayFabID) == 0x000020, "Member 'FPlayerReport::ReporterPlayFabID' has a wrong offset!");
static_assert(offsetof(FPlayerReport, ReportType) == 0x000030, "Member 'FPlayerReport::ReportType' has a wrong offset!");
static_assert(offsetof(FPlayerReport, Timestamp) == 0x000040, "Member 'FPlayerReport::Timestamp' has a wrong offset!");
static_assert(offsetof(FPlayerReport, ServerName) == 0x000050, "Member 'FPlayerReport::ServerName' has a wrong offset!");
static_assert(offsetof(FPlayerReport, ScreenshotFilename) == 0x000060, "Member 'FPlayerReport::ScreenshotFilename' has a wrong offset!");
static_assert(offsetof(FPlayerReport, KillsDeathsTksTD) == 0x000070, "Member 'FPlayerReport::KillsDeathsTksTD' has a wrong offset!");
static_assert(offsetof(FPlayerReport, Messages) == 0x000080, "Member 'FPlayerReport::Messages' has a wrong offset!");

}

